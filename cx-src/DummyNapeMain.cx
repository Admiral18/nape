package;
$(import);

class Iso {
    public var value:Float;
    public function new() {}        
}

interface IsoFunction {
    public function iso(x:Float, y:Float):Float;        
}

class IsoIso {
    public function iso3(x:Float, y:Float):Float { return 0.0; }        
}

class DummyNapeMain implements IsoFunction, extends IsoIso {

    static function call1(iso:Float->Float->Float) {
        var sum = 0.0;
        for (i in 0...100) {
        for (j in 0...100) {
            sum += iso(i/2, j/2);                
        }
        }
        return sum;
    }

    static var __iso = new Iso();
    static function call2(iso:Float->Float->Iso->Void) {
        var sum = 0.0;
        for (i in 0...100) {
        for (j in 0...100) {
            iso(i/2, j/2, __iso);                
            sum += __iso.value;
        }
        }
        return sum;
    }

    static function call3(iso:IsoFunction) {
        var sum = 0.0;
        for (i in 0...100) {
        for (j in 0...100) {
            sum += iso.iso(i/2, j/2);                
        }
        }
        return sum;
    }

    static function call4(iso:IsoIso) {
        var sum = 0.0;
        for (i in 0...100) {
        for (j in 0...100) {
            sum += iso.iso3(i/2, j/2);                
        }
        }
        return sum;
    }

    public function iso(x:Float, y:Float):Float {
        return (Std.int(x)&0xff) - y;            
    }
    public function iso2(x:Float, y:Float, iso:Iso) {
        iso.value = (Std.int(x)&0xff) - y;            
    }
    public override function iso3(x:Float, y:Float):Float {
        return (Std.int(x)&0xff) - y;            
    }

    static function main() {
        var m = new DummyNapeMain();
        (new haxe.Timer(0)).run = m.goforit;
    }

    public function new() {}
    public function goforit() {
//        call1(iso);            
//        call2(iso2);
//        call3(this);
        call4(this);
    }

}
