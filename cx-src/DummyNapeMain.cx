package;

$(import);

#if cpp
class DummyNapeMain {
	static function main() {
		var w = 400;
		var h = 300;
		var fps = 60;
		var bgColor = 0x333333;
		var flags =
			nme.Lib.BORDERLESS |
			nme.Lib.HARDWARE |
			nme.Lib.VSYNC |
			0;
		var name = "Test Nape hxcpp/nme";

		nme.Lib.create(function() { new DummyNapeMain(); },w,h,fps,bgColor,flags,name);
	}

	function new() {
        var root = nme.Lib.current;
        Perlin3D.init_noise();

        var z = 0.0;
        var bnd = 0.0;
        var iso = function(x:Float,y:Float) return Perlin3D.noise(x/40,y/30,z)-bnd;

        var debug = new ShapeDebug(400,300,0xffffff);
        root.addChild(debug.display);

        var bounds  = new AABB(0,0,400,300);
        var cells   = new Vec2(5,5);
        var grid    = new Vec2(100,100);
        var quality = 2;

		var tim = new haxe.Timer(17);
        tim.run = function () {
            z += 1/30;
            bnd = Math.sin(z*0.3)*0.35;
            debug.clear();
            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
                var qs = p.convex_decomposition();
                for(q in qs) debug.drawFilledPolygon(q,colour(q));
                debug.drawPolygon(p,0);
            }
            debug.flush();
        }

		root.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
			tim.stop();
			var space = new Space(new Vec2(0,400));

			var border = new Body(BodyType.STATIC);
			border.shapes.add(new Polygon(Polygon.rect(0,0,-20,300)));
			border.shapes.add(new Polygon(Polygon.rect(400,0,20,300)));
			border.shapes.add(new Polygon(Polygon.rect(0,0,400,-20)));
			border.shapes.add(new Polygon(Polygon.rect(0,300,400,20)));
			border.space = space;

            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
				var body = new Body();
                var qs = p.convex_decomposition();
                for(q in qs) {
					body.shapes.add(new Polygon(q));
				}
				body.align();
				body.space = space;
			}

			(new haxe.Timer(17)).run = function() {
				debug.clear();
				space.step(1/60,10,5);
				debug.draw(space);
				debug.flush();
			}
		});
    }

    static inline function colour(p:GeomPoly) {
        //hue
        var h = p.area()/3000*360; while(h>360) h -= 360;
        var f = (h%60)/60;

        var r:Float, g:Float, b:Float;
        if     (h<=60 ) { r = 1; g = f; b = 0; }
        else if(h<=120) { r = 1-f; g = 1; b = 0; }
        else if(h<=180) { r = 0; g = 1; b = f; }
        else if(h<=240) { r = 0; g = 1-f; b = 1; }
        else if(h<=300) { r = f; g = 0; b = 1; }
        else            { r = 1; g = 0; b = 1-f; }

        return (Std.int(r*0xff)<<16)|(Std.int(g*0xff)<<8)|Std.int(b*0xff);
    }
}

class Perlin3D {
    public static inline function noise(x:Float, y:Float, z:Float) {
        var X = Std.int(x); x -= X; X &= 0xff;
        var Y = Std.int(y); y -= Y; Y &= 0xff;
        var Z = Std.int(z); z -= Z; Z &= 0xff;
        var u = fade(x); var v = fade(y); var w = fade(z);
        var A = p(X)  +Y; var AA = p(A)+Z; var AB = p(A+1)+Z;
        var B = p(X+1)+Y; var BA = p(B)+Z; var BB = p(B+1)+Z;
        return lerp(w, lerp(v, lerp(u, grad(p(AA  ), x  , y  , z   ),
                                       grad(p(BA  ), x-1, y  , z   )),
                               lerp(u, grad(p(AB  ), x  , y-1, z   ),
                                       grad(p(BB  ), x-1, y-1, z   ))),
                       lerp(v, lerp(u, grad(p(AA+1), x  , y  , z-1 ),
                                       grad(p(BA+1), x-1, y  , z-1 )),
                               lerp(u, grad(p(AB+1), x  , y-1, z-1 ),
                                       grad(p(BB+1), x-1, y-1, z-1 ))));
    }

    static inline function fade(t:Float) return t*t*t*(t*(t*6-15)+10)
    static inline function lerp(t:Float, a:Float, b:Float) return a + t*(b-a)
    static inline function grad(hash:Int, x:Float, y:Float, z:Float) {
        var h = hash&15;
        var u = h<8 ? x : y;
        var v = h<4 ? y : h==12||h==14 ? x : z;
        return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
    }

    static inline function p(i:Int) return perm[i]
    static var perm:Array<Int>;
    
    public static function init_noise() {
		perm = new Array<Int>();

        var p = [151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

        for(i in 0...256) {
            perm[i]=    p[i];
            perm[256+i]=p[i];
        }
    }
}


#elseif swc
class DummyNapeMain {
	static function main() {}
}

#else 

class Tracer {
	static public function trace(objs:Array<Dynamic>,txt:flash.text.TextField) {
		var dict_id = 0;
		var stack = [];
		var dict = new flash.utils.Dictionary(false);
		var idl = [];

		$(mixin pushobj(i) ({
			if((untyped dict[i])!=null) (untyped dict[i]).id;
			else {
				var o = { id: dict_id++, obj:i, refs:[] };
				untyped dict[i] = o;
				stack.push(o);
				idl.push(o);
				o.id;
			}
		}));

		for(i in objs) pushobj(i);
		var tim = new haxe.Timer(0);

		var fcnt = 0;
		var finish = function() {	
			var pt = flash.Lib.getTimer();
			var buf = "";
			while(flash.Lib.getTimer()-pt <= 50) {
				if(fcnt >= idl.length) {
					txt.text += buf+"\n\nDONE";
					txt.scrollV = txt.maxScrollV;
					tim.stop();
					return;
				}
				var i = idl[fcnt++];
				buf += "id: "+i.id+" refs:"+Std.string(i.refs)+" = "+Std.string(i.obj)+"\n";
			}
			txt.text += buf;
			txt.scrollV = txt.maxScrollV;
		}
		
		var cnnt = 0;
		tim.run = function() {
			txt.text = "running: stack size="+stack.length+" cnt="+cnnt;

			if(stack.length==0) { tim.run = finish; txt.text = ""; return; }

			var pt = flash.Lib.getTimer();
			while(flash.Lib.getTimer()-pt <= 50) {
				if(stack.length==0) { tim.run = finish; txt.text = ""; return; }

				var cur = stack.shift();
				cnnt++;
				var cls = Type.getClass(cur.obj);
				for(o in Type.getInstanceFields(cls)) {
					var field:Dynamic = Reflect.field(cur.obj, o);
					if(field!=null && Reflect.isObject(field)) {
						cur.refs.push({ name:o, id:	pushobj(field) });
					}
				}
			}
		}
	}
}

class DummyNapeMain {
	static function main() {
		var root = flash.Lib.current;
		var space = new Space();
		var debug = new BitmapDebug(600,600,0x333333);
		root.addChild(debug.display);

		var b1 = new Body(); 
		var b2 = new Body();
		b1.position = b2.position = new Vec2(100,100);

		b1.shapes.add(new Circle(50));
		b2.shapes.add(new Circle(50));

		b1.space = space;
		b2.space = space;

		var begin = new InteractionListener(CbEvent.BEGIN, b1.cbType, b2.cbType, function (x:Arbiter) {
			trace("BEGIN "+b1.cbType+":"+b2.cbType);
		});
		begin.space = space;

		(new haxe.Timer(0)).run = function() {
			debug.clear();

			space.step(1/60,10,10);
			debug.draw(space);

			debug.flush();
		}
	}
}

import flash.Lib;
import flash.utils.ByteArray;
import flash.Memory;

class DummyNapeMaixdsn {
public static var debug:Debug;
static function main() {
        var root = Lib.current;
        Perlin3D.init_noise();

        var z = 0.0;
        var bnd = 0.0;
        var iso = function(x:Float,y:Float) return Perlin3D.noise(x/40,y/30,z)-bnd;

        /*var */debug = new ShapeDebug(400,300,0xffffff);
        root.addChild(debug.display);

        var bounds  = new AABB(0,0,400,300);
        var cells   = new Vec2(5,5);
        var grid    = new Vec2(100,100);
        var quality = 2;

        (new haxe.Timer(17)).run = function () {
            z += 1/30;
            bnd = Math.sin(z*0.3)*0.35;
            debug.clear();
            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
//                debug.drawFilledPolygon(p,colour(p));
//                var p2 = p.simplify(1);
//              if(!p2.isDegenerate()) {
//                debug.drawPolygon(p,
                debug.drawPolygon(p,0xff0000);
                    var qs = p.convex_decomposition();
                     for(q in qs) debug.drawFilledPolygon(q,colour(q));
//              }
                debug.drawPolygon(p,0);
            }
//          for(p in polys) debug.drawFilledPolygon(p,colour(p));
            debug.flush();
        }
    }

    static inline function colour(p:GeomPoly) {
        //hue
        var h = p.area()/3000*360; while(h>360) h -= 360;
        var f = (h%60)/60;

        var r:Float, g:Float, b:Float;
        if     (h<=60 ) { r = 1; g = f; b = 0; }
        else if(h<=120) { r = 1-f; g = 1; b = 0; }
        else if(h<=180) { r = 0; g = 1; b = f; }
        else if(h<=240) { r = 0; g = 1-f; b = 1; }
        else if(h<=300) { r = f; g = 0; b = 1; }
        else            { r = 1; g = 0; b = 1-f; }

        return (Std.int(r*0xff)<<16)|(Std.int(g*0xff)<<8)|Std.int(b*0xff);
    }
}

class Perlin3D {
    public static inline function noise(x:Float, y:Float, z:Float) {
        var X = Std.int(x); x -= X; X &= 0xff;
        var Y = Std.int(y); y -= Y; Y &= 0xff;
        var Z = Std.int(z); z -= Z; Z &= 0xff;
        var u = fade(x); var v = fade(y); var w = fade(z);
        var A = p(X)  +Y; var AA = p(A)+Z; var AB = p(A+1)+Z;
        var B = p(X+1)+Y; var BA = p(B)+Z; var BB = p(B+1)+Z;
        return lerp(w, lerp(v, lerp(u, grad(p(AA  ), x  , y  , z   ),
                                       grad(p(BA  ), x-1, y  , z   )),
                               lerp(u, grad(p(AB  ), x  , y-1, z   ),
                                       grad(p(BB  ), x-1, y-1, z   ))),
                       lerp(v, lerp(u, grad(p(AA+1), x  , y  , z-1 ),
                                       grad(p(BA+1), x-1, y  , z-1 )),
                               lerp(u, grad(p(AB+1), x  , y-1, z-1 ),
                                       grad(p(BB+1), x-1, y-1, z-1 ))));
    }

    static inline function fade(t:Float) return t*t*t*(t*(t*6-15)+10)
    static inline function lerp(t:Float, a:Float, b:Float) return a + t*(b-a)
    static inline function grad(hash:Int, x:Float, y:Float, z:Float) {
        var h = hash&15;
        var u = h<8 ? x : y;
        var v = h<4 ? y : h==12||h==14 ? x : z;
        return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
    }

    static inline function p(i:Int) return perm[i]
    static var perm:flash.Vector<Int>;
    
    public static function init_noise() {
        var bd = new ByteArray();
        bd.length = 8096;
        Memory.select(bd);

		  perm = new flash.Vector<Int>(512,true);

        var p = [151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

        for(i in 0...256) {
            perm[i]=    p[i];
            perm[256+i]=p[i];
        }
    }
}

class XxDummyNapeMain {
	static public var debug:Debug;

	static function mains() {
		var debug = new BitmapDebug(600,600,0xffffff);
		var grav = new Vec2(0,20*30);
		var world = new Space(grav);

		var dyn = new Body();
		dyn.position.setxy(100,100);
		var filter = new InteractionFilter(1,-1);
		var mat = new Material(0.1,0.5,0.5,0.5,0.1);
		mat.shared = true;

		var shape:Shape = new Circle(10, new Vec2(0,0), mat,filter);
		dyn.type = BodyType.DYNAMIC;
		dyn.allowRotation = false;
		dyn.gravMass = 0;
		dyn.shapes.add(shape);
		world.bodies.add(dyn);

		filter = new InteractionFilter(128,0);
		var anchor = new Body();
		anchor.position.setxy(20,200);
		anchor.type = BodyType.STATIC;
		shape = new Polygon(Polygon.box(100,100), mat,filter);
		anchor.shapes.add(shape);
		world.bodies.add(anchor);

		var joint = new LineJoint(anchor,dyn,new Vec2(),new Vec2(),new Vec2(1,0),0,2000);
		world.constraints.add(joint);

		var c = flash.Lib.current;
		c.addChild(debug.display);

		var tim = new haxe.Timer(Std.int(1000/60));
		tim.run = function() {
			world.step(1/60,37,37);

			var mat = new Mat23();
			debug.transform = mat;
			debug.clear();
			debug.draw(world);
			debug.flush();
		}

		haxe.Timer.delay(function(){
			joint.space = null; 
			anchor.space = null;
			dyn.space = null;
		},1000);
	}



	static function maisfn() {
		var c = flash.Lib.current;
//		haxe.Log.setColor(0xffffff);

		debug = new ShapeDebug(600,600,0x333333);
		debug.drawShapeAngleIndicators = false;
		c.addChild(debug.display);

		var f = function(x:Float,y:Float):Float {
			var dx = x-300;
			var dy = y-300;
//			return dx*dx+dy*dy-200*200;
			var del = dx*dx+dy*dy;
			del = (150-Math.sqrt(del));
//			del = del*del - 50*50;
			del = Math.sin(0.2*(del-50));
			return  10000 + del*0.5 - dx*dx+dy*dy-300*300*Math.cos((dx*dx+dy)*7e-4)*Math.sin((dy*dx)*5e-4);
		}

		var space = new Space(new Vec2(0,400));

		var border = new Body(BodyType.STATIC);
		border.shapes.add(new Polygon(Polygon.rect(0,0,-40,600)));
		border.shapes.add(new Polygon(Polygon.rect(600,0,40,600)));
		border.shapes.add(new Polygon(Polygon.rect(0,0,600,-40)));
		border.shapes.add(new Polygon(Polygon.rect(0,600,600,40)));
		border.space = space;

//		var polys = MarchingSquares.run(f, new AABB(0,0,600,600), new Vec2(5,5), 10, true);
		var polys = MarchingSquares.run(f, new AABB(0,0,600,600), new Vec2(20,20), 2, true);
		for(p in polys) {
			var qs = p.simplify(1).convex_decomposition();
			var b = new Body();
			for(q in qs) {
				var s = q;
				if(!s.isDegenerate()) {
					b.shapes.add(new Polygon(s));
				}
			}
			if(!b.shapes.empty()) {
				b.align();
				b.space = space;
			}
		}

		debug.draw(space);
		debug.flush();

		var mcon = new PivotJoint(space.world,space.world,new Vec2(), new Vec2());
		mcon.stiff = false;
		mcon.maxForce = 100000;
		mcon.active = false;
		mcon.space = space;

		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			var pv = Vec2.get(c.mouseX,c.mouseY);
			var bods = space.bodiesUnderPoint(pv);
			for(b in bods) {
				if(!b.isDynamic()) continue;

				mcon.body1 = b;
				mcon.anchor1 = b.worldToLocal(pv);
				mcon.active = true;
				break;
			}
		});
		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
			mcon.active = false;
		});

	    var txt = new flash.text.TextField();
	    txt.defaultTextFormat = new flash.text.TextFormat("Courier New",null,0);
	    txt.width = txt.height = 600;
	    txt.selectable = false;
		txt.multiline = true;
	    c.addChild(txt);

		(new haxe.Timer(0)).run = function() {
			debug.clear();

			mcon.anchor2.setxy(c.mouseX,c.mouseY);
			space.step(1/120,6,3);
			space.step(1/120,6,3);

			debug.draw(space);
			debug.flush();

			txt.text = "";
			#if NAPE_POOL_STATS
				txt.text += PR(POOL_STATS).dump();
			#end
			#if NAPE_TIMES
				txt.text += Debug.TIMES(space);
			#end
		}
	}

	static function maiaergn() {
		var c = flash.Lib.current;
		haxe.Log.setColor(0xffffff);

		var space = new Space(new Vec2(0,600));

		debug = new BitmapDebug(600,600,0x333333);
		debug.drawShapeAngleIndicators = false;
		c.addChild(debug.display);

		var border = new Body(BodyType.STATIC);
		border.shapes.add(new Polygon(Polygon.rect(0,0,-40,600)));
		border.shapes.add(new Polygon(Polygon.rect(600,0,40,600)));
		border.shapes.add(new Polygon(Polygon.rect(0,0,600,-40)));
		border.shapes.add(new Polygon(Polygon.rect(0,600,600,40)));
		border.space = space;

		var gp:GeomPoly = null;
		var pre:Vec2 = null;
		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			gp = new GeomPoly();
			gp.push(pre = Vec2.get(c.mouseX,c.mouseY));
		});
		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
/*			if(gp!=null && gp.size()>3) {
				var polys = gp.simplify(3).simple_decomposition();
				for(p in polys) {
					var body = new Body();
					var cons = p.convex_decomposition();
					for(c in cons) {
						body.shapes.add(new Polygon(c));
						c.clear();
					}
					body.align();
					body.space = space;
					p.clear();
				}
			}*/
		//	gp = null;
		});

	        var txt = new flash.text.TextField();
	        txt.defaultTextFormat = new flash.text.TextFormat("Courier New",null,0xffffff);
	        txt.width = txt.height = 600;
	        txt.selectable = false;
		txt.multiline = true;
	        c.addChild(txt);

		(new haxe.Timer(0)).run = function() {
			debug.clear();

			if(gp!=null) {
				var cur = Vec2.get(c.mouseX,c.mouseY);
				if(cur.sub(pre).length>5) {
					gp.push(cur);
					pre = cur;
				}
		
				MarchingSquares.run(function(x,y) return gp.contains(Vec2.get(x,y)) ? -1.0 : 1.0, new AABB(0,0,600,600), new Vec2(10,10), 2);	

				debug.drawPolygon(gp,0xff0000);
			/*	var v = gp.current();
				do {
					debug.drawFilledCircle(gp.current(),0.5,0xffff);
					gp.skip_forward(1);
				} while(gp.current() != v);

				var gp2 = gp.simplify(3);
				debug.drawPolygon(gp2,0x808080);
				var v = gp2.current();
				do {
					debug.drawFilledCircle(gp2.current(),0.5,0xff0000);
					gp2.skip_forward(1);
				} while(gp2.current() != v);*/
			}

			space.step(1/60,20,10);
			debug.draw(space);
			debug.flush();

			txt.text = "";
			#if NAPE_POOL_STATS
				txt.text += PR(POOL_STATS).dump();
			#end
			#if NAPE_TIMES
				txt.text += Debug.TIMES(space);
			#end
		}
	}



	static function mainss() {
		var c = flash.Lib.current;

		var P = [];
		trace(Debug.version());

		$(mixin v2(x,y) Vec2.get(x,y));

//		P = [v2(0,0),v2(200,0),v2(200,200),v2(100,200),v2(110,175),v2(100,150),v2(150,150),v2(150,50),v2(50,50),v2(50,150),v2(100,150),v2(110,175),v2(100,200),v2(0,200)];	

//		P = [v2(0,0),v2(300,0),v2(300,100),v2(200,100),v2(100,200),v2(80,200),v2(50,300),v2(80,200),v2(100,200),
//			 v2(200,100),v2(300,100),
//			 v2(300,300),v2(150,300),v2(150,400),v2(-50,400)];
//		P = [v2(0,0),v2(300,0),v2(300,200),v2(260,100),v2(225,150),v2(235,100),v2(227,50),v2(225,150),v2(260,100),v2(300,200),v2(300,300),v2(0,300)];
//		P = [v2(0,0),v2(300,0),v2(300,300),v2(100,300),v2(100,200),v2(200,200),v2(200,100),v2(100,100),v2(100,200),v2(0,200)];

//		P = [v2(0,0),v2(500,0),v2(500,200),v2(400,200),v2(400,100),v2(300,100),v2(300,200),v2(200,200),v2(200,100),v2(100,100),v2(100,300),v2(200,300),v2(200,200),v2(300,200),v2(300,300),v2(400,300),v2(400,200),v2(500,200),v2(500,400),v2(0,400)];

		debug = new BitmapDebug(600,600,0xFFFFFF);
		debug.clear();
		debug.transform.tx = 100;
		debug.transform.ty = 100;
		c.addChild(debug.display);

		var sdebug = new ShapeDebug(600,600,0xFFFFFF);
		c.addChild(sdebug.display);
		sdebug.display.alpha = 0.5;

        var txt = new flash.text.TextField();
        txt.defaultTextFormat = new flash.text.TextFormat("Courier New",null,0);
        c.addChild(txt);
        txt.width = 600;
        txt.height = 600;
        txt.selectable = false;
		txt.multiline = true;

		$(mixin colour() {
			var col = Std.int(0x80*Math.random())+0x60;
			var col1 = Std.int(0x80*Math.random())+0x60;
			var col2 = Std.int(0x80*Math.random())+0x60;
			col | (col1<<16) | (col2<<8);
		});

		$(mixin scalec(col) {
			var fact = Math.random()*0.2+0.8;
			var r = Std.int((col>>16)*fact);
			var g = Std.int(((col>>8)&0xff)*fact);
			var b = Std.int(((col)&0xff)*fact);
			(r<<16) | (g<<8) | (b);
		});
	
		if(P.length>0) {
		debug.drawPolygon(P,0xff0000);
		debug.flush();

//		debug.drawFilledPolygon(P,0x808080);
//		for(p in (new GeomPoly(P)).convex_decomposition()) debug.drawFilledPolygon(p.toArray(),colour);
		for(p in (new GeomPoly(P)).monotone_decomposition()) {
			var col = colour;
//			for(q in p.convex_decomposition()) debug.drawFilledPolygon(q.toArray(),scalec(col));
		}

		debug.drawPolygon(P,0xff0000);
		var index = 0;
		for(p in P)
			debug.drawFilledCircle(p,2,0xffff);
		debug.flush();
		}

//		for(p in (new GeomPoly(P)).monotone_decomposition()) debug.drawPolygon(p.toArray(),0xffffff);
//		debug.flush();
		debug.transform.setAs();
		P = [];
//P = [Vec2.get(208,317),Vec2.get(184,290),Vec2.get(155,247),Vec2.get(132,197),Vec2.get(134,148),Vec2.get(157,128),Vec2.get(179,114),Vec2.get(207,107),Vec2.get(238,107),Vec2.get(269,125),Vec2.get(281,149),Vec2.get(264,168),Vec2.get(235,159),Vec2.get(219,137),Vec2.get(204,107),Vec2.get(212,83),Vec2.get(250,58),Vec2.get(283,52),Vec2.get(312,52),Vec2.get(346,59),Vec2.get(395,76),Vec2.get(445,97),Vec2.get(474,123),Vec2.get(484,155),Vec2.get(491,196),Vec2.get(486,235),Vec2.get(474,266),Vec2.get(447,293),Vec2.get(414,308),Vec2.get(380,315),Vec2.get(348,313),Vec2.get(299,298),Vec2.get(253,277),Vec2.get(219,244),Vec2.get(194,218),Vec2.get(176,193),Vec2.get(166,162),Vec2.get(159,135),Vec2.get(158,109),Vec2.get(165,82),Vec2.get(184,56),Vec2.get(208,48)];
//P=[Vec2.get(217,387),Vec2.get(210,362),Vec2.get(196,321),Vec2.get(194,295),Vec2.get(194,261),Vec2.get(195,232),Vec2.get(206,199),Vec2.get(220,175),Vec2.get(250,157),Vec2.get(285,157),Vec2.get(317,174),Vec2.get(333,195),Vec2.get(332,226),Vec2.get(326,255),Vec2.get(322,285),Vec2.get(329,322),Vec2.get(351,346),Vec2.get(385,349),Vec2.get(411,312),Vec2.get(412,283),Vec2.get(409,249),Vec2.get(400,216),Vec2.get(388,186),Vec2.get(372,149),Vec2.get(362,119),Vec2.get(379,96),Vec2.get(410,99),Vec2.get(420,122),Vec2.get(430,161),Vec2.get(435,189),Vec2.get(435,217),Vec2.get(435,246),Vec2.get(433,277),Vec2.get(444,306),Vec2.get(469,316),Vec2.get(488,287),Vec2.get(499,241),Vec2.get(501,209),Vec2.get(501,175),Vec2.get(494,150),Vec2.get(484,126),Vec2.get(477,92),Vec2.get(478,54),Vec2.get(503,72),Vec2.get(536,131),Vec2.get(560,183),Vec2.get(568,226),Vec2.get(566,270),Vec2.get(564,314),Vec2.get(564,345),Vec2.get(564,380),Vec2.get(566,416),Vec2.get(567,445),Vec2.get(567,477),Vec2.get(554,506),Vec2.get(516,517),Vec2.get(480,521),Vec2.get(451,528),Vec2.get(418,529),Vec2.get(384,529),Vec2.get(338,524),Vec2.get(301,517),Vec2.get(250,512),Vec2.get(220,513),Vec2.get(187,513),Vec2.get(161,508),Vec2.get(134,491),Vec2.get(102,466),Vec2.get(71,434),Vec2.get(62,403),Vec2.get(59,368),Vec2.get(60,327),Vec2.get(71,281),Vec2.get(82,243),Vec2.get(91,213),Vec2.get(102,188),Vec2.get(113,159),Vec2.get(118,129),Vec2.get(122,98),Vec2.get(128,67),Vec2.get(150,51),Vec2.get(175,55),Vec2.get(188,78),Vec2.get(187,112),Vec2.get(178,142),Vec2.get(162,183),Vec2.get(149,228),Vec2.get(137,272),Vec2.get(132,318),Vec2.get(132,366),Vec2.get(135,392),Vec2.get(143,417),Vec2.get(156,442),Vec2.get(184,453),Vec2.get(211,454),Vec2.get(236,440),Vec2.get(246,404),Vec2.get(248,365),Vec2.get(239,320),Vec2.get(228,287),Vec2.get(233,260),Vec2.get(252,242),Vec2.get(274,230),Vec2.get(307,239),Vec2.get(333,256),Vec2.get(350,276),Vec2.get(358,309),Vec2.get(356,342),Vec2.get(358,368),Vec2.get(372,405),Vec2.get(397,423),Vec2.get(423,420),Vec2.get(447,400),Vec2.get(448,374),Vec2.get(438,350),Vec2.get(424,323),Vec2.get(419,295),Vec2.get(416,267),Vec2.get(419,240),Vec2.get(431,217),Vec2.get(453,204)];

//P = [v2(100,100),v2(300,100),v2(300,300),v2(200,100),v2(100,300)];
//P = [v2(100,100),v2(300,100),v2(300,300),v2(200,100),v2(100,300),v2(250,150),v2(350,200),v2(284,225)];
//P = [v2(100,100),v2(300,100),v2(300,300),v2(150,150),v2(250,150),v2(100,300)];

//P = [v2(100,100),v2(200,100),v2(150,150),v2(100,200),v2(200,200),v2(150,150)];
P = [v2(100,100),v2(200,100),v2(100,200),v2(200,200),v2(125,125),v2(125,150),v2(175,150)];
		var mdown = false;
		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			mdown = true;
			P.push(new Vec2(c.mouseX,c.mouseY));
		});
		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function(_) { mdown = false; P = []; });

		var tim = new haxe.Timer(0);
		var pl = P.length*0;
		tim.run = function() {
			if(mdown) {
				var p = new Vec2(c.mouseX,c.mouseY);
				if(p.sub(P[P.length-1]).length>5) P.push(p);
			}

			if(P.length>=3 && P.length!=pl) {
				pl = P.length;
				debug.clear();

//		if((new GeomPoly(P)).isSimple())
//			PR(Simple).decompose((new GeomPoly(P)).pr(inner).vertices);
//try {
		var ps = (new GeomPoly(P)).simple_decomposition();
		debug.drawFilledPolygon(P,0xff00);
		debug.flush();
		
		tim.stop(); return;


//		sdebug.clear();
//		sdebug.drawFilledPolygon(P,0xff0000);
//		sdebug.drawPolygon(P,0xff00ff);
try{
					}catch(e:Dynamic) {
						tim.stop();

						var ret = Std.string(e);

						ret += "\n\n[";
						var fst = true;
						for(i in P) {
							if(!fst) ret += ",";
							fst = false;
							ret += "Vec2.get("+i.x+","+i.y+")";
						}
						ret += "]";
						throw ret;

						throw e;
					}
/*
		for(poly in (new GeomPoly(P)).simple_decomposition()) {
			var col = colour;
			for(p in poly.monotone_decomposition()) {
				for(q in p.convex_decomposition()) debug.drawFilledPolygon(q.toArray(),scalec(col));
			}
		}
		debug.drawPolygon(P,0x0);
		debug.flush();*/
/*

//				debug.drawFilledPolygon(P,0x808080);
//				debug.drawPolygon(P,((new GeomPoly(P)).isSimple()) ? 0xff0000 : 0xffffff);
//				for(i in P) debug.drawCircle(i,1.5,0xff8000);
//				if((new GeomPoly(P)).isSimple()) {
//					try {
//					var polys = new GeomPoly(P).monotone_decomposition();
//					for(p in polys) debug.drawPolygon(p.toArray(),0xff00);

//					var polys = new GeomPoly(P).convex_decomposition();
//					for(p in polys) debug.drawPolygon(p.toArray(),0xffff00);
/*					}catch(e:Dynamic) {
						tim.stop();

						var ret = "[";
						var fst = true;
						for(i in P) {
							if(!fst) ret += ",";
							fst = false;
							ret += "Vec2.get("+i.x+","+i.y+")";
						}
						ret += "]";
						throw ret;

						throw e;
					}*/
//				}
				debug.flush();

			txt.text = "";
			#if NAPE_POOL_STATS
				txt.text += PR(POOL_STATS).dump()+"\n";
			#end

			}
		};
	}


	static function mainsp() {
        var c = flash.Lib.current;
        haxe.Log.setColor(0xffffff);

//		var space = new Space(new Vec2(0,400),Broadphase.SWEEP_AND_PRUNE);
		var space = new Space();
		/*var*/ debug = new BitmapDebug(600,600,0x333333);
//		/*var*/ debug = new ShapeDebug(600,600,0x333333);
        c.addChild(debug.display);
//		debug.cullingEnabled = true;

        var txt = new flash.text.TextField();
        txt.defaultTextFormat = new flash.text.TextFormat("Courier New",null,0xffffff);
        c.addChild(txt);
        txt.width = 600;
        txt.height = 600;
        txt.selectable = true;
		txt.multiline = true;

        var pt = flash.Lib.getTimer();

//        debug.drawConstraints = true;
        c.stage.quality = flash.display.StageQuality.LOW;

		var bb = new Body();
		bb.shapes.add(new Circle(10));
		bb.space = space;

		var mcon = new PivotJoint(space.world,space.world, new Vec2(), new Vec2());

		mcon.stiff = false;
		mcon.maxForce = 50000;
//		var mcon:Dynamic = null;

		var init = function() {
//			var bods = space.bodies.copy();

			space.clear();
			space.gravity.setxy(0,400);
/*
			for(b in bods) {
				b.space = space;
				if(b.isDynamic()) {
					b.velocity.y -= 50;
					b.rotation += 1;
				}
			}
			bods.clear();

			mcon.active = false;
			mcon.space = space;*/
//		}

		var walls = new Body(BodyType.STATIC);
		for(i in 0...10) {
			walls.clear();
			walls.shapes.add(new Polygon(Polygon.rect(-9*5+i*5,550,600,50)));
			walls.shapes.add(new Polygon(Polygon.rect(0,0,600,50)));
			walls.shapes.add(new Polygon(Polygon.rect(0,0,50,600)));
			walls.shapes.add(new Polygon(Polygon.rect(550,0,50,600)));
		}
		walls.space = space;
	
		for(i in 0...4) {
			var b = new Body();
			var s = new Circle(60);
			s.fluidEnabled = true;
			s.fluidProperties.density = 2;
			s.material.density = 2;
			s.body = b;
			space.bodies.add(b);
			b.position.setxy(Math.random()*500+50,Math.random()*500+50);
			s.filter.fluidGroup = 2;
			s.filter.fluidMask = 1;
		}

		var pre:Body = null;	
		for(i in 0...450) {
			var b = new Body();
			b.shapes.add(new Polygon(Polygon.box(16,16)));
			var xi = i%18;
			var yi =Std.int( (i-xi)/18);
			b.position.setxy(50+xi*16,50+yi*16);
			b.space = space;

            if(pre!=null && false) {
				var mid = pre.position.add(b.position).muleq(0.5);
				space.constraints.add(new PivotJoint(pre,b,pre.worldToLocal(mid),b.worldToLocal(mid)));
			}

			pre = b;
			if((i+1)%18==0) pre = null;
		}

		mcon.active = false;
		mcon.space = space;
	}

		var mat:Mat23 = new Mat23();

		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (ev) {
			var pv = mat.inverse_transform(new Vec2(c.mouseX,c.mouseY));
			var bods:BodyList = null;
			bods = space.bodiesUnderPoint(pv);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
					mcon.anchor2 = b.worldToLocal(pv);
					mcon.active = true;
					break;
				}
			}
		});
		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (ev) {
			mcon.active = false;
		});
        
		var tim2 = new haxe.Timer(3000); //5000
		tim2.run = function() { for(i in 0...10) init(); }
//		tim2.run = function() { init(); }
		init();
//		Tracer.trace([space],txt);
//		return;

		var tim2 = new haxe.Timer(100); //1000
/*		tim2.run = function () { 
			mat = new Mat23(2*Math.random()-1,2*Math.random()-1,2*Math.random()-1,2*Math.random()-1,Math.random()*100-50,Math.random()*100-50).equiorthogonalise();
			mat = Mat23.translation(-300,-300).concat(mat).concat(Mat23.translation(300,300));	
		}*/

		var tim = new haxe.Timer(0);

        tim.run = function() {
            var ct = flash.Lib.getTimer();
            var dt = (ct-pt)/1000;
            pt = ct;

            debug.clear();
			mcon.anchor1.set(mat.inverse_transform(new Vec2(c.mouseX,c.mouseY)));

			if(!space.dynamics.empty()) {
				var b = space.dynamics.at(Std.int(space.dynamics.length*Math.random()));
				b.space = null;
				while(!b.constraints.empty()) {
					b.constraints.at(0).space = null;
				}
			}

            space.step(1/40,8,4);
            
            #if NAPE_TIMES var pt = flash.Lib.getTimer(); #end
			debug.transform = mat;
            debug.draw(space);
            #if NAPE_TIMES Debug.DRAW += flash.Lib.getTimer()-pt; #end

			txt.text = "";
			#if NAPE_POOL_STATS
				txt.text += PR(POOL_STATS).dump()+"\n";
			#end

            txt.text += "fps: "+Std.string(1/dt).substr(0,5)+"\n";

            #if NAPE_TIMES
                txt.text += "\n"+Debug.TIMES(space);
            #end

			var prec = function(x:Float,y:Int) {
				return Std.string(Std.int(x*Math.pow(10,y))*Math.pow(10,-y));
			}
			var mem = function(x:Float) {
				if(x<1024) return Std.string(x)+"B";
				else if(x<1024*1024) return prec(x/1024,2)+"KiB";
				else                 return prec(x/1024/1024,2)+"MiB";
			};

			txt.text += "\n\nMAX: "+mem(flash.system.System.totalMemory);
			txt.text +=   "\nCUR: "+mem(flash.system.System.totalMemory-flash.system.System.freeMemory);

            debug.flush();
		}
	}
}
#end
