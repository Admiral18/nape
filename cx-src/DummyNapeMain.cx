
package;
$(import);


class DummyNapeMain {
    public static var debug:Debug;
    static function mains() {
        var b1 = new Body(BodyType.STATIC);
        b1.shapes.add(new Polygon(Polygon.rect(0, 100, 100, 100)));

        var b2 = new Body();
        b2.shapes.add(new Polygon(Polygon.box(100, 10)));
        b2.rotation = 0.4;

        b2.position.x = 50;
        b2.position.y = 101 - (b2.bounds.max.y - b2.position.y);

        b2.angularVel = -100;

        trace(b2.shapes.at(0).castPolygon.worldVerts);
        var s = new Space();
        b1.space = b2.space = s;

        s.step(1, 10, 10);
    }

    static function main() {
        var s = new Space(new Vec2(0, 400), Broadphase.SWEEP_AND_PRUNE);

        var t = new flash.text.TextField();
        flash.Lib.current.addChild(t);

//        for (i in 28...29)
        for (i in 0...1)
        {
            var b1 = new Body();
            var w = 5 + i * 1.5;
            var h = 1;
            var w = 5;
            var h = 5;
            b1.shapes.add(new Polygon(Polygon.box(30, 30)));
//            b1.shapes.add(new Circle(15));
            var v = i%6;
            var u = (i - v) / 6;
            b1.position.x = 100 + u * 20;
            b1.position.y = 100 + (v * 30);
            b1.velocity.y = 600;
            b1.velocity.x = 60*(10 + i*2);
            b1.space = s;
            b1.userData.px = b1.position.x;
            b1.userData.py = b1.position.y;

            //b1.setShapeFilters(new InteractionFilter(2, 1));
        }

        debug = new BitmapDebug(600,600,0x333333);
        flash.Lib.current.addChild(debug.display);

        var hand = new PivotJoint(s.world, null, new Vec2(), new Vec2());
        hand.stiff = false;
        hand.active = false;
        hand.space = s;

        flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
            var x = flash.Lib.current.mouseX;
            var y = flash.Lib.current.mouseY;
            var v = Vec2.get(x, y);
            var bodies = s.bodiesUnderPoint(v);
            for (b in bodies)
            {
                hand.body2 = b;
                hand.anchor2 = b.worldToLocal(v);
                hand.active = true;
                return;
            }
        });
        flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
            hand.active = false;
        });

        var c:Shape;
        var b2 = new Body(BodyType.KINEMATIC);
        b2.shapes.add(new Polygon(Polygon.rect(50, 50, 500, 1)));
        b2.shapes.add(new Polygon(Polygon.rect(50, 50, 1, 500)));
        b2.shapes.add(new Polygon(Polygon.rect(50, 550, 500, 1)));
        b2.shapes.add(new Polygon(Polygon.rect(550, 50, 1, 500)));
        b2.space = s;

        var cb:CbType;
        b2.cbTypes.add(cb = new CbType());
        b2.shapes.add(new Polygon(Polygon.rect(150, 275, 300, 1)));

//        s.visitBodies(function (b) b.shapes.foreach(function (s) s.material.elasticity = 0.7));

        s.listeners.add(new PreListener(InteractionType.COLLISION, cb, CbType.ANY_BODY.excluding(cb), function (cb) {
            cb.arbiter.collisionArbiter.contacts.clear();
            return null;
        }));

        debug.drawCollisionArbiters = true;
        var f = function() {
            debug.clear();
            var x = flash.Lib.current.mouseX;
            var y = flash.Lib.current.mouseY;
            hand.anchor1.setxy(x, y);
            //b2.velocity.y = 800 * Math.cos(s.elapsedTime*20);
            s.step(1/60, 10, 10);
            debug.draw(s);
            s.liveBodies.foreach(function (b) {
                debug.drawLine(Vec2.weak(b.userData.px, b.userData.py), b.position, 0xffffff);
                b.userData.px = b.position.x;
                b.userData.py = b.position.y;
            });
            debug.flush();
        };
        (new haxe.Timer(500)).run = f;
        f();
    }
}

/*
package;
$(import);


class DummyNapeMain {
    public static var debug:Debug;
    static function main() {
        var b1 = new Body();
        b1.shapes.add(new Polygon(Polygon.box(1, 400)));
//        b1.shapes.add(new Circle(40, new Vec2(100, 0)));

        debug = new ShapeDebug(1, 1);
        flash.Lib.current.addChild(debug.display);

        var b2 = new Body();
        b2.shapes.add(new Polygon(Polygon.box(1, 40)));
//        b2.shapes.add(new Circle(40, new Vec2(100, 0)));
        //b2.shapes.add(new Circle(40, new Vec2(-40, 0)));
        b2.position.x = b2.position.y = 300;

        (new haxe.Timer(0)).run = function () {
            b1.position.x = flash.Lib.current.mouseX;
            b1.position.y = flash.Lib.current.mouseY;
            b1.rotation = 0;

            b2.position.x = b2.position.y = 300;
            b2.rotation = 0;

//            b1.velocity.x = -150;
//            b1.velocity.y = 150;
//            b1.angularVel = -Math.PI;

            b2.velocity.x = 50;
            b2.velocity.y = 50;
            b2.angularVel = Math.PI*10;
            b2.angularVel = min(b2.angularVel, Math.PI*2/2);

            debug.clear();
            debug.draw(b1);
            debug.draw(b2);

            for(s1 in b1.shapes)
            {
                for (s2 in b2.shapes)
                {
                    s1.pr(inner).validate_aabb();
                    s2.pr(inner).validate_aabb();
                    s1.pr(inner).validate_sweepRadius();
                    s2.pr(inner).validate_sweepRadius();
                    if (s1.pr(inner).isPolygon()) s1.pr(inner).polygon.validate_gaxi();
                    if (s2.pr(inner).isPolygon()) s2.pr(inner).polygon.validate_gaxi();
                }
            }

            var toi = new PR(ToiEvent)();
            toi.s2 = b1.shapes.at(0).pr(inner);
            toi.s1 = b2.shapes.at(0).pr(inner);
            b1.pr(inner).sweepTime = 0;
            b2.pr(inner).sweepTime = 0;
            PR(SweepDistance).staticSweep(toi, 2, 0, 2);
            if (toi.toi < 0) {
                b1.pr(inner).sweepIntegrate(2);
                b1.pr(inner).sweepValidate(toi.s2);
                b2.pr(inner).sweepIntegrate(2);
                b2.pr(inner).sweepValidate(toi.s1);
            }
            else {
                debug.drawCircle(toi.c1.wrapper(), 2, 0xff0000);
                debug.drawCircle(toi.c2.wrapper(), 2, 0xff00);
            }

            b1.worldCOM;
            b2.worldCOM;
            debug.draw(b1);
            debug.draw(b2);

            debug.flush();
        }
    }
}*/
