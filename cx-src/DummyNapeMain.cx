package;

enum Scalar {
	sName(n:String);
	sConst(x:Float);
	sRotation(body:Int);
	sAngularVel(body:Int);
	sInvInertia(body:Int);
	sInvMass(body:Int);
}
enum Vector {
	vName(n:String);
	vConst(x:Float,y:Float);
	vPosition(body:Int);
	vVelocity(body:Int);
	vRelative(body:Int,n:String);
}
enum Matrix {
	mConst(a:Float,b:Float,c:Float,d:Float);
}

enum Expr {
	eMul(x:Expr,y:Expr); //scalar*T | vector*scalar
	eNeg(x:Expr); //T
	eAdd(x:Expr,y:Expr); //T*T
	eDot(x:Expr,y:Expr); //vector*vector
	eCross(x:Expr,y:Expr); //S*T
	ePerp(x:Expr); //vector
	eOuter(x:Expr,y:Expr); //vector*vector
	eMag(x:Expr); //vector
	eInv(x:Expr); //scalar

	eUnit(x:Expr); //vector

	eScalar(x:Scalar);
	eVector(x:Vector);
	eMatrix(m:Matrix);

	eLet(n:String,eq:Expr,out:Expr);
}

class Printer {
	static public function print_scalar(x:Scalar) {
		return switch(x) {
			case sName(n): n+".f";
			case sConst(x): Std.string(x);
			case sRotation(b): "b"+b+".rot";
			case sAngularVel(b): "b"+b+".angvel";
			case sInvInertia(b): "b"+b+".iinertia";
			case sInvMass(b): "b"+b+".invmass";
		}
	}
	static public function print_vector(x:Vector) {
		return switch(x) {
			case vName(n): n+".v";
			case vConst(x,y): "<"+x+","+y+">";
			case vPosition(b): "b"+b+".pos";
			case vVelocity(b): "b"+b+".vel";
			case vRelative(b,x): "b"+b+".rel("+x+")";
		}
	}
	static public function print_matrix(x:Matrix) {
		return switch(x) {
			case mConst(a,b,c,d): "["+a+","+b+","+c+","+d+"]";
		}
	}
	static public function print(e:Expr) {
		return switch(e) {
			case eMul(x,y): "("+print(x)+"*"+print(y)+")";
			case eNeg(x): "(-"+print(x)+")";
			case eAdd(x,y): "("+print(x)+"+"+print(y)+")";
			case eDot(x,y): "("+print(x)+" dot "+print(y)+")";
			case eCross(x,y): "("+print(x)+" crs "+print(y)+")";
			case ePerp(x): "(perp "+print(x)+")";
			case eOuter(x,y): "(outer "+print(x)+" "+print(y)+")";
			case eMag(x): "(mag "+print(x)+")";
			case eInv(x): "(inv "+print(x)+")";
			case eUnit(x): "(unit "+print(x)+")";
			case eLet(n,x,y): "(let "+n+"="+print(x)+" in "+print(y)+")";

			case eScalar(x): print_scalar(x);
			case eVector(x): print_vector(x);
			case eMatrix(x): print_matrix(x);
		}
	}
}

enum EType {
	etScalar;
	etVector;
	etMatrix;
}

class Typer {
	static public inline function sert(x:Bool,msg:String):Void {
		if(!x) throw (msg);
	}

	static public function eq(a:EType,b:EType):Bool { return Type.enumEq(a,b); }

	static public function scalar(e:Expr):Bool { return eq(typeof(e),etScalar); }
	static public function vector(e:Expr):Bool { return eq(typeof(e),etVector); }
	static public function matrix(e:Expr):Bool { return eq(typeof(e),etMatrix); }

	static public function typeof(e:Expr, ?env:Hash<Array<Expr>>):EType {
		if(env==null) env = new Hash<Array<Expr>>();
		function _typeof(e:Expr) return typeof(e, env);

		return switch(e) {
			case eScalar(_): etScalar;
			case eVector(_): etVector;
			case eMatrix(_): etMatrix;

			case eMul(x,y):
				sert((scalar(x) || scalar(y) || matrix(x) || matrix(y)),"Mismatched types in eMul");
				if(scalar(x)) _typeof(y);
				else if(scalar(y)) _typeof(x);
				else if(matrix(x) && matrix(y)) etMatrix;
				else etVector;
			case eNeg(x):
				_typeof(x);
			case eAdd(x,y):
				sert(eq(_typeof(x),_typeof(y)),"Mismatched types in eAdd");
				_typeof(x);
			case eDot(x,y):
				sert((vector(x) && vector(y)) || (scalar(x) && scalar(y)),"Mismatched types in eDot");
				etScalar;
			case eCross(x,y):
				if(vector(x) && vector(y)) etScalar else if(matrix(x) || matrix(y)) etMatrix else etVector;
			case ePerp(x):
				sert(vector(x),"Mismatched type in ePerp");
				etVector;
			case eOuter(x,y):
				sert((vector(x) && vector(y)) || (scalar(x) && scalar(y)),"Mismatched types in eOuter");
				vector(x) ? etMatrix : etScalar;
			case eMag(x):
				sert(vector(x),"Mismatched type in eMag");
				etScalar;
			case eInv(x):
				sert(scalar(x),"Mismatched type in eInv");
				etScalar;
			case eUnit(x):
				sert(vector(x),"Mismatched type in eUnit");
				etVector;

			case eLet(n,x,y):
				if(!env.exists(n)) env.set(n, []);
				env.get(n).unshift(x);
				var ret = typeof(y, env);
				env.get(n).shift();
				if(env.get(n).length==0) env.remove(n);
				ret;
		}
	}

	static public function okay(e:Expr) {
		try { typeof(e); }
		catch (e:Dynamic) { return false; }
		return true;
	}
}

class Differ {
	//subs is hash of substitutions to make based on Printer.print(e) existing in hash to a 'let' variable
	static public function diff(e:Expr, ?wrt:Expr, ?elt:Int=-1, ?subs:Hash<Expr>):Expr {
		var angvelb = -1;
		var velb = -1;
		if(wrt!=null) {
			switch(wrt) {
				default: throw "Error: Cannot differentiate wrt to var";
				case eScalar(x):
					switch(x) {
						case sAngularVel(b): angvelb = b;
						default: throw "Error: Cannot differentiate wrt to var";
					}
				case eVector(x):
					switch(x) {
						case vVelocity(b): velb = b;
						default: throw "Error: Cannot differentiate wrt to var";
					}
			}
		}

		if(subs==null) subs = new Hash<Expr>();
		function _diff(e:Expr) return diff(e,wrt,elt,subs);

		var ret = switch(e) {
			case eScalar(x):
				if(wrt!=null) {
					if(angvelb!=-1) {
						eScalar(switch(x) {
							case sAngularVel(b):
								if(b==angvelb) sConst(1.0) else sConst(0.0);
							default:
								sConst(0.0);
						});
					}else
						eScalar(sConst(0.0));
				}else {
					eScalar(switch(x) {
						case sRotation(b): sAngularVel(b);
						default: sConst(0.0);
					});
				}
			case eVector(x):
				if(velb!=-1) {
					eVector(switch(x) {
						case vVelocity(b):
							if(b==velb) vConst(elt==0 ? 1 : 0, elt==1 ? 1 : 0);
							else vConst(0,0);
						default:
							vConst(0,0);
					});
				}else if(angvelb!=-1) {
					eVector(vConst(0,0));
				}else {
					switch(x) {
						case vPosition(b): eVector(vVelocity(b));
						case vRelative(b,n): eCross(eScalar(sAngularVel(b)),eVector(vRelative(b,n)));
						default: eVector(vConst(0,0));
					}
				}
			case eMatrix(x):
				eMatrix(mConst(0,0,0,0));

			case eMul(x,y):
				eAdd(eMul(_diff(x),y),eMul(x,_diff(y)));
			case eNeg(x):
				eNeg(_diff(x));
			case eAdd(x,y):
				eAdd(_diff(x),_diff(y));
			case eDot(x,y):
				eAdd(eDot(_diff(x),y),eDot(x,_diff(y)));
			case eCross(x,y):
				eAdd(eCross(_diff(x),y),eCross(x,_diff(y)));
			case ePerp(x):
				ePerp(_diff(x));
			case eMag(x):
				eDot(eUnit(x),_diff(x));
			case eInv(x):
				eNeg(eMul(eInv(eMul(x,x)),_diff(x)));

			case eUnit(x):
				eMul(
					ePerp(eUnit(x)),
					eMul(
						eCross(eUnit(x),_diff(x)),
						eInv(eMag(x))
					)
				);

			case eLet(n,x,y):
				var nprime = n+"__prime";
				var dx = _diff(x);
				var dstr = Printer.print(dx);
				subs.set(dstr, Typer.scalar(dx) ? eScalar(sName(nprime)) : eVector(vName(nprime)));
				var ret = eLet(n,x,
					eLet(nprime,dx,
						diff(y,wrt,elt,subs)
					)
				);
				subs.remove(dstr);
				ret;
			default: throw "not differentiable";
		}
		var retstr = Printer.print(ret);
		if(subs.exists(retstr)) return subs.get(retstr);
		else return ret;
	}
}

class Simple {
	static function none(x:Expr) {
		return switch(x) {
			case eScalar(y): switch(y) { case sConst(z): z==-1; default: false; }
			default: false;
		}
	}
	static function one(x:Expr) {
		return switch(x) {
			case eScalar(y): switch(y) { case sConst(z): z==1; default: false; }
			case eMatrix(y): switch(y) { case mConst(a,b,c,d): a==d && a==1 && b==c && b==0; default: false; }
			default: false;
		}
	}
	static function zero(x:Expr) {
		return switch(x) {
			case eScalar(y): switch(y) { case sConst(z): z==0; default: false; }
			case eVector(y): switch(y) { case vConst(z,w): z==w && w==0; default: false; }
			case eMatrix(y): switch(y) { case mConst(a,b,c,d): a==b && b==c && c==d && d==0; default: false; }
			default: false;
		}
	}
	static function const(x:Expr) {
		return switch(x) {
			case eScalar(y): switch(y) { case sConst(_): true; default: false; }
			case eVector(y): switch(y) { case vConst(_,_): true; default: false; }
			case eMatrix(y): switch(y) { case mConst(_,_,_,_): true; default: false; }
			default: false;
		}
	}
	static function svalue(x:Expr) {
		return switch(x) {
			case eScalar(y): switch(y) { case sConst(z): z; default: 0.0; }
			default: 0.0;
		}
	}
	static function vvalue(x:Expr) {
		return switch(x) {
			case eVector(y): switch(y) { case vConst(x,y): [x,y]; default: [0.0,0.0]; }
			default: [0.0,0.0];
		}
	}
	public static function simple(x:Expr) {
		var y = __simple(x);
		return __simple(y);
	}
	public static function __simple(x:Expr) {
		return switch(x) {
			case eLet(n,x,y): eLet(n,simple(x),simple(y));
			case eAdd(inx,iny):
				var x = simple(inx);
				var y = simple(iny);
				zero(x) ? y : zero(y) ? x : eAdd(x,y);
			case ePerp(inx):
				var x = simple(inx);
				switch(x) {
				case eVector(x):
				switch(x) {
					case vConst(x,y): eVector(vConst(-y,x));
					default: ePerp(eVector(x));
				}
				default: x;
				}
			case eNeg(inx):
				var x = simple(inx);
				zero(x) ? x : !const(x) ? eNeg(x) : ({
					switch(x) {
						case eScalar(y): switch(y) { case sConst(z): eScalar(sConst(-z)); default: x;}
						case eVector(y): switch(y) { case vConst(xx,y): eVector(vConst(-xx,-y)); default: x;}
						case eMatrix(y): switch(y) { case mConst(a,b,c,d): eMatrix(mConst(-a,-b,-c,-d)); default: x;}
						default: x;
					}
				});
			case eMul(inx,iny):
				var x = simple(inx);
				var y = simple(iny);
				zero(x) ? x : zero(y) ? y : ({
					one(x) ? y : one(y) ? x : ({
						none(x) ? eNeg(y) : none(y) ? eNeg(x) :	eMul(x,y);
					});
				});
			case eDot(inx,iny):
				var x = simple(inx);
				var y = simple(iny);
				if(zero(x) || zero(y)) eScalar(sConst(0));
				else if(Typer.scalar(x)) {
					simple(eMul(x,y));
				}else {
					if(const(x) && const(y))
						eScalar(sConst(vvalue(x)[0]*vvalue(y)[0] + vvalue(x)[1]*vvalue(y)[1]));
					else {
						switch(x) {
						case eNeg(x1):
							simple(eNeg(eDot(x1,y)));
						case ePerp(x1):
							eCross(x1,y);
						default:
							eDot(x,y);
						}
					}
				}
			case eCross(inx,iny):
				var x = simple(inx);
				var y = simple(iny);
				if(zero(x) || zero(y)) {
					if(Typer.matrix(x) || Typer.matrix(y)) eMatrix(mConst(0,0,0,0));
					else if(Typer.vector(x) && Typer.vector(y)) eScalar(sConst(0));
					else eVector(vConst(0,0));
				}else if(Typer.scalar(x))
					eMul(x,ePerp(y));
				else if(Typer.scalar(y))
					eNeg(eMul(y,ePerp(x)));
				else
					eCross(x,y);
			case eOuter(inx,iny):
				var x = simple(inx);
				var y = simple(iny);
				if(Typer.scalar(x)) {
					const(x) && const(y) ? eScalar(sConst(svalue(x)*svalue(y))) :
					zero(x) || zero(y) ? eScalar(sConst(0)) : eMul(x,y);
				}else {
					const(x) && const(y) ? ({
						var xv = vvalue(x);
						var yv = vvalue(y);
						eMatrix(mConst(xv[0]*yv[0],xv[0]*yv[1],xv[1]*yv[0],xv[1]*yv[1]));
					}) :
					zero(x) || zero(y) ? eMatrix(mConst(0,0,0,0)) : eOuter(x,y);
				}
			case eUnit(inx):
				var x = simple(inx);
				eUnit(x);
			default: x;
		}
	}
}

class Jacobian {
	public static function jacobian(V:Expr, bodies:Array<Int>) {
		var ret = [];
		for(b in bodies) {
			ret.push(Simple.simple(Differ.diff(V,eVector(vVelocity(b)),0)));
			ret.push(Simple.simple(Differ.diff(V,eVector(vVelocity(b)),1)));
			ret.push(Simple.simple(Differ.diff(V,eScalar(sAngularVel(b)))));
		}
		return ret;
	}
}

class KEff {
	public static function __keff(j1:Array<Expr>, bodies:Array<Int>, ?j2:Array<Expr>) {
		if(j2==null) j2 = j1;
		var outexpr = null;
		for(i in 0...j1.length) {
			var b = bodies[Std.int(i/3)];
			var m = if((i%3)==2) eScalar(sInvInertia(b)) else eScalar(sInvMass(b));
			var e = Simple.simple(eMul(m,eOuter(j1[i],j2[i])));
			if(outexpr==null) outexpr = e;
			else outexpr = eAdd(outexpr, e);
		}
		return Simple.simple(outexpr);
	}

	public static function keff(js:Array<Array<Expr>>, bodies:Array<Int>) {
		var ret = [];
		for(i in 0...js.length) {
			for(j in 0...js.length) {
				ret.push(__keff(js[i],bodies,js[j]));
			}
		}
		return ret;
	}
}

class BodyImpulse {
	public static function bodyimpulse(js:Array<Array<Expr>>, body_index:Int) {
		var ret = [eScalar(sConst(0.0)),eScalar(sConst(0.0)),eScalar(sConst(0.0))];
		var scalars = Typer.scalar(js[0][0]);
		var i = body_index*3;

		for(ji in 0...js.length) {
			var j = js[ji];
			var jv = if(Typer.scalar(j[i])) eScalar(sName("__lambda_"+ji)) else eVector(vName("__lambda_"+ji));
			ret[0] = eAdd(ret[0], eDot(j[i], jv));
			ret[1] = eAdd(ret[1], eDot(j[i+1], jv));
			ret[2] = eAdd(ret[2], eDot(j[i+2], jv));
		}
		return Lambda.map(ret,Simple.simple);
	}
}

//using hscript
class VM {
	static function scalar(x:Scalar) {
		return switch(x) {
			case sName(n): "scalar_"+n;
			case sConst(x): Std.string(x);
			case sRotation(b): "body_"+b+"_rotation";
			case sAngularVel(b): "body_"+b+"_angvel";
			case sInvInertia(b): "body_"+b+"_cinertia";
			case sInvMass(b): "body_"+b+"_cmass";
		}
	}
	static function vector(v:Vector) {
		return switch(v) {
			case vName(n): "vector_"+n;
			case vConst(x,y): "["+Std.string(x)+","+Std.string(y)+"]";
			case vPosition(b): "body_"+b+"_position";
			case vVelocity(b): "body_"+b+"_velocity";
			case vRelative(b,n): "body_"+b+"_relative_"+n;
		}
	}
	static function matrix(m:Matrix) {
		return switch(m) {
			case mConst(a,b,c,d): "["+Std.string(a)+","+Std.string(b)+","+Std.string(c)+","+Std.string(d)+"]";
		}
	}

	public static function unparse(e:Expr) {
		return switch(e) {
			case eScalar(x): scalar(x);
			case eVector(x): vector(x);
			case eMatrix(x): matrix(x);

			case eMul(x,y): 
				if(Typer.scalar(x) && Typer.scalar(y)) "("+unparse(x)+"*"+unparse(y)+")"
				else if(Typer.scalar(x)) {
						if(Typer.vector(y)) {
"({
	var t0 = "+unparse(y)+";
	var t1 = "+unparse(x)+";
	[t0[0]*t1,t0[1]*t1];
})";
						}else {
"({
	var t0 = "+unparse(y)+";
	var t1 = "+unparse(x)+";
	[t0[0]*t1,t0[1]*t1,t0[2]*t1,t0[3]*t1];
})";
						}
					}
				else {
					Typer.sert(Typer.scalar(y),"bah");
					unparse(eMul(y,x));
				}

			case eAdd(x,y):
				if(Typer.scalar(x)) "("+unparse(x)+"+"+unparse(y)+")"
				else if(Typer.vector(x)) {
"({
	var t0 = "+unparse(x)+";
	var t1 = "+unparse(y)+";
	[t0[0]+t1[0],t0[1]+t1[1]];
})";
				}else {
"({
	var t0 = "+unparse(x)+";
	var t1 = "+unparse(y)+";
	[t0[0]+t1[0],t0[1]+t1[1],t0[2]+t1[2],t0[3]+t1[3]];
})";
				}

			case eNeg(x):
				if(Typer.scalar(x)) "(-"+unparse(x)+")"
				else if(Typer.vector(x)) {
"({
	var t = "+unparse(x)+";
	[-t[0],-t[1]];
})";
				}else {
"({
	var t = "+unparse(x)+";
	[-t[0],-t[1],-t[2],-t[3]];
})";
				}

			case eDot(x,y):
"({
	var t0 = "+unparse(x)+";
	var t1 = "+unparse(y)+";
	t0[0]*t0[0] + t0[1]*t1[1];
})";

			case eCross(x,y):
"({
	var t0 = "+unparse(x)+";
	var t1 = "+unparse(y)+";
	t0[0]*t0[1] - t0[1]*t1[0];
})";

			case ePerp(x):
"({
	var t = "+unparse(x)+";
	[-t[1],t[0]];
})";

			case eOuter(x,y):
"({
	var t0 = "+unparse(x)+";
	var t1 = "+unparse(y)+";
	[t0[0]*t1[0], t0[0]*t1[1], t0[1]*t1[0], t0[1]*t1[1]];
})";

			case eMag(x):
"({
	var t = "+unparse(x)+";
	Math.sqrt(t[0]*t[0]+t[1]*t[1]);
})";

			case eInv(x): "(1.0/"+unparse(x)+")";

			default:
				throw "bah";
				"";
		}
	}
}

class DummyNapeMain {
	static function main() {
		var txt = new flash.text.TextField();
		flash.Lib.current.addChild(txt);
		txt.width = flash.Lib.current.stage.stageWidth;
		txt.height = flash.Lib.current.stage.stageHeight;
		txt.wordWrap = true;
		
		function tracex(x:Dynamic) {
			txt.text += Std.string(x)+"\n";
		}

/*		var r1 = eVector(vRelative(1,"anchor1"));
		var r2 = eVector(vRelative(2,"anchor2"));
		var x1 = eVector(vPosition(1));
		var x2 = eVector(vPosition(2));

		var dist_C = eAdd(eMag(eAdd(eAdd(x2,r2), eNeg(eAdd(x1,r1)))), eNeg(eScalar(sName("length"))));
		tracex(Printer.print(dist_C));

		var dist_V = Simple.simple(Differ.diff(dist_C));
		tracex(Printer.print(dist_V));

		var dist_J = Jacobian.jacobian(dist_V,[1,2]);
		tracex(Lambda.map(dist_J, Printer.print));

		var J = [dist_J];
		var K = KEff.keff(J,[1,2]);
		tracex(Lambda.map(K, Printer.print));*/

		var expr = eLet("a",eDot(eVector(vConst(1,2)),eVector(vPosition(1))),eVector(vName("a")));
		trace(Printer.print(expr));
		expr = Differ.diff(expr);
		trace(Printer.print(expr));

/*
		var pivot_C = eAdd(eAdd(x2,r2), eNeg(eAdd(x1,r1)));
		var angle_C = eAdd(eScalar(sRotation(2)),eNeg(eScalar(sRotation(1))));
		tracex(Printer.print(pivot_C));
		tracex(Printer.print(angle_C));
		tracex(VM.unparse(pivot_C));
		tracex(VM.unparse(angle_C));

		var pivot_V = Simple.simple(Differ.diff(pivot_C));
		var angle_V = Simple.simple(Differ.diff(angle_C));
		tracex(Printer.print(pivot_V));
		tracex(Printer.print(angle_V));
		tracex(VM.unparse(pivot_V));
		tracex(VM.unparse(angle_V));

		var pivot_J = Jacobian.jacobian(pivot_V,[1,2]);
		var angle_J = Jacobian.jacobian(angle_V,[1,2]);
		tracex(Lambda.map(pivot_J, Printer.print));
		tracex(Lambda.map(angle_J, Printer.print));

		var J = [pivot_J,angle_J];
		var K = KEff.keff(J,[1,2]);
		tracex(Lambda.map(K, Printer.print));
		tracex(Lambda.map(K, VM.unparse));

		var body1 = BodyImpulse.bodyimpulse(J,0);
		var body2 = BodyImpulse.bodyimpulse(J,1);
		tracex(Lambda.map(body1, Printer.print));
		tracex(Lambda.map(body1, VM.unparse));
		tracex(Lambda.map(body2, Printer.print));
		tracex(Lambda.map(body2, VM.unparse));*/
	}
}
