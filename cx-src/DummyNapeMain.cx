package;

#if !(IGNORE_DUMMY)

$(import);

#if (cpp||neko)
class DummyNapeMain {
	static function main() {
		var w = 800;
		var h = 600;
		var fps = 60;
		var bgColor = 0x333333;
		var flags =
			nme.Lib.BORDERLESS |
			nme.Lib.HARDWARE |
			nme.Lib.VSYNC |
			0;
		var name = "Test Nape hxcpp/nme";

		nme.Lib.create(function() { new DummyNapeMain(); },w,h,fps,bgColor,flags,name);
	}

	function new() {
		var cur = flash.Lib.current;

		var bd = new flash.display.BitmapData(800,600,true,0x0);
		var shape = new flash.display.Shape();
		shape.graphics.beginFill(0x999999);
		shape.graphics.drawRect(0,300,800,500);
		bd.draw(shape);

		var erase = new flash.display.BitmapData(64,64,true,0xffffffff);
		shape.graphics.clear();
		shape.graphics.beginFill(0xff0000);
		shape.graphics.drawCircle(32,32,32);
		erase.draw(shape);
		erase.copyChannel(erase,erase.rect,new flash.geom.Point(), flash.display.BitmapDataChannel.BLUE, flash.display.BitmapDataChannel.ALPHA);

		var debug = new ShapeDebug(800,600,0x0);
		debug.drawShapeAngleIndicators = true;
		cur.addChild(debug.display);

		function lookup(x:Float,y:Float):Float {
			return bd.getPixel32(Std.int(x),Std.int(y))==0 ? 1 : -1;
		}

		function invalidate2() {
			debug.clear();
			var polys = MarchingSquares.run(lookup, new AABB(0,0,800,600), new Vec2(15,15));
			for(p in polys) {
				var qs:GeomPolyList = new GeomPolyList();
				try {
					 qs = p.convex_decomposition();
				}catch(e:Dynamic) {
					var ret = "[";
					for(v in p) {
						if(ret!="[") ret += ",";
						ret += "v("+v.x+","+v.y+")";
					}
					trace(ret+"]");
				}
				for(q in qs)
					debug.drawPolygon(q,0xff0000);
			}
			debug.flush();
		}
		invalidate2();

		cur.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
			bd.copyPixels(bd,new flash.geom.Rectangle(cur.mouseX-32,cur.mouseY-32,64,64), new flash.geom.Point(cur.mouseX-32,cur.mouseY-32), erase, new flash.geom.Point(), false);
			invalidate2();
		});

		cur.addEventListener(flash.events.MouseEvent.MOUSE_MOVE, function(e) {
			if(!e.buttonDown) return;

			bd.copyPixels(bd,new flash.geom.Rectangle(cur.mouseX-32,cur.mouseY-32,64,64), new flash.geom.Point(cur.mouseX-32,cur.mouseY-32), erase, new flash.geom.Point(), false);
			invalidate2();
		});


/*		var debug = new ShapeDebug(800,600);
		debug.drawShapeAngleIndicators = false;
		flash.Lib.current.addChild(debug.display);

		var space = new Space(Vec2.weak(0,400));

		var water = new Body(BodyType.STATIC);
		var w1 = new Polygon(Polygon.rect(0,0,800,300));   w1.body = water;
		var w2 = new Polygon(Polygon.rect(0,300,800,300)); w2.body = water;
		w1.fluidEnabled = w2.fluidEnabled = true;
		w1.fluidProperties.density = w2.fluidProperties.density = 4;
		w1.fluidProperties.viscosity = w2.fluidProperties.viscosity = 5;
		w1.fluidProperties.gravity = Vec2.weak(0,-400);

		water.align();
		water.kinAngVel = 2;

		water.space = space;
	
		var walls = new Body(BodyType.STATIC);
		walls.shapes.add(new Polygon(Polygon.rect(0,0,-40,600)));
		walls.shapes.add(new Polygon(Polygon.rect(800,0,40,600)));
		walls.shapes.add(new Polygon(Polygon.rect(0,0,800,-40)));
		walls.shapes.add(new Polygon(Polygon.rect(0,600,800,40)));
		walls.space = space;

		for(i in 0...1400) {
			var b = new Body();
			b.position.setxy(Math.random()*800,Math.random()*600);
			b.shapes.add(new Polygon(Polygon.regular(Math.random()*12+6,Math.random()*12+6,Std.int(Math.random()*1+3))));
			b.space = space;
		}

		var mcon = new PivotJoint(space.world,space.world,Vec2.weak(),Vec2.weak());
		mcon.stiff = false;
		mcon.space = space;
		mcon.active = false;
		mcon.space = space;

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			var mx = flash.Lib.current.mouseX;	
			var my = flash.Lib.current.mouseY;
			var bods = space.bodiesInCircle(Vec2.weak(mx,my), 5);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
					mcon.anchor2 = b.worldToLocal(Vec2.weak(mx,my),true);
					mcon.active = true;
				}
			}
		});

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
			mcon.active = false;
		});
		
		(new haxe.Timer(0)).run = function() {
			debug.clear();
			mcon.anchor1.setxy(flash.Lib.current.mouseX,flash.Lib.current.mouseY);
			space.step(1/60,6,2);
			debug.draw(space);
			debug.flush();
		}

*/

/*        var root = nme.Lib.current;
        Perlin3D.init_noise();

        var z = 0.0;
        var bnd = 0.0;
        var iso = function(x:Float,y:Float) return Perlin3D.noise(x/40,y/30,z)-bnd;

        var debug = new ShapeDebug(400,300,0xffffff);
        root.addChild(debug.display);

        var bounds  = new AABB(0,0,400,300);
        var cells   = new Vec2(5,5);
        var grid    = new Vec2(100,100);
        var quality = 2;

		var tim = new haxe.Timer(17);
        tim.run = function () {
            z += 1/30;
            bnd = Math.sin(z*0.3)*0.35;
            debug.clear();
            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
                var qs = p.convex_decomposition();
                for(q in qs) debug.drawFilledPolygon(q,colour(q));
                debug.drawPolygon(p,0);
            }
            debug.flush();
        }

		root.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
			tim.stop();
			var space = new Space(new Vec2(0,400));

			var border = new Body(BodyType.STATIC);
			border.shapes.add(new Polygon(Polygon.rect(0,0,-20,300)));
			border.shapes.add(new Polygon(Polygon.rect(400,0,20,300)));
			border.shapes.add(new Polygon(Polygon.rect(0,0,400,-20)));
			border.shapes.add(new Polygon(Polygon.rect(0,300,400,20)));
			border.space = space;

            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
				var body = new Body();
                var qs = p.convex_decomposition();
                for(q in qs) {
					body.shapes.add(new Polygon(q));
				}
				body.align();
				body.space = space;
			}

			(new haxe.Timer(17)).run = function() {
				debug.clear();
				space.step(1/60,10,5);
				debug.draw(space);
				debug.flush();
			}
		});*/
    }

    static inline function colour(p:GeomPoly) {
        //hue
        var h = p.area()/3000*360; while(h>360) h -= 360;
        var f = (h%60)/60;

        var r:Float, g:Float, b:Float;
        if     (h<=60 ) { r = 1; g = f; b = 0; }
        else if(h<=120) { r = 1-f; g = 1; b = 0; }
        else if(h<=180) { r = 0; g = 1; b = f; }
        else if(h<=240) { r = 0; g = 1-f; b = 1; }
        else if(h<=300) { r = f; g = 0; b = 1; }
        else            { r = 1; g = 0; b = 1-f; }

        return (Std.int(r*0xff)<<16)|(Std.int(g*0xff)<<8)|Std.int(b*0xff);
    }
}

class Perlin3D {
    public static inline function noise(x:Float, y:Float, z:Float) {
        var X = Std.int(x); x -= X; X &= 0xff;
        var Y = Std.int(y); y -= Y; Y &= 0xff;
        var Z = Std.int(z); z -= Z; Z &= 0xff;
        var u = fade(x); var v = fade(y); var w = fade(z);
        var A = p(X)  +Y; var AA = p(A)+Z; var AB = p(A+1)+Z;
        var B = p(X+1)+Y; var BA = p(B)+Z; var BB = p(B+1)+Z;
        return lerp(w, lerp(v, lerp(u, grad(p(AA  ), x  , y  , z   ),
                                       grad(p(BA  ), x-1, y  , z   )),
                               lerp(u, grad(p(AB  ), x  , y-1, z   ),
                                       grad(p(BB  ), x-1, y-1, z   ))),
                       lerp(v, lerp(u, grad(p(AA+1), x  , y  , z-1 ),
                                       grad(p(BA+1), x-1, y  , z-1 )),
                               lerp(u, grad(p(AB+1), x  , y-1, z-1 ),
                                       grad(p(BB+1), x-1, y-1, z-1 ))));
    }

    static inline function fade(t:Float) return t*t*t*(t*(t*6-15)+10)
    static inline function lerp(t:Float, a:Float, b:Float) return a + t*(b-a)
    static inline function grad(hash:Int, x:Float, y:Float, z:Float) {
        var h = hash&15;
        var u = h<8 ? x : y;
        var v = h<4 ? y : h==12||h==14 ? x : z;
        return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
    }

    static inline function p(i:Int) return perm[i]
    static var perm:Array<Int>;
    
    public static function init_noise() {
		perm = new Array<Int>();

        var p = [151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

        for(i in 0...256) {
            perm[i]=    p[i];
            perm[256+i]=p[i];
        }
    }
}


#elseif swc
class DummyNapeMain {
}

#else 

class Tracer {
	static public function trace(objs:Array<Dynamic>,txt:flash.text.TextField) {
		var dict_id = 0;
		var stack = [];
		var dict = new flash.utils.Dictionary(false);
		var idl = [];

		$(mixin pushobj(i) ({
			if((untyped dict[i])!=null) (untyped dict[i]).id;
			else {
				var o = { id: dict_id++, obj:i, refs:[] };
				untyped dict[i] = o;
				stack.push(o);
				idl.push(o);
				o.id;
			}
		}));

		for(i in objs) pushobj(i);
		var tim = new haxe.Timer(0);

		var fcnt = 0;
		var finish = function() {	
			var pt = flash.Lib.getTimer();
			var buf = "";
			while(flash.Lib.getTimer()-pt <= 50) {
				if(fcnt >= idl.length) {
					txt.text += buf+"\n\nDONE";
					txt.scrollV = txt.maxScrollV;
					tim.stop();
					return;
				}
				var i = idl[fcnt++];
				buf += "id: "+i.id+" refs:"+Std.string(i.refs)+" = "+Std.string(i.obj)+"\n";
			}
			txt.text += buf;
			txt.scrollV = txt.maxScrollV;
		}
		
		var cnnt = 0;
		tim.run = function() {
			txt.text = "running: stack size="+stack.length+" cnt="+cnnt;

			if(stack.length==0) { tim.run = finish; txt.text = ""; return; }

			var pt = flash.Lib.getTimer();
			while(flash.Lib.getTimer()-pt <= 50) {
				if(stack.length==0) { tim.run = finish; txt.text = ""; return; }

				var cur = stack.shift();
				cnnt++;
				var cls = Type.getClass(cur.obj);
				for(o in Type.getInstanceFields(cls)) {
					var field:Dynamic = Reflect.field(cur.obj, o);
					if(field!=null && Reflect.isObject(field)) {
						cur.refs.push({ name:o, id:	pushobj(field) });
					}
				}
			}
		}
	}
}

$(mixin global ArrayList(T,ARRAY) GenArrayList(T,ARRAY) ZNPArrayList_`T`ARRAY);
$(expand global GenArrayList(T,ARRAY)
class ArrayList(T,ARRAY) {
	ArrayListMixin(
		$(mixin _delelt(o) {})
	,
		T,ARRAY,ArrayListNode(T)
	)
}
);

$(mixin global ArrayAllocList(T,ARRAY) GenArrayAllocList(T,ARRAY) ZNPArrayAllocList_`T`ARRAY);
$(expand global GenArrayAllocList(T,ARRAY)
class ArrayAllocList(T,ARRAY) {
	ArrayListMixin(
		$(mixin _delelt(o) Free(T,o))
	,
		T,ARRAY,ArrayListNode(T)
	)
}
);

$(mixin global ArrayListMixin(defs, T,ARRAY,TI)
	defs

	#if !ARRAY
		public var _head:ArrayListNode(T);
	#else
		public var _elts:Array<T>;
	#end

	public function new() {
		#if ARRAY
			_elts = [];
		#end
	}

	$(mixin I() #if !ARRAY TI #else Int #end);
	
	flibmdel public inline function begin() {
		return #if !ARRAY _head #else 0 #end;
	}

	flibmdel public inline function add(o:T) {
		#if !ARRAY
			var tmp = Get(ArrayListNode(T));
			tmp.elt = o;
			tmp.next = begin();
			_head = tmp;
		#else
			_elts.push(o);
		#end
		return o;
	}

	flibmdel public inline function pop():Void {
		#if !ARRAY
			var ret = begin();
			_head = ret.next;
			_delelt(ret.elem());
			Free(ArrayListNode(T),ret);
		#else
			_elts.pop();
		#end
	}

	flibmdel public inline function pop_unsafe():T {
		#if !ARRAY
			var ret = front();
			pop();
			return ret;
		#else
			return _elts.pop();
		#end
	}

	flibmdel public inline function remove(o:T) {
		#if !ARRAY
			var pre = null;
			var cur = begin();
			var ret = false;
			while(cur!=null) {
				if(cur.elem()==o) {
					erase(pre);
					ret = true;
					break;
				}
				pre = cur;
				cur = cur.next;
			}
			return ret;
		#else
			var ret = false;
			for(i in 0..._elts.length) {
				if(_elts[i]==o) {
					erase(i-1);
					ret = true;
					break;
				}
			}
			return ret;
		#end
	}

	public static inline var nil#if !ARRAY :ArrayListNode(T) = null #else :Int = -1#end;

	flibmdel public inline function erase(pre:I):I {
		if(pre==nil) { pop(); return begin(); }
		else {
			#if !ARRAY
				var old = pre.next;
				var cur = old.next;
				pre.next = cur;
				_delelt(old.elem());
				Free(ArrayListNode(T),old);
				return cur;
			#else
				pre++;
				_delelt(_elts[pre]);
				_elts[pre] = _elts[_elts.length-1];
				_elts.pop();
				return pre;
			#end
		}
	}

	flibmdel public inline function clear() {
		#if !ARRAY
			while(!empty()) pop();
		#else
			if($str(_delelt)!="{}") {
				for(i in _elts) _delelt(i);
			}
			_elts = [];
		#end
	}

	flibmdel public inline function empty() return #if !ARRAY begin()==null #else _elts.length==0 #end

	flibmdel public inline function size() {
		#if !ARRAY
			var cnt = 0;
			var cur = begin();
			while(cur!=null) { cnt++; cur = cur.next; }
			return cnt;
		#else
			return _elts.length;
		#end
	}

	flibmdel public inline function front() return #if !ARRAY begin().elem() #else _elts[0] #end

	flibmdel public inline function iterator_at(ind:Int) {
		#if !ARRAY
			var ret = begin();
			while(ind-->0 && ret!=null) ret = ret.next;
			return ret;
		#else
			return ind;
		#end
	}

	flibmdel public inline function at(ind:Int) {
		#if !ARRAY
			var it = iterator_at(ind);
			return it.elem();
		#else
			return _elts[ind];
		#end
	}

	flibmdel public inline function iter(f:T->Void) {
		#if !ARRAY
			var cur = begin();
			while(cur!=null) {
				f(cur.elem());
				cur = cur.next;
			}
		#else
			for(x in _elts) f(x);
		#end
	}
	flibmdel public inline function iterbool(f:T->Bool) {
		#if !ARRAY
			var pre = null;
			var cur = begin();
			while(cur!=null) {
				if(f(cur.elem()))
					cur = erase(pre);
				else {
					pre = cur;
					cur = cur.next;
				}
			}
		#else
			var i = 0;
			var j = _elts.length;
			while(i<j) {
				if(f(_elts[i])) {
					_delelt(_elts[i]);
					_elts[i] = _elts[--j];
					_elts.pop();
				}else
					i++;
			}
		#end
	}
);

$(define class ArrayListNode(T) {
	MixPoolNoNext(ArrayListNode(T))
	
	public var next:ArrayListNode(T);
	flibmdel public inline function alloc() {}
	flibmdel public inline function free() { trace("Node-free"); }

	public var elt:T;
	public function new() {}
	flibmdel public inline function elem() return elt
});

class Integer {
	MixPool(Integer)
	public var i:Int;
	public function new(i:Int) this.i = i

	flibmdel public inline function alloc() {}
	flibmdel public inline function free () { trace("Int-free"); }
}

class DummyNapeMain {
	static function main() {

		var intlist = new ArrayList(Int,true)();

		intlist.add(10);
		intlist.add(20);
		intlist.add(30);
		intlist.add(40);
		intlist.add(50);
		intlist.iter(function (x) trace(x)); trace("");

		intlist.remove(30);
		intlist.iterbool(function (x) return x==20);
		intlist.iter(function (x) trace(x)); trace("");

		intlist.clear();

		var intlist = new ArrayList(Int,false)();
		intlist.add(10);
		intlist.add(20);
		intlist.add(30);
		intlist.add(40);
		intlist.add(50);
		intlist.iter(function (x) trace(x)); trace("");
	
		intlist.remove(30);
		intlist.iterbool(function (x) return x==20);
		intlist.iter(function (x) trace(x)); trace("");

		intlist.clear();

		var intlist = new ArrayAllocList(Integer,true)();
		intlist.add(new Integer(10));
		intlist.add(new Integer(20));
		intlist.add(new Integer(30));
		intlist.add(new Integer(40));
		intlist.add(new Integer(50));
		intlist.iter(function (x) trace(x.i)); trace("");

		intlist.iterbool(function (x) return x.i==20);
		intlist.iter(function (x) trace(x.i)); trace("");

		intlist.clear();

		var intlist = new ArrayAllocList(Integer,false)();
		intlist.add(new Integer(10));
		intlist.add(new Integer(20));
		intlist.add(new Integer(30));
		intlist.add(new Integer(40));
		intlist.add(new Integer(50));
		intlist.iter(function (x) trace(x.i)); trace("");

		intlist.iterbool(function (x) return x.i==20);
		intlist.iter(function (x) trace(x.i)); trace("");

		intlist.clear();
	}
}

class DummyNapeMains {
	static function main() {
		var debug = new BitmapDebug(800,600,0x333333);
		debug.drawShapeAngleIndicators = false;
		debug.drawConstraints = false;
		flash.Lib.current.addChild(debug.display);

		var space = new Space();

		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Circle(50));
		b.space = space;

		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Polygon(Polygon.regular(50,50,4)));
		b.space = space;

/*-		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Circle(10));
		b.space = space;*/

		var mcon = new PivotJoint(space.world,space.world,Vec2.weak(),Vec2.weak());
		mcon.active = false;
		mcon.stiff = false;
		mcon.maxForce = 0;
		mcon.space = space;

		for(b in space.bodies) b.shapes.at(0).filter.collisionMask = 0;

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			var mx = flash.Lib.current.mouseX;	
			var my = flash.Lib.current.mouseY;
			var bods = space.bodiesInCircle(Vec2.weak(mx,my), 5);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
//					mcon.anchor2 = b.worldToLocal(Vec2.weak(mx,my),true);
					mcon.active = true;
				}
			}
		});

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
			mcon.active = false;
		});
		
		var x = Vec2.get();
		var y = Vec2.get();

		(new haxe.Timer(0)).run = function() {
			debug.clear();
			space.step(1/60,10,10);
			debug.draw(space);

			if(mcon.active) {
				for(b in space.dynamics) {
					if(b==mcon.body2) continue;
					if(Geom.intersects(b.shapes.at(0),mcon.body2.shapes.at(0))) {
						debug.drawLine(b.worldCOM,mcon.body2.worldCOM,0xff0000);
					}
					if(Geom.contains(b.shapes.at(0),mcon.body2.shapes.at(0))) {
						debug.drawLine(b.worldCOM,mcon.body2.worldCOM,0xff00);
					}
					if(Geom.distance(b.shapes.at(0),mcon.body2.shapes.at(0),x,y)>=0) {
						debug.drawLine(x,y,0xff00ff);
					}
				}
			}

			debug.flush();
		}
	}
}

#end

#else
#end
