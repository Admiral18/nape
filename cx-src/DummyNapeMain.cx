package;

#if !(IGNORE_DUMMY)

$(import);

#if (cpp||neko)
class DummyNapeMain {
	static function main() {
		var w = 800;
		var h = 600;
		var fps = 60;
		var bgColor = 0x333333;
		var flags =
			nme.Lib.BORDERLESS |
			nme.Lib.HARDWARE |
			nme.Lib.VSYNC |
			0;
		var name = "Test Nape hxcpp/nme";

		nme.Lib.create(function() { new DummyNapeMain(); },w,h,fps,bgColor,flags,name);
	}

	function new() {
		var cur = flash.Lib.current;

		var bd = new flash.display.BitmapData(800,600,true,0x0);
		var shape = new flash.display.Shape();
		shape.graphics.beginFill(0x999999);
		shape.graphics.drawRect(0,300,800,500);
		bd.draw(shape);

		var erase = new flash.display.BitmapData(64,64,true,0xffffffff);
		shape.graphics.clear();
		shape.graphics.beginFill(0xff0000);
		shape.graphics.drawCircle(32,32,32);
		erase.draw(shape);
		erase.copyChannel(erase,erase.rect,new flash.geom.Point(), flash.display.BitmapDataChannel.BLUE, flash.display.BitmapDataChannel.ALPHA);

		var debug = new ShapeDebug(800,600,0x0);
		debug.drawShapeAngleIndicators = true;
		cur.addChild(debug.display);

		function lookup(x:Float,y:Float):Float {
			return bd.getPixel32(Std.int(x),Std.int(y))==0 ? 1 : -1;
		}

		function invalidate2() {
			debug.clear();
			var polys = MarchingSquares.run(lookup, new AABB(0,0,800,600), new Vec2(15,15));
			for(p in polys) {
				var qs:GeomPolyList = new GeomPolyList();
				try {
					 qs = p.convex_decomposition();
				}catch(e:Dynamic) {
					var ret = "[";
					for(v in p) {
						if(ret!="[") ret += ",";
						ret += "v("+v.x+","+v.y+")";
					}
					trace(ret+"]");
				}
				for(q in qs)
					debug.drawPolygon(q,0xff0000);
			}
			debug.flush();
		}
		invalidate2();

		cur.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
			bd.copyPixels(bd,new flash.geom.Rectangle(cur.mouseX-32,cur.mouseY-32,64,64), new flash.geom.Point(cur.mouseX-32,cur.mouseY-32), erase, new flash.geom.Point(), false);
			invalidate2();
		});

		cur.addEventListener(flash.events.MouseEvent.MOUSE_MOVE, function(e) {
			if(!e.buttonDown) return;

			bd.copyPixels(bd,new flash.geom.Rectangle(cur.mouseX-32,cur.mouseY-32,64,64), new flash.geom.Point(cur.mouseX-32,cur.mouseY-32), erase, new flash.geom.Point(), false);
			invalidate2();
		});


/*		var debug = new ShapeDebug(800,600);
		debug.drawShapeAngleIndicators = false;
		flash.Lib.current.addChild(debug.display);

		var space = new Space(Vec2.weak(0,400));

		var water = new Body(BodyType.STATIC);
		var w1 = new Polygon(Polygon.rect(0,0,800,300));   w1.body = water;
		var w2 = new Polygon(Polygon.rect(0,300,800,300)); w2.body = water;
		w1.fluidEnabled = w2.fluidEnabled = true;
		w1.fluidProperties.density = w2.fluidProperties.density = 4;
		w1.fluidProperties.viscosity = w2.fluidProperties.viscosity = 5;
		w1.fluidProperties.gravity = Vec2.weak(0,-400);

		water.align();
		water.kinAngVel = 2;

		water.space = space;
	
		var walls = new Body(BodyType.STATIC);
		walls.shapes.add(new Polygon(Polygon.rect(0,0,-40,600)));
		walls.shapes.add(new Polygon(Polygon.rect(800,0,40,600)));
		walls.shapes.add(new Polygon(Polygon.rect(0,0,800,-40)));
		walls.shapes.add(new Polygon(Polygon.rect(0,600,800,40)));
		walls.space = space;

		for(i in 0...1400) {
			var b = new Body();
			b.position.setxy(Math.random()*800,Math.random()*600);
			b.shapes.add(new Polygon(Polygon.regular(Math.random()*12+6,Math.random()*12+6,Std.int(Math.random()*1+3))));
			b.space = space;
		}

		var mcon = new PivotJoint(space.world,space.world,Vec2.weak(),Vec2.weak());
		mcon.stiff = false;
		mcon.space = space;
		mcon.active = false;
		mcon.space = space;

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			var mx = flash.Lib.current.mouseX;	
			var my = flash.Lib.current.mouseY;
			var bods = space.bodiesInCircle(Vec2.weak(mx,my), 5);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
					mcon.anchor2 = b.worldToLocal(Vec2.weak(mx,my),true);
					mcon.active = true;
				}
			}
		});

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
			mcon.active = false;
		});
		
		(new haxe.Timer(0)).run = function() {
			debug.clear();
			mcon.anchor1.setxy(flash.Lib.current.mouseX,flash.Lib.current.mouseY);
			space.step(1/60,6,2);
			debug.draw(space);
			debug.flush();
		}

*/

/*        var root = nme.Lib.current;
        Perlin3D.init_noise();

        var z = 0.0;
        var bnd = 0.0;
        var iso = function(x:Float,y:Float) return Perlin3D.noise(x/40,y/30,z)-bnd;

        var debug = new ShapeDebug(400,300,0xffffff);
        root.addChild(debug.display);

        var bounds  = new AABB(0,0,400,300);
        var cells   = new Vec2(5,5);
        var grid    = new Vec2(100,100);
        var quality = 2;

		var tim = new haxe.Timer(17);
        tim.run = function () {
            z += 1/30;
            bnd = Math.sin(z*0.3)*0.35;
            debug.clear();
            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
                var qs = p.convex_decomposition();
                for(q in qs) debug.drawFilledPolygon(q,colour(q));
                debug.drawPolygon(p,0);
            }
            debug.flush();
        }

		root.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
			tim.stop();
			var space = new Space(new Vec2(0,400));

			var border = new Body(BodyType.STATIC);
			border.shapes.add(new Polygon(Polygon.rect(0,0,-20,300)));
			border.shapes.add(new Polygon(Polygon.rect(400,0,20,300)));
			border.shapes.add(new Polygon(Polygon.rect(0,0,400,-20)));
			border.shapes.add(new Polygon(Polygon.rect(0,300,400,20)));
			border.space = space;

            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
				var body = new Body();
                var qs = p.convex_decomposition();
                for(q in qs) {
					body.shapes.add(new Polygon(q));
				}
				body.align();
				body.space = space;
			}

			(new haxe.Timer(17)).run = function() {
				debug.clear();
				space.step(1/60,10,5);
				debug.draw(space);
				debug.flush();
			}
		});*/
    }

    static inline function colour(p:GeomPoly) {
        //hue
        var h = p.area()/3000*360; while(h>360) h -= 360;
        var f = (h%60)/60;

        var r:Float, g:Float, b:Float;
        if     (h<=60 ) { r = 1; g = f; b = 0; }
        else if(h<=120) { r = 1-f; g = 1; b = 0; }
        else if(h<=180) { r = 0; g = 1; b = f; }
        else if(h<=240) { r = 0; g = 1-f; b = 1; }
        else if(h<=300) { r = f; g = 0; b = 1; }
        else            { r = 1; g = 0; b = 1-f; }

        return (Std.int(r*0xff)<<16)|(Std.int(g*0xff)<<8)|Std.int(b*0xff);
    }
}

class Perlin3D {
    public static inline function noise(x:Float, y:Float, z:Float) {
        var X = Std.int(x); x -= X; X &= 0xff;
        var Y = Std.int(y); y -= Y; Y &= 0xff;
        var Z = Std.int(z); z -= Z; Z &= 0xff;
        var u = fade(x); var v = fade(y); var w = fade(z);
        var A = p(X)  +Y; var AA = p(A)+Z; var AB = p(A+1)+Z;
        var B = p(X+1)+Y; var BA = p(B)+Z; var BB = p(B+1)+Z;
        return lerp(w, lerp(v, lerp(u, grad(p(AA  ), x  , y  , z   ),
                                       grad(p(BA  ), x-1, y  , z   )),
                               lerp(u, grad(p(AB  ), x  , y-1, z   ),
                                       grad(p(BB  ), x-1, y-1, z   ))),
                       lerp(v, lerp(u, grad(p(AA+1), x  , y  , z-1 ),
                                       grad(p(BA+1), x-1, y  , z-1 )),
                               lerp(u, grad(p(AB+1), x  , y-1, z-1 ),
                                       grad(p(BB+1), x-1, y-1, z-1 ))));
    }

    static inline function fade(t:Float) return t*t*t*(t*(t*6-15)+10)
    static inline function lerp(t:Float, a:Float, b:Float) return a + t*(b-a)
    static inline function grad(hash:Int, x:Float, y:Float, z:Float) {
        var h = hash&15;
        var u = h<8 ? x : y;
        var v = h<4 ? y : h==12||h==14 ? x : z;
        return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
    }

    static inline function p(i:Int) return perm[i]
    static var perm:Array<Int>;
    
    public static function init_noise() {
		perm = new Array<Int>();

        var p = [151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

        for(i in 0...256) {
            perm[i]=    p[i];
            perm[256+i]=p[i];
        }
    }
}


#elseif swc
class DummyNapeMain {
}

#else 

typedef TracerObj = {id:Int, obj:Dynamic, refs:Array<{name:String,id:Int}>};
typedef TracerSt = {objs:Array<Dynamic>,cont:Array<Dynamic>->Void,str:String};
class Tracer extends flash.text.TextField {
	public function new() {
		super();
		width = flash.Lib.current.stage.stageWidth;
		height = flash.Lib.current.stage.stageHeight;
		defaultTextFormat = new flash.text.TextFormat("Courier New, Consolas",null,0xffffff);

		init();
	}

	static inline var INIT = 0;
	static inline var SEARCH = 1;
	static inline var TRACE = 2;
	static inline var SLEEP = 3;
	var state:Int;

	var trace_stack:Array<TracerSt>;
	public function trace(objs:Array<Dynamic>,?cont:Array<Dynamic>->Void) {
		if(objs.length==0) return;
		trace_stack.push({objs:objs,cont:cont,str:null});
		begin();
	}

	public function print(str:String) {
		if(str==null) str = "null";
		trace_stack.push({objs:null,cont:null,str:str});
		begin();
	}

	var ctrace:TracerSt;
	var dict_id:Int;
	var stack:Array<TracerObj>;
	var dict:flash.utils.Dictionary;
	var idl:Array<TracerObj>;
	var cnnt:Int; var fcnt:Int;
	public function begin() {
		if(state!=SLEEP) return;
		if(trace_stack.length==0) return;
		ctrace = trace_stack.shift();
		state = INIT;
	}

	function init() {
		state = SLEEP;
		trace_stack = [];

		(new haxe.Timer(0)).run = mainloop;
	}

	function mainloop() {
		if(state==SLEEP) return;

		$(mixin pushobj(i) {
			if((untyped dict[i])!=null) (untyped dict[i]).id;
			else {
				var o = { id: dict_id++, obj:i, refs:[] };
				untyped dict[i] = o;
				stack.push(o);
				idl.push(o);
				o.id;
			}
		});

		if(state==INIT) {
			if(ctrace.str!=null) {
				text += ctrace.str;
				scrollV = maxScrollV;
				state = SLEEP;
				begin();
				return;
			}

			stack = [];
			idl = [];
			dict_id = 0;
			cnnt = 0;
			dict = new flash.utils.Dictionary(false);
			for(i in ctrace.objs) pushobj(i);
			state = SEARCH;
		}

		var pt = flash.Lib.getTimer();
		var buf = "";
		if(state==SEARCH)
			text += "running: stdack size="+stack.length+" cnt="+cnnt+"\n";	
		while(flash.Lib.getTimer()-pt <= 50) {
			if(state==SEARCH) {
				if(stack.length==0) {
					fcnt = 0;
					state = TRACE;
					continue;
				}

				var cur = stack.shift();
				cnnt++;
				var cls = Type.getClass(cur.obj);
				for(o in Type.getInstanceFields(cls)) {
					var field:Dynamic = Reflect.field(cur.obj, o);
					if(field!=null && Reflect.isObject(field))
						cur.refs.push({name:o, id:pushobj(field)});
				}
			}else {
				if(fcnt >= idl.length) {
					text += buf+"\nDONE\n\n";
					scrollV = maxScrollV;
					state = SLEEP;
					if(ctrace.cont!=null) {
						var objs:Array<Dynamic> = [];
						for(i in idl) objs.push(i.obj);
						ctrace.cont(objs);
					}
					begin();
					break;
				}
				var i = idl[fcnt++];
				var nme:String;
				try {
					nme = Std.string(i.obj);
				}catch(e:Dynamic) {
					nme = Std.string(e);
				}
				buf += "id: "+i.id+" refs:"+Std.string(i.refs)+" = "+Std.string(nme)+"\n";
			}
		}
		if(state==TRACE) {
			text += buf;
			scrollV = maxScrollV;
		}
	}
}

class DummyNapeMain {
	static function mains() {
		haxe.Log.setColor(0xffffff);
		var tracer = new Tracer();
		flash.Lib.current.addChild(tracer);

/*		haxe.Timer.delay(function() {
			for(i in 0...10000) {
				var b = new Body();
				b.shapes.add(new Circle(10));
				b.shapes.clear();
			}
			Debug.clearObjectPools();
		},3000);*/


		var space = new Space();
		space.gravity = Vec2.weak(0,400);
		var ceiling = new Body(Vec2.weak(0,-15));
		ceiling.shapes.add(new Polygon(Polygon.rect(0,0,768,10,true)));
		ceiling.space = space;

		var con = new PivotJoint(space.world,ceiling, new Vec2(), new Vec2());
		con.space = space;
		
		space.step(1/60);
		space.destroy();

		space = new Space();
		con.space = space;
		space.step(1/60);

//		(new haxe.Timer(400)).run = doit;

//		var v = new Circle(10, new Vec2(10,10), new Material(), new InteractionFilter());
/*		tracer.print(Debug.objectPoolStats()+"\n");
		var s = new Space(null,Broadphase.SWEEP_AND_PRUNE);
		var b = new Body();
		var v = new Polygon(Polygon.box(10,20,true));
		var c = new Compound();
		b.compound = c;
		v.body = b;
		c.space = s;

		s.bodies;
		s.constraints;
		s.liveBodies;
		s.liveConstraints;
		s.compounds;
		s.arbiters;
		c.bodies;

		tracer.trace([v], function(objs) {
			s.destroy(true);
			Debug.clearObjectPools();
			tracer.trace(objs);
		});
*/
/*		for(key in (untyped __keys__(dict)).iterator()) {
			txt.text += untyped dict[key];
		}*/
	}

//	static var s = new Space();
	static function doit() {

		var s = new Space();
		for(i in 0...100) {
			var c = new Polygon(Polygon.box(10,10));
			var b = new Body(); c.body = b;
			b.space = s;
		}

//		space.step(1/60);
		s.destroy();
		Debug.clearObjectPools();
	}


	static function maisn() {
		haxe.Log.setColor(0xffffff);
		var stage = flash.Lib.current.stage;

		var space = new Space(new Vec2(0,400)/*,Broadphase.SWEEP_AND_PRUNE*/);
		var debug = new BitmapDebug(stage.stageWidth,stage.stageHeight,0x333333,true);
		stage.addChild(debug.display);
		debug.drawShapeAngleIndicators = false;

		var border = new Body(BodyType.STATIC);
		border.shapes.add(new Polygon(Polygon.rect(0,0,-50,stage.stageHeight)));
		border.shapes.add(new Polygon(Polygon.rect(stage.stageWidth,0,50,stage.stageHeight)));
		border.shapes.add(new Polygon(Polygon.rect(0,0,stage.stageWidth,-50)));
		border.shapes.add(new Polygon(Polygon.rect(0,stage.stageHeight,stage.stageWidth,50)));
		border.space = space;

		var boxw = 6;
		var boxh = 12;
		var height = 40; //820 blocks

		for(y in 1...(height+1)) {
			for(x in 0...y) {
				var block = new Body();
				block.position.x = stage.stageWidth/2 - boxw*(y-1)/2 + x*boxw;
				//we give blocks y-position so that they're already overlapping a bit
				//since with the chain of allowed overlaps will mean 'ideal' position won't be satisfied.
				block.position.y = stage.stageHeight - boxh/2 - boxh*(height-y)*0.97;
				block.shapes.add(new Polygon(Polygon.box(boxw,boxh)));
				block.space = space;
			}
		}		

		//----------------------------------------------------------------------------------
		stage.addEventListener(flash.events.Event.ENTER_FRAME, function (_) {
			haxe.Log.clear();
			//we start of simulation with a lower timestep to help with stability as all the contact constraints 'warm up'
			//  once the contacts are 'warm' the time-step will go to full speed and the pyramid will remain standing
			//without this the pyramid will simply tumble before the contacts have had time to settle towards a solution
			//  to the huge set of contact equations.
			var dt = min(1/40, 1/200 + space.timeStamp*60*1e-5);

			debug.clear();
			space.step(dt,5,5);
			debug.draw(space);
			debug.flush();

//			trace(Debug.TIMES(space));
		});
	}

	static function main() {
		var root = flash.Lib.current;
		var space = new Space(Vec2.weak(0,300));
		var debug = new BitmapDebug(800,600,0x333333);
		debug.drawCollisionArbiters = true;
		root.addChild(debug.display);

		var q = new Body(BodyType.STATIC);
		var r = new Polygon(Polygon.rect(0,600,800,-50));
		r.body = q;
		var r = new Polygon(Polygon.rect(0,0,-50,600));
		r.body = q;
		var r = new Polygon(Polygon.rect(800,0,50,600));
		r.body = q;
		q.shapes.add(new Polygon([new Vec2(0,300),new Vec2(280,550),new Vec2(0,550)]));
		q.shapes.add(new Polygon([new Vec2(800,300),new Vec2(520,550),new Vec2(800,550)]));
		q.space = space;

		var b2 = new Body();
		b2.shapes.add(new Circle(50,null));
		b2.position.x = 400;
		b2.position.y = 200;

		var cb = new CbType();

		for(i in 0...2) {
		var b1 = new Body(); 
		b1.position = new Vec2(50+Math.random()*700,Math.random()*250);

//		b1.shapes.add(new Circle(50,new Vec2(-50,0)));
		b1.shapes.add(new Polygon(Polygon.rect(-100,-50,100,100)));
		b1.shapes.add(new Circle(50,new Vec2(50,0)));

		b1.space = space;
		b1.scaleShapes(0.5,0.5);

//		for(s in b1.shapes) s.cbType = cb;
		for(s in b1.shapes) s.cbType = cb;

		}

//		b2.space = space;
		b2.shapes.at(0).fluidEnabled= true;
		b2.shapes.at(0).fluidProperties.density = 3;

//		for(s in b2.shapes) s.cbType = cb;
		b2.cbType = cb;

		var begin = new InteractionListener(CbEvent.BEGIN, InteractionType.ANY, cb, cb, function (x,y,arbs) {
//			trace("BEG "+x.toString()+" "+y.toString()+" arbs="+arbs.toString());
		});
		begin.space = space;
		var endh = new InteractionListener(CbEvent.END, InteractionType.ANY, cb, cb, function (x,y,arbs) {
//			trace("END "+x.toString()+" "+y.toString()+" arbs="+arbs.toString());
		});
		endh.space = space;

		var pre = new PreListener(InteractionType.COLLISION, cb, cb, function (x:Arbiter):PreFlag {
			trace("pre");
			if(x.isCollisionArbiter()) {
				var carb = x.collisionArbiter;
				var i = 0;
				while(i<carb.contacts.length) {
					var c = carb.contacts.at(i);
					if(c.penetration<=10) {
						carb.contacts.remove(c);
						continue;
					}else c.penetration -= 10;
					i++;
				}
				if(carb.contacts.length==0) return PreFlag.IGNORE_ONCE;
				carb.radius -= 10;
			}else if(x.isFluidArbiter()) {
				var farb = x.fluidArbiter;
				if(farb.overlap<=100) return PreFlag.IGNORE_ONCE;
				else farb.overlap -= 100;
			}
			return PreFlag.ACCEPT_ONCE;
		});
		pre.space = space;
		pre.pure = true;

		var mcon = new PivotJoint(space.world,space.world,Vec2.weak(),Vec2.weak());
		mcon.active = false;
		mcon.stiff = false;
		mcon.space = space;

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			pre.handler = pre.handler;

			var mx = flash.Lib.current.mouseX;	
			var my = flash.Lib.current.mouseY;
			var bods = space.bodiesInCircle(Vec2.weak(mx,my), 5);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
					mcon.anchor2 = b.worldToLocal(Vec2.weak(mx,my),true);
					mcon.active = true;
				}
			}
		});

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
			mcon.active = false;
		});

		(new haxe.Timer(Std.int(1000/flash.Lib.current.stage.frameRate))).run = function() {
			debug.clear();

//			if(flash.Lib.getTimer()>4000 && (b2.arbiters.at(0).body1==b1 || b2.arbiters.at(0).body2==b1)) b2.arbiters.at(0).state = PreFlag.IGNORE;
//			if(flash.Lib.getTimer()>5000 && (b2.arbiters.at(0).body1==b1 || b2.arbiters.at(0).body2==b1)) b2.arbiters.at(0).state = PreFlag.ACCEPT;

			mcon.anchor1.setxy(flash.Lib.current.mouseX,flash.Lib.current.mouseY);

			space.step(1/60,10,10);
			debug.draw(space);

			debug.flush();
		}
	}
}

import flash.Lib;
import flash.utils.ByteArray;
import flash.Memory;

class DummyNapeMaixdsn {
public static var debug:Debug;
static function main() {
		var a = new AABB();
		trace(a.x);
		trace(a.y);
		trace(a.width);
		trace(a.height);
		trace(a.min.x);
		trace(a.max.x);
		trace(a.min.y);
		trace(a.max.y);
		a.width = 100;
		trace(a.x);
		trace(a.y);
		trace(a.width);
		trace(a.height);
		trace(a.min.x);
		trace(a.max.x);
		trace(a.min.y);
		trace(a.max.y);
		return;

        var root = Lib.current;
        Perlin3D.init_noise();

        var z = 0.0;
        var bnd = 0.0;
        var iso = function(x:Float,y:Float) return Perlin3D.noise(x/40,y/30,z)-bnd;

        /*var */debug = new ShapeDebug(400,300,0xffffff);
        root.addChild(debug.display);

        var bounds  = new AABB(0,0,400,300);
        var cells   = new Vec2(5,5);
        var grid    = new Vec2(100,100);
        var quality = 2;

        (new haxe.Timer(17)).run = function () {
            z += 1/30;
            bnd = Math.sin(z*0.3)*0.35;
            debug.clear();
            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
//                debug.drawFilledPolygon(p,colour(p));
//                var p2 = p.simplify(1);
//              if(!p2.isDegenerate()) {
//                debug.drawPolygon(p,
                debug.drawPolygon(p,0xff0000);
                    var qs = p.convex_decomposition();
                     for(q in qs) debug.drawFilledPolygon(q,colour(q));
//              }
                debug.drawPolygon(p,0);
            }
//          for(p in polys) debug.drawFilledPolygon(p,colour(p));
            debug.flush();
        }
    }

    static inline function colour(p:GeomPoly) {
        //hue
        var h = p.area()/3000*360; while(h>360) h -= 360;
        var f = (h%60)/60;

        var r:Float, g:Float, b:Float;
        if     (h<=60 ) { r = 1; g = f; b = 0; }
        else if(h<=120) { r = 1-f; g = 1; b = 0; }
        else if(h<=180) { r = 0; g = 1; b = f; }
        else if(h<=240) { r = 0; g = 1-f; b = 1; }
        else if(h<=300) { r = f; g = 0; b = 1; }
        else            { r = 1; g = 0; b = 1-f; }

        return (Std.int(r*0xff)<<16)|(Std.int(g*0xff)<<8)|Std.int(b*0xff);
    }
}

class Perlin3D {
    public static inline function noise(x:Float, y:Float, z:Float) {
        var X = Std.int(x); x -= X; X &= 0xff;
        var Y = Std.int(y); y -= Y; Y &= 0xff;
        var Z = Std.int(z); z -= Z; Z &= 0xff;
        var u = fade(x); var v = fade(y); var w = fade(z);
        var A = p(X)  +Y; var AA = p(A)+Z; var AB = p(A+1)+Z;
        var B = p(X+1)+Y; var BA = p(B)+Z; var BB = p(B+1)+Z;
        return lerp(w, lerp(v, lerp(u, grad(p(AA  ), x  , y  , z   ),
                                       grad(p(BA  ), x-1, y  , z   )),
                               lerp(u, grad(p(AB  ), x  , y-1, z   ),
                                       grad(p(BB  ), x-1, y-1, z   ))),
                       lerp(v, lerp(u, grad(p(AA+1), x  , y  , z-1 ),
                                       grad(p(BA+1), x-1, y  , z-1 )),
                               lerp(u, grad(p(AB+1), x  , y-1, z-1 ),
                                       grad(p(BB+1), x-1, y-1, z-1 ))));
    }

    static inline function fade(t:Float) return t*t*t*(t*(t*6-15)+10)
    static inline function lerp(t:Float, a:Float, b:Float) return a + t*(b-a)
    static inline function grad(hash:Int, x:Float, y:Float, z:Float) {
        var h = hash&15;
        var u = h<8 ? x : y;
        var v = h<4 ? y : h==12||h==14 ? x : z;
        return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
    }

    static inline function p(i:Int) return perm[i]
    static var perm:flash.Vector<Int>;
    
    public static function init_noise() {
        var bd = new ByteArray();
        bd.length = 8096;
        Memory.select(bd);

		  perm = new flash.Vector<Int>(512,true);

        var p = [151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

        for(i in 0...256) {
            perm[i]=    p[i];
            perm[256+i]=p[i];
        }
    }
}

class XxDummyNapeMain {
	static public var debug:Debug;

	static function mains() {
		var debug = new BitmapDebug(600,600,0xffffff);
		var grav = new Vec2(0,20*30);
		var world = new Space(grav);

		var dyn = new Body();
		dyn.position.setxy(100,100);
		var filter = new InteractionFilter(1,-1);
		var mat = new Material(0.1,0.5,0.5,0.5,0.1);

		var shape:Shape = new Circle(10, new Vec2(0,0), mat,filter);
		dyn.type = BodyType.DYNAMIC;
		dyn.allowRotation = false;
		dyn.gravMass = 0;
		dyn.shapes.add(shape);
		world.bodies.add(dyn);

		filter = new InteractionFilter(128,0);
		var anchor = new Body();
		anchor.position.setxy(20,200);
		anchor.type = BodyType.STATIC;
		shape = new Polygon(Polygon.box(100,100), mat,filter);
		anchor.shapes.add(shape);
		world.bodies.add(anchor);

		var joint = new LineJoint(anchor,dyn,new Vec2(),new Vec2(),new Vec2(1,0),0,2000);
		world.constraints.add(joint);

		var c = flash.Lib.current;
		c.addChild(debug.display);

		var tim = new haxe.Timer(Std.int(1000/60));
		tim.run = function() {
			world.step(1/60,37,37);

			var mat = new Mat23();
			debug.transform = mat;
			debug.clear();
			debug.draw(world);
			debug.flush();
		}

		haxe.Timer.delay(function(){
			joint.space = null; 
			anchor.space = null;
			dyn.space = null;
		},1000);
	}



	static function maisfn() {
		var c = flash.Lib.current;
//		haxe.Log.setColor(0xffffff);

		debug = new ShapeDebug(600,600,0x333333);
		debug.drawShapeAngleIndicators = false;
		c.addChild(debug.display);

		var body = new Body();
		body.shapes.add(new Polygon(Polygon.rect(100,100,100,100,true)));
		
		var spr = new flash.display.Sprite();
		spr.graphics.beginFill(0xff0000,1);
		spr.graphics.drawRect(100,100,100,100);
		spr.graphics.endFill();

/*		var d = body.localCOM.copy();
		body.translateShapes(d.mul(-1));
		body.position.addeq(d);
		spr.x -= d.x;
		spr.y -= d.y;*/
		
		var m = Mat23.rotation(Math.PI/2);
		trace(m.toString());
		m.concat(Mat23.translation(100,100));
		trace(m.toString());
		var m2 = new flash.geom.Matrix();
		m2.rotate(Math.PI/2);
		var m3 = new flash.geom.Matrix();
		m3.translate(100,100);
		trace([m2.a,m2.b,m2.c,m2.d,m2.tx,m2.ty]);
		m2.concat(m3);
		trace([m2.a,m2.b,m2.c,m2.d,m2.tx,m2.ty]);

		spr.rotation = 90;
		var m2 = spr.transform.matrix;
		trace([m2.a,m2.b,m2.c,m2.d,m2.tx,m2.ty]);

	}
}

class DummyNapeMains {
	static function main() {
		var debug = new BitmapDebug(800,600,0x333333);
		debug.drawShapeAngleIndicators = false;
		debug.drawConstraints = false;
		flash.Lib.current.addChild(debug.display);

		var space = new Space();

		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Circle(50));
		b.space = space;

		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Polygon(Polygon.regular(50,50,4)));
		b.space = space;

/*-		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Circle(10));
		b.space = space;*/

		var mcon = new PivotJoint(space.world,space.world,Vec2.weak(),Vec2.weak());
		mcon.active = false;
		mcon.stiff = false;
		mcon.maxForce = 0;
		mcon.space = space;

		for(b in space.bodies) b.shapes.at(0).filter.collisionMask = 0;

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			var mx = flash.Lib.current.mouseX;	
			var my = flash.Lib.current.mouseY;
			var bods = space.bodiesInCircle(Vec2.weak(mx,my), 5);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
//					mcon.anchor2 = b.worldToLocal(Vec2.weak(mx,my),true);
					mcon.active = true;
				}
			}
		});

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
			mcon.active = false;
		});
		
		var x = Vec2.get();
		var y = Vec2.get();

		(new haxe.Timer(0)).run = function() {
			debug.clear();
			space.step(1/60,10,10);
			debug.draw(space);

			if(mcon.active) {
/*				for(b in space.dynamics) {
					if(b==mcon.body2) continue;
					if(Geom.intersects(b.shapes.at(0),mcon.body2.shapes.at(0))) {
						debug.drawLine(b.worldCOM,mcon.body2.worldCOM,0xff0000);
					}
					if(Geom.contains(b.shapes.at(0),mcon.body2.shapes.at(0))) {
						debug.drawLine(b.worldCOM,mcon.body2.worldCOM,0xff00);
					}
					if(Geom.distance(b.shapes.at(0),mcon.body2.shapes.at(0),x,y)>=0) {
						debug.drawLine(x,y,0xff00ff);
					}
				}*/			
			}

			debug.flush();
		}
	}
}

#end

#else
#end
