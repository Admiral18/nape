package;

#if !(IGNORE_DUMMY)

$(import);

#if (cpp||neko)
class DummyNapeMain {
	static function main() {
		var w = 800;
		var h = 600;
		var fps = 60;
		var bgColor = 0x333333;
		var flags =
			nme.Lib.BORDERLESS |
			nme.Lib.HARDWARE |
			nme.Lib.VSYNC |
			0;
		var name = "Test Nape hxcpp/nme";

		nme.Lib.create(function() { new DummyNapeMain(); },w,h,fps,bgColor,flags,name);
	}

	function new() {
		var cur = flash.Lib.current;

		var bd = new flash.display.BitmapData(800,600,true,0x0);
		var shape = new flash.display.Shape();
		shape.graphics.beginFill(0x999999);
		shape.graphics.drawRect(0,300,800,500);
		bd.draw(shape);

		var erase = new flash.display.BitmapData(64,64,true,0xffffffff);
		shape.graphics.clear();
		shape.graphics.beginFill(0xff0000);
		shape.graphics.drawCircle(32,32,32);
		erase.draw(shape);
		erase.copyChannel(erase,erase.rect,new flash.geom.Point(), flash.display.BitmapDataChannel.BLUE, flash.display.BitmapDataChannel.ALPHA);

		var debug = new ShapeDebug(800,600,0x0);
		debug.drawShapeAngleIndicators = true;
		cur.addChild(debug.display);

		function lookup(x:Float,y:Float):Float {
			return bd.getPixel32(Std.int(x),Std.int(y))==0 ? 1 : -1;
		}

		cur.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
			bd.copyPixels(bd,new flash.geom.Rectangle(cur.mouseX-32,cur.mouseY-32,64,64), new flash.geom.Point(cur.mouseX-32,cur.mouseY-32), erase, new flash.geom.Point(), false);
		});

		cur.addEventListener(flash.events.MouseEvent.MOUSE_MOVE, function(e) {
			if(!e.buttonDown) return;

			bd.copyPixels(bd,new flash.geom.Rectangle(cur.mouseX-32,cur.mouseY-32,64,64), new flash.geom.Point(cur.mouseX-32,cur.mouseY-32), erase, new flash.geom.Point(), false);
		});


/*		var debug = new ShapeDebug(800,600);
		debug.drawShapeAngleIndicators = false;
		flash.Lib.current.addChild(debug.display);

		var space = new Space(Vec2.weak(0,400));

		var water = new Body(BodyType.STATIC);
		var w1 = new Polygon(Polygon.rect(0,0,800,300));   w1.body = water;
		var w2 = new Polygon(Polygon.rect(0,300,800,300)); w2.body = water;
		w1.fluidEnabled = w2.fluidEnabled = true;
		w1.fluidProperties.density = w2.fluidProperties.density = 4;
		w1.fluidProperties.viscosity = w2.fluidProperties.viscosity = 5;
		w1.fluidProperties.gravity = Vec2.weak(0,-400);

		water.align();
		water.kinAngVel = 2;

		water.space = space;
	
		var walls = new Body(BodyType.STATIC);
		walls.shapes.add(new Polygon(Polygon.rect(0,0,-40,600)));
		walls.shapes.add(new Polygon(Polygon.rect(800,0,40,600)));
		walls.shapes.add(new Polygon(Polygon.rect(0,0,800,-40)));
		walls.shapes.add(new Polygon(Polygon.rect(0,600,800,40)));
		walls.space = space;

		for(i in 0...1400) {
			var b = new Body();
			b.position.setxy(Math.random()*800,Math.random()*600);
			b.shapes.add(new Polygon(Polygon.regular(Math.random()*12+6,Math.random()*12+6,Std.int(Math.random()*1+3))));
			b.space = space;
		}

		var mcon = new PivotJoint(space.world,space.world,Vec2.weak(),Vec2.weak());
		mcon.stiff = false;
		mcon.space = space;
		mcon.active = false;
		mcon.space = space;

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			var mx = flash.Lib.current.mouseX;	
			var my = flash.Lib.current.mouseY;
			var bods = space.bodiesInCircle(Vec2.weak(mx,my), 5);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
					mcon.anchor2 = b.worldToLocal(Vec2.weak(mx,my),true);
					mcon.active = true;
				}
			}
		});

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
			mcon.active = false;
		});
		
		(new haxe.Timer(0)).run = function() {
			debug.clear();
			mcon.anchor1.setxy(flash.Lib.current.mouseX,flash.Lib.current.mouseY);
			space.step(1/60,6,2);
			debug.draw(space);
			debug.flush();
		}

*/

/*        var root = nme.Lib.current;
        Perlin3D.init_noise();

        var z = 0.0;
        var bnd = 0.0;
        var iso = function(x:Float,y:Float) return Perlin3D.noise(x/40,y/30,z)-bnd;

        var debug = new ShapeDebug(400,300,0xffffff);
        root.addChild(debug.display);

        var bounds  = new AABB(0,0,400,300);
        var cells   = new Vec2(5,5);
        var grid    = new Vec2(100,100);
        var quality = 2;

		var tim = new haxe.Timer(17);
        tim.run = function () {
            z += 1/30;
            bnd = Math.sin(z*0.3)*0.35;
            debug.clear();
            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
                var qs = p.convex_decomposition();
                for(q in qs) debug.drawFilledPolygon(q,colour(q));
                debug.drawPolygon(p,0);
            }
            debug.flush();
        }

		root.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
			tim.stop();
			var space = new Space(new Vec2(0,400));

			var border = new Body(BodyType.STATIC);
			border.shapes.add(new Polygon(Polygon.rect(0,0,-20,300)));
			border.shapes.add(new Polygon(Polygon.rect(400,0,20,300)));
			border.shapes.add(new Polygon(Polygon.rect(0,0,400,-20)));
			border.shapes.add(new Polygon(Polygon.rect(0,300,400,20)));
			border.space = space;

            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
				var body = new Body();
                var qs = p.convex_decomposition();
                for(q in qs) {
					body.shapes.add(new Polygon(q));
				}
				body.align();
				body.space = space;
			}

			(new haxe.Timer(17)).run = function() {
				debug.clear();
				space.step(1/60,10,5);
				debug.draw(space);
				debug.flush();
			}
		});*/
    }

    static inline function colour(p:GeomPoly) {
        //hue
        var h = p.area()/3000*360; while(h>360) h -= 360;
        var f = (h%60)/60;

        var r:Float, g:Float, b:Float;
        if     (h<=60 ) { r = 1; g = f; b = 0; }
        else if(h<=120) { r = 1-f; g = 1; b = 0; }
        else if(h<=180) { r = 0; g = 1; b = f; }
        else if(h<=240) { r = 0; g = 1-f; b = 1; }
        else if(h<=300) { r = f; g = 0; b = 1; }
        else            { r = 1; g = 0; b = 1-f; }

        return (Std.int(r*0xff)<<16)|(Std.int(g*0xff)<<8)|Std.int(b*0xff);
    }
}

class Perlin3D {
    public static inline function noise(x:Float, y:Float, z:Float) {
        var X = Std.int(x); x -= X; X &= 0xff;
        var Y = Std.int(y); y -= Y; Y &= 0xff;
        var Z = Std.int(z); z -= Z; Z &= 0xff;
        var u = fade(x); var v = fade(y); var w = fade(z);
        var A = p(X)  +Y; var AA = p(A)+Z; var AB = p(A+1)+Z;
        var B = p(X+1)+Y; var BA = p(B)+Z; var BB = p(B+1)+Z;
        return lerp(w, lerp(v, lerp(u, grad(p(AA  ), x  , y  , z   ),
                                       grad(p(BA  ), x-1, y  , z   )),
                               lerp(u, grad(p(AB  ), x  , y-1, z   ),
                                       grad(p(BB  ), x-1, y-1, z   ))),
                       lerp(v, lerp(u, grad(p(AA+1), x  , y  , z-1 ),
                                       grad(p(BA+1), x-1, y  , z-1 )),
                               lerp(u, grad(p(AB+1), x  , y-1, z-1 ),
                                       grad(p(BB+1), x-1, y-1, z-1 ))));
    }

    static inline function fade(t:Float) return t*t*t*(t*(t*6-15)+10)
    static inline function lerp(t:Float, a:Float, b:Float) return a + t*(b-a)
    static inline function grad(hash:Int, x:Float, y:Float, z:Float) {
        var h = hash&15;
        var u = h<8 ? x : y;
        var v = h<4 ? y : h==12||h==14 ? x : z;
        return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
    }

    static inline function p(i:Int) return perm[i]
    static var perm:Array<Int>;
    
    public static function init_noise() {
		perm = new Array<Int>();

        var p = [151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

        for(i in 0...256) {
            perm[i]=    p[i];
            perm[256+i]=p[i];
        }
    }
}


#elseif swc
class DummyNapeMain {
}

#else 

class Tracer {
	static public function trace(objs:Array<Dynamic>,txt:flash.text.TextField) {
		var dict_id = 0;
		var stack = [];
		var dict = new flash.utils.Dictionary(false);
		var idl = [];
		
		var sdict = new Hash<Bool>();
		var stats = [];

		$(mixin pushobj(i) ({
			if((untyped dict[i])!=null) (untyped dict[i]).id;
			else {
				var o = { id: dict_id++, obj:i, refs:[] };
				untyped dict[i] = o;
				stack.push(o);
				idl.push(o);
				o.id;
			}
		}));

		for(i in objs) pushobj(i);
		var tim = new haxe.Timer(0);

		var fcnt = 0;
		var finish2 = function() {
			var pt = flash.Lib.getTimer();
			var buf = "";
			while(flash.Lib.getTimer()-pt <= 50) {
				if(fcnt >= stats.length) {
					txt.text += buf+"\n\nDONE";
					txt.scrollV = txt.maxScrollV;
					tim.stop();
					return;
				}
				var i = stats[fcnt++];
				buf += "nme: "+i.name+" refs:"+Std.string(i.refs)+"\n";
			}
		}

		var finish = function() {	
			var pt = flash.Lib.getTimer();
			var buf = "";
			while(flash.Lib.getTimer()-pt <= 50) {
				if(fcnt >= idl.length) {
					txt.text += buf+"\n";
					txt.scrollV = txt.maxScrollV;
					fcnt = 0;
					tim.run = finish2;
					return;
				}
				var i = idl[fcnt++];
				buf += "id: "+i.id+" refs:"+Std.string(i.refs)+" = "+Std.string(i.obj)+"\n";
			}
			txt.text += buf;
			txt.scrollV = txt.maxScrollV;
		}

		var cnnt = 0;
		tim.run = function() {
			txt.text = "running: stack size="+stack.length+" cnt="+cnnt+"\n";

			if(stack.length==0) { tim.run = finish; txt.text = ""; return; }

			var pt = flash.Lib.getTimer();
			while(flash.Lib.getTimer()-pt <= 50) {
				if(stack.length==0) { tim.run = finish; txt.text = ""; return; }

				var cur = stack.shift();
				cnnt++;
				var cls = Type.getClass(cur.obj);
				for(o in Type.getInstanceFields(cls)) {
					var field:Dynamic = Reflect.field(cur.obj, o);
					if(field!=null && Reflect.isObject(field)) {
						cur.refs.push({ name:o, id:	pushobj(field) });
					}
				}
				var nme = Type.getClassName(cls);
				if(!sdict.exists(nme)) {
					sdict.set(nme,true);
					var ccur = [];
					for(o in Type.getClassFields(cls)) {
						var field:Dynamic = Reflect.field(cur.obj, o);
						if(field!=null && Reflect.isObject(field)) {
							ccur.push({ name:o, id: pushobj(field) });
						}
					}
					stats.push({name:nme,refs:ccur});
				}
			}
		}
	}
}

class DummyNapeMain {
public		static var txt = new flash.text.TextField();
		public static function traces(t:Dynamic) {
			txt.text += Std.string(t)+"\n";
		}
	static function mains() {
		haxe.Log.setColor(0xffffff);

		var txt = new flash.text.TextField();
		txt.width = flash.Lib.current.stage.stageWidth;
		txt.height = flash.Lib.current.stage.stageHeight;
		flash.Lib.current.addChild(txt);

/*		haxe.Timer.delay(function() {
			for(i in 0...10000) {
				var b = new Body();
				b.shapes.add(new Circle(10));
				b.shapes.clear();
			}
			Debug.clearObjectPools();
		},3000);*/

/*		var g = new BitmapDebug(800,600,0x333333); flash.Lib.current.addChild(g.display);
		g.clear();
		PR(AngleDraw).drawSpiral(g, 100,100, 0,Math.PI*10, 60,10, 0xffffff);
		g.flush();*/

		var b = new Body();
		trace(b.rotation);
		b.rotation += 2;
		trace(b.rotation);
		b.rotation -= 8;
		trace(b.rotation);

//		(new haxe.Timer(400)).run = doit;
//		Tracer.trace([c,b],txt);

/*		for(key in (untyped __keys__(dict)).iterator()) {
			txt.text += untyped dict[key];
		}*/
		
	}

	static var space = new Space();
	static function doit() {
		for(i in 0...100) {
			var c = new Polygon(Polygon.box(10,10));
//			var c = new Circle(10);
			var b = new Body(); c.body = b;
			b.position.x = Math.random()*800;
			b.position.y = Math.random()*600;
			b.space = space;
		}
		space.step(1/60);
		space.clear();
//		Debug.clearObjectPools();
	}


	static function parse(s:String):GeomPoly {
		var beg = s.indexOf("[");
		var end = s.indexOf("]");
		var data = s.substr(beg+2,end-beg-2).split("},{");
		var ret = new GeomPoly();
		for(p in data) {
			var pd = p.split(",");
			ret.push(new Vec2(Std.parseFloat(pd[0]),Std.parseFloat(pd[1])));
		}
		return ret;
	}

	public static var debug:Debug;	
	static function main() {
		debug = new ShapeDebug(1,1);
		flash.Lib.current.addChild(debug.display);
		var s = "poly=GeomPoly[{244,0},{320,0},{320,2},{320,4},{320,6},{320,8},{320,10},{320,12},{320,14},{320,16},{320,18},{320,20},{320,22},{320,24},{320,26},{320,28},{320,30},{320,32},{320,34},{320,36},{320,38},{320,40},{320,42},{320,44},{320,46},{320,48},{320,50},{320,52},{320,54},{320,56},{320,58},{320,60},{320,62},{320,64},{320,66},{320,68},{320,70},{320,72},{320,74},{320,76},{320,78},{320,80},{320,82},{320,84},{320,86},{320,88},{320,90},{320,92},{320,94},{320,96},{320,98},{320,100},{320,102},{320,104},{320,106},{320,108},{320,110},{320,112},{320,114},{320,116},{320,118},{320,120},{320,122},{320,124},{320,126},{320,128},{320,130},{320,132},{320,134},{320,136},{320,138},{320,140},{320,142},{320,144},{320,146},{320,148},{320,150},{320,152},{320,154},{320,156},{320,158},{320,160},{320,162},{320,164},{320,166},{320,168},{320,170},{320,172},{320,174},{320,176},{320,178},{320,180},{320,182},{320,184},{320,186},{320,188},{320,190},{320,192},{320,194},{320,196},{320,198},{320,200},{320,202},{320,204},{320,206},{320,208},{320,210},{320,212},{320,214},{320,216},{320,218},{320,220},{320,222},{320,224},{320,226},{320,228},{320,230},{320,232},{320,234},{320,236},{320,238},{320,240},{320,242},{320,244},{320,246},{320,248},{320,250},{320,252},{320,254},{320,256},{320,258},{320,260},{320,262},{320,264},{320,266},{320,268},{320,270},{320,272},{320,274},{320,276},{320,278},{320,280},{320,282},{320,284},{320,286},{320,288},{320,290},{320,292},{320,294},{320,296},{320,298},{320,300},{320,302},{320,304},{320,306},{320,308},{320,310},{320,312},{320,314},{320,316},{320,318},{320,320},{320,322},{320,324},{320,326},{320,328},{320,330},{320,332},{320,334},{320,336},{320,338},{320,340},{320,342},{320,344},{320,346},{320,348},{320,350},{320,352},{320,354},{320,356},{320,358},{320,360},{320,362},{320,364},{320,366},{320,368},{320,370},{320,372},{320,374},{320,376},{320,378},{320,380},{320,382},{320,384},{320,386},{320,388},{320,390},{320,392},{320,394},{320,396},{320,398},{320,400},{320,402},{320,404},{320,406},{320,408},{320,410},{320,412},{320,414},{320,416},{320,418},{320,420},{320,422},{320,424},{320,426},{320,428},{320,430},{320,432},{320,434},{320,436},{320,438},{320,440},{320,442},{320,444},{320,446},{320,448},{320,450},{320,452},{320,454},{320,456},{320,458},{320,460},{320,462},{320,464},{320,466},{320,468},{320,470},{320,472},{320,474},{320,476},{320,478},{318,480},{316,480},{314,480},{312,480},{310,480},{308,480},{306,480},{304,480},{302,480},{300,480},{298,480},{296,480},{294,480},{292,480},{290,480},{288,480},{286,480},{284,480},{282,480},{280,480},{278,480},{276,480},{274,480},{272,480},{270,480},{268,480},{266,480},{264,480},{262,480},{260,480},{258,480},{256,480},{254,480},{252,480},{250,480},{248,480},{246,480},{244,480},{242,480},{240,480},{238,480},{236,480},{234,480},{232,480},{230,480},{228,478},{228,476},{228,474},{230,472},{230,470},{230,468},{230,466},{230,464},{230,462},{230,460},{230,458},{230,456},{230,454},{230,452},{230,450},{230,448},{232,446},{232,444},{232,442},{232,440},{232,438},{234,436},{234,434},{234,432},{234,430},{236,428},{236,426},{236,424},{236,422},{236,420},{238,418},{238,416},{238,414},{238,412},{240,410},{240,408},{242,406},{242,404},{242,402},{242,400},{244,398},{246,396},{248,394},{250,392},{252,390},{254,388},{254,386},{256,384},{256,382},{258,380},{258,378},{260,376},{260,374},{262,372},{262,370},{264,368},{264,366},{264,364},{264,362},{266,360},{268,358},{268,356},{270,354},{272,352},{272,350},{272,348},{274,346},{274,344},{276,342},{276,340},{276,338},{278,336},{278,334},{280,332},{282,330},{282,328},{284,326},{286,326},{288,324},{288,322},{290,320},{290,318},{290,316},{290,314},{290,312},{290,310},{290,308},{292,306},{292,304},{292,302},{292,300},{294,298},{294,296},{294,294},{294,292},{296,290},{296,288},{296,286},{298,284},{298,282},{298,280},{300,278},{300,276},{300,274},{302,272},{302,270},{302,268},{304,266},{304,264},{304,262},{304,260},{306,258},{306,256},{306,254},{306,252},{306,250},{306,248},{306,246},{304,244},{304,242},{304,240},{304,238},{304,236},{302,234},{302,232},{302,230},{302,228},{302,226},{300,224},{300,222},{300,220},{298,218},{298,216},{298,214},{296,212},{296,210},{296,208},{296,206},{296,204},{296,202},{296,200},{296,198},{296,196},{296,194},{296,192},{296,190},{296,188},{296,186},{294,184},{294,182},{294,180},{294,178},{292,176},{292,174},{292,172},{292,170},{292,168},{290,166},{290,164},{290,162},{290,160},{288,158},{288,156},{288,154},{288,152},{288,150},{288,148},{288,146},{288,144},{286,142},{286,140},{284,138},{284,136},{282,134},{282,132},{280,130},{280,128},{278,126},{278,124},{278,122},{276,120},{276,118},{276,116},{274,114},{274,112},{274,110},{274,108},{272,106},{272,104},{272,102},{272,100},{270,98},{270,96},{270,94},{268,92},{268,90},{268,88},{266,86},{266,84},{264,82},{264,80},{264,78},{264,76},{262,74},{262,72},{260,70},{260,68},{258,66},{256,64},{256,62},{254,60},{254,58},{254,56},{252,54},{252,52},{252,50},{250,48},{250,46},{250,44},{248,42},{248,40},{246,38},{246,36},{246,34},{244,32},{244,30},{244,28},{244,26},{244,24},{242,22},{242,20},{242,18},{242,16},{242,14},{242,12},{242,10},{242,8},{242,6},{244,4},{244,2}]";
		var gp = parse(s);
		debug.drawPolygon(gp,0xff0000);
		for(p in gp.convex_decomposition()) {
			debug.drawPolygon(p,Std.int(0xffffff*Math.random()));
			if((new Polygon(p)).validity() != ValidationResult.VALID)
				throw "oh no";
		}
	}
}

import flash.Lib;
import flash.utils.ByteArray;
import flash.Memory;

class DummyNapeMaixdsn {
public static var debug:Debug;
static function main() {
		var a = new AABB();
		trace(a.x);
		trace(a.y);
		trace(a.width);
		trace(a.height);
		trace(a.min.x);
		trace(a.max.x);
		trace(a.min.y);
		trace(a.max.y);
		a.width = 100;
		trace(a.x);
		trace(a.y);
		trace(a.width);
		trace(a.height);
		trace(a.min.x);
		trace(a.max.x);
		trace(a.min.y);
		trace(a.max.y);
		return;

        var root = Lib.current;
        Perlin3D.init_noise();

        var z = 0.0;
        var bnd = 0.0;
        var iso = function(x:Float,y:Float) return Perlin3D.noise(x/40,y/30,z)-bnd;

        /*var */debug = new ShapeDebug(400,300,0xffffff);
        root.addChild(debug.display);

        var bounds  = new AABB(0,0,400,300);
        var cells   = new Vec2(5,5);
        var grid    = new Vec2(100,100);
        var quality = 2;

        (new haxe.Timer(17)).run = function () {
            z += 1/30;
            bnd = Math.sin(z*0.3)*0.35;
            debug.clear();
            var polys = MarchingSquares.run(iso, bounds, cells, quality, grid);
            for(p in polys) {
//                debug.drawFilledPolygon(p,colour(p));
//                var p2 = p.simplify(1);
//              if(!p2.isDegenerate()) {
//                debug.drawPolygon(p,
                debug.drawPolygon(p,0xff0000);
//              }
                debug.drawPolygon(p,0);
            }
//          for(p in polys) debug.drawFilledPolygon(p,colour(p));
            debug.flush();
        }
    }

    static inline function colour(p:GeomPoly) {
        //hue
        var h = p.area()/3000*360; while(h>360) h -= 360;
        var f = (h%60)/60;

        var r:Float, g:Float, b:Float;
        if     (h<=60 ) { r = 1; g = f; b = 0; }
        else if(h<=120) { r = 1-f; g = 1; b = 0; }
        else if(h<=180) { r = 0; g = 1; b = f; }
        else if(h<=240) { r = 0; g = 1-f; b = 1; }
        else if(h<=300) { r = f; g = 0; b = 1; }
        else            { r = 1; g = 0; b = 1-f; }

        return (Std.int(r*0xff)<<16)|(Std.int(g*0xff)<<8)|Std.int(b*0xff);
    }
}

class Perlin3D {
    public static inline function noise(x:Float, y:Float, z:Float) {
        var X = Std.int(x); x -= X; X &= 0xff;
        var Y = Std.int(y); y -= Y; Y &= 0xff;
        var Z = Std.int(z); z -= Z; Z &= 0xff;
        var u = fade(x); var v = fade(y); var w = fade(z);
        var A = p(X)  +Y; var AA = p(A)+Z; var AB = p(A+1)+Z;
        var B = p(X+1)+Y; var BA = p(B)+Z; var BB = p(B+1)+Z;
        return lerp(w, lerp(v, lerp(u, grad(p(AA  ), x  , y  , z   ),
                                       grad(p(BA  ), x-1, y  , z   )),
                               lerp(u, grad(p(AB  ), x  , y-1, z   ),
                                       grad(p(BB  ), x-1, y-1, z   ))),
                       lerp(v, lerp(u, grad(p(AA+1), x  , y  , z-1 ),
                                       grad(p(BA+1), x-1, y  , z-1 )),
                               lerp(u, grad(p(AB+1), x  , y-1, z-1 ),
                                       grad(p(BB+1), x-1, y-1, z-1 ))));
    }

    static inline function fade(t:Float) return t*t*t*(t*(t*6-15)+10)
    static inline function lerp(t:Float, a:Float, b:Float) return a + t*(b-a)
    static inline function grad(hash:Int, x:Float, y:Float, z:Float) {
        var h = hash&15;
        var u = h<8 ? x : y;
        var v = h<4 ? y : h==12||h==14 ? x : z;
        return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
    }

    static inline function p(i:Int) return perm[i]
    static var perm:flash.Vector<Int>;
    
    public static function init_noise() {
        var bd = new ByteArray();
        bd.length = 8096;
        Memory.select(bd);

		  perm = new flash.Vector<Int>(512,true);

        var p = [151,160,137,91,90,15,
        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

        for(i in 0...256) {
            perm[i]=    p[i];
            perm[256+i]=p[i];
        }
    }
}

class XxDummyNapeMain {
	static public var debug:Debug;

	static function mains() {
		var debug = new BitmapDebug(600,600,0xffffff);
		var grav = new Vec2(0,20*30);
		var world = new Space(grav);

		var dyn = new Body();
		dyn.position.setxy(100,100);
		var filter = new InteractionFilter(1,-1);
		var mat = new Material(0.1,0.5,0.5,0.5,0.1);

		var shape:Shape = new Circle(10, new Vec2(0,0), mat,filter);
		dyn.type = BodyType.DYNAMIC;
		dyn.allowRotation = false;
		dyn.gravMass = 0;
		dyn.shapes.add(shape);
		world.bodies.add(dyn);

		filter = new InteractionFilter(128,0);
		var anchor = new Body();
		anchor.position.setxy(20,200);
		anchor.type = BodyType.STATIC;
		shape = new Polygon(Polygon.box(100,100), mat,filter);
		anchor.shapes.add(shape);
		world.bodies.add(anchor);

		var joint = new LineJoint(anchor,dyn,new Vec2(),new Vec2(),new Vec2(1,0),0,2000);
		world.constraints.add(joint);

		var c = flash.Lib.current;
		c.addChild(debug.display);

		var tim = new haxe.Timer(Std.int(1000/60));
		tim.run = function() {
			world.step(1/60,37,37);

			var mat = new Mat23();
			debug.transform = mat;
			debug.clear();
			debug.draw(world);
			debug.flush();
		}

		haxe.Timer.delay(function(){
			joint.space = null; 
			anchor.space = null;
			dyn.space = null;
		},1000);
	}



	static function maisfn() {
		var c = flash.Lib.current;
//		haxe.Log.setColor(0xffffff);

		debug = new ShapeDebug(600,600,0x333333);
		debug.drawShapeAngleIndicators = false;
		c.addChild(debug.display);

		var body = new Body();
		body.shapes.add(new Polygon(Polygon.rect(100,100,100,100,true)));
		
		var spr = new flash.display.Sprite();
		spr.graphics.beginFill(0xff0000,1);
		spr.graphics.drawRect(100,100,100,100);
		spr.graphics.endFill();

/*		var d = body.localCOM.copy();
		body.translateShapes(d.mul(-1));
		body.position.addeq(d);
		spr.x -= d.x;
		spr.y -= d.y;*/
		
		var m = Mat23.rotation(Math.PI/2);
		trace(m.toString());
		m.concat(Mat23.translation(100,100));
		trace(m.toString());
		var m2 = new flash.geom.Matrix();
		m2.rotate(Math.PI/2);
		var m3 = new flash.geom.Matrix();
		m3.translate(100,100);
		trace([m2.a,m2.b,m2.c,m2.d,m2.tx,m2.ty]);
		m2.concat(m3);
		trace([m2.a,m2.b,m2.c,m2.d,m2.tx,m2.ty]);

		spr.rotation = 90;
		var m2 = spr.transform.matrix;
		trace([m2.a,m2.b,m2.c,m2.d,m2.tx,m2.ty]);

	}
}

class DummyNapeMains {
	static function main() {
		var debug = new BitmapDebug(800,600,0x333333);
		debug.drawShapeAngleIndicators = false;
		debug.drawConstraints = false;
		flash.Lib.current.addChild(debug.display);

		var space = new Space();

		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Circle(50));
		b.space = space;

		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Polygon(Polygon.regular(50,50,4)));
		b.space = space;

/*-		var b = new Body(BodyType.DYNAMIC, Vec2.weak(400,300));
		b.shapes.add(new Circle(10));
		b.space = space;*/

		var mcon = new PivotJoint(space.world,space.world,Vec2.weak(),Vec2.weak());
		mcon.active = false;
		mcon.stiff = false;
		mcon.maxForce = 0;
		mcon.space = space;

		for(b in space.bodies) b.shapes.at(0).filter.collisionMask = 0;

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
			var mx = flash.Lib.current.mouseX;	
			var my = flash.Lib.current.mouseY;
			var bods = space.bodiesInCircle(Vec2.weak(mx,my), 5);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
//					mcon.anchor2 = b.worldToLocal(Vec2.weak(mx,my),true);
					mcon.active = true;
				}
			}
		});

		flash.Lib.current.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (_) {
			mcon.active = false;
		});
		
		var x = Vec2.get();
		var y = Vec2.get();

		(new haxe.Timer(0)).run = function() {
			debug.clear();
			space.step(1/60,10,10);
			debug.draw(space);

			if(mcon.active) {
/*				for(b in space.dynamics) {
					if(b==mcon.body2) continue;
					if(Geom.intersects(b.shapes.at(0),mcon.body2.shapes.at(0))) {
						debug.drawLine(b.worldCOM,mcon.body2.worldCOM,0xff0000);
					}
					if(Geom.contains(b.shapes.at(0),mcon.body2.shapes.at(0))) {
						debug.drawLine(b.worldCOM,mcon.body2.worldCOM,0xff00);
					}
					if(Geom.distance(b.shapes.at(0),mcon.body2.shapes.at(0),x,y)>=0) {
						debug.drawLine(x,y,0xff00ff);
					}
				}*/			
			}

			debug.flush();
		}
	}
}

#end

#else
#end
