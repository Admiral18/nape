package;

$(import);

#if cpp
class DummyNapeMain {
	static function main() {}
}
#elseif swc
class DummyNapeMain {
	static function main() {}
}

#else 
class DummyNapeMain {
	static function main() {
		var c = flash.Lib.current;
		haxe.Log.setColor(0xffffff);
		debug = new ShapeDebug(0x333333);
		c.addChild(debug.display);
		var txt = new flash.text.TextField();
		txt.defaultTextFormat = new flash.text.TextFormat(null,null,0xffffff);
		c.addChild(txt);
		txt.width = 600;
		txt.height = 600;
		txt.selectable = false;
		c.stage.quality = flash.display.StageQuality.LOW;

			var space = new Space(new Vec2(0, 450), Broadphase.DYNAMIC_AABB_TREE);
//			var space = new Space(new Vec2(0, 450), Broadphase.SWEEP_AND_PRUNE);

			var waterBody = new Body(BodyType.STATIC, new Vec2(0, 0));
			var heroBody = new Body(BodyType.DYNAMIC, new Vec2(0, 0));
			var randomBody = new Body(BodyType.DYNAMIC, new Vec2(0, 0));
			
			var waterShape = new Polygon([new Vec2(0, 200), new Vec2(700, 200), new Vec2(700, 500), new Vec2(0, 500)], new Material(), new InteractionFilter(1, 1));
			waterShape.fluidEnabled = true;
			waterShape.fluidProperties = new FluidProperties(2.75, 1.5);
			waterBody.shapes.add(waterShape);
			waterBody.space = space;
			
			var shape = new Circle(15, new Vec2(0, 13), new Material(0, 0, 0, 1.5, 0), new InteractionFilter(1, 1));
			var shape2 = new Circle(13, new Vec2(0, -13), new Material(0, 0, 0, 1.5, 0), new InteractionFilter(1, 1));
			var feet = new Circle(6, new Vec2(0, 24), new Material(0, 8, 9, 1, 1), new InteractionFilter(1, 1));
			heroBody.shapes.add(shape);
			heroBody.shapes.add(shape2);
			heroBody.shapes.add(feet);
			heroBody.space = space;
			
			var randomShape = new Polygon(Polygon.rect(0, 0, 30, 30), Material.wood(), new InteractionFilter(1, 1));
			randomBody.shapes.add(randomShape);
			randomBody.align();
			randomBody.space = space;
			
			heroBody.position.x = 450;
			heroBody.position.y = 100;
			heroBody.allowRotation = false;
			
			randomBody.position.x = 200;
			randomBody.position.y = 100;
			
			space.step(1 / 1000);
			
			c.addEventListener(flash.events.Event.ENTER_FRAME, function(_) {
				space.step(1/60);
				debug.clear();
				debug.draw(space);
				debug.flush();
			});
	}

	static public var debug:Debug;
	static function mains() {
        var c = flash.Lib.current;
        haxe.Log.setColor(0xffffff);

		//var space = new Space(new Vec2(0,400),Broadphase.SWEEP_AND_PRUNE);
		var space = new Space(new Vec2(0,400));
		/*var*/ debug = new BitmapDebug(600,600,0x333333);
        c.addChild(debug.display);
		
        var txt = new flash.text.TextField();
        txt.x = 20;
        txt.defaultTextFormat = new flash.text.TextFormat(null,null,0xffffff);
        c.addChild(txt);

        var pt = flash.Lib.getTimer();
		txt.x = 300;
        txt.width = 600;
        txt.height = 600;
        txt.selectable = false;

        debug.drawConstraints = true;
        c.stage.quality = flash.display.StageQuality.LOW;

		var walls = new Body(BodyType.STATIC);
		walls.shapes.add(new Polygon(Polygon.rect(0,550,600,50)));
		walls.shapes.add(new Polygon(Polygon.rect(0,0,600,50)));
		walls.shapes.add(new Polygon(Polygon.rect(0,0,50,600)));
		walls.shapes.add(new Polygon(Polygon.rect(550,0,50,600)));
		walls.space = space;

		for(i in 0...4) {
			var b = new Body();
			var s = new Circle(60);
			s.fluidEnabled = true;
			s.fluidProperties.density = 2;
			s.material.density = 2;
			s.body = b;
			b.space = space;
			b.position.setxy(Math.random()*500+50,Math.random()*500+50);
			s.filter.fluidGroup = 2;
			s.filter.fluidMask = 1;
		}

		for(i in 0...300) {
			var b = new Body();
			b.shapes.add(new Polygon(Polygon.box(16,16)));
			var xi = i%18;
			var yi =Std.int( (i-xi)/18);
			b.position.setxy(50+xi*16,50+yi*16);
			b.space = space;
		}

		for(X in 0...0) {
				var px = 300-150 + 150*X;
	
		var tri = new Body(BodyType.STATIC);
		tri.shapes.add(new Polygon(Polygon.regular(50,50,3)));
		tri.position.setxy(px,300);
		tri.space = space;

		var ball = new Body();
		ball.shapes.add(new Circle(25));

		var pre = tri;
		for(i in 0...20) {
			var link = new Body();
			link.shapes.add(new Circle(4));
			link.space = space;
			link.position.setxy(px+25,300+(i+1)*8);

			var a1 = if(pre==tri) new Vec2(25,0) else new Vec2(0,4);
			var con = new PivotJoint(pre,link,a1,new Vec2(0,-4));
			con.space = space;
			con.ignore = true;
			pre = link;
		}
//		ball.shapes.at(0).material.density /= 4;
		ball.position.setxy(px+25,300+20*8+4+12.5);
		ball.space = space;
		var con = new PivotJoint(pre,ball,new Vec2(0,4), new Vec2(0,-25));
		con.space = space;
		con.ignore = true;
		}

		var mcon = new PivotJoint(space.world,space.world, new Vec2(), new Vec2());
		mcon.stiff = false;
		mcon.maxForce = 50000;
		mcon.active = false;
		mcon.space = space;

		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (ev) {
			var pv = new Vec2(c.mouseX,c.mouseY);
			var bods = space.bodiesUnderPoint(pv);
			var bods = space.bodiesUnderPoint(pv);
			for(b in bods) {
				if(b.isDynamic()) {
					mcon.body2 = b;
					mcon.anchor2 = b.worldToLocal(pv);
					mcon.active = true;
					break;
				}
			}
		});
		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function (ev) {
			mcon.active = false;
		});
        
		var tim = new haxe.Timer(0);
        tim.run = function() {
            var ct = flash.Lib.getTimer();
            var dt = (ct-pt)/1000;
            txt.text = "fps: "+Std.string(1/dt).substr(0,5);
            pt = ct;

            debug.clear();
			mcon.anchor1.setxy(c.mouseX,c.mouseY);
            space.step(1/40,40,40);
            
            #if NAPE_TIMES var pt = flash.Lib.getTimer(); #end
            debug.draw(space);
            #if NAPE_TIMES Debug.DRAW += flash.Lib.getTimer()-pt; #end

            #if NAPE_TIMES
                txt.text += "\n\n"+Debug.TIMES(space);
            #end

			var ray = new Ray(new Vec2(300,300), new Vec2(300-c.mouseX,300-c.mouseY).mul(-1));
			var res = space.rayMultiCast(ray,true);
			for(r in res) {
				debug.drawCircle(ray.at(r.distance),2,0xffff);
				//	debug.drawLine(ray.origin, ray.at(res.distance), 0xff00ff);
				//	debug.drawCircle(ray.at(res.distance),2,0xffff);
			}
            debug.flush();
		}
	}
}
#end
