package;

$(import);

#if cpp
class DummyNapeMain {
	static function main() {}
}
#elseif swc
class DummyNapeMain {
	static function main() {}
}

#elseif true

class Doll {
    public var headB:Body;
    public var torsoB:Body;
    public var legUpLeft:Body;
	public var legUpRight:Body;
	public var legBottomLeft:Body;
	public var legBottomRight:Body;
	public var armUpLeft:Body;
	public var armUpRight:Body;
	public var armBottomLeft:Body;
	public var armBottomRight:Body;
    private var space:Space;
    public var filter:InteractionFilter;

    public function new(x:Float,y:Float, space:Space) {
            filter = new InteractionFilter(2,3);
            filter.shared = true;
            var ragMaterial:Material = new Material(0.2, 0.4, 0.4, 10);
			ragMaterial.shared = true;

            this.space = space;

            headB = new Body(BodyType.DYNAMIC, new Vec2(x+0, y-6.35));
			headB.shapes.add(new Circle(16, null, ragMaterial, filter));
			torsoB = new Body(BodyType.DYNAMIC, new Vec2(x+0, y+22));
			torsoB.shapes.add(new Polygon(Polygon.box(15.5, 26.6), ragMaterial, filter ));
			legUpLeft = new Body(BodyType.DYNAMIC, new Vec2(x - 4.4, y + 37.45));
			legUpLeft.shapes.add(new Polygon(Polygon.box(4.4, 12), ragMaterial, filter));
			legUpRight = new Body(BodyType.DYNAMIC, new Vec2(x + 4.4, y + 37.45));
			legUpRight.shapes.add(new Polygon(Polygon.box(4.4, 12), ragMaterial, filter));
			legBottomLeft = new Body(BodyType.DYNAMIC, new Vec2(x - 4.1, y + 46.3));
			legBottomLeft.shapes.add(new Polygon(Polygon.box(6.25, 11), ragMaterial, filter));
			legBottomRight = new Body(BodyType.DYNAMIC, new Vec2(x + 4.1, y + 46.3));
			legBottomRight.shapes.add(new Polygon(Polygon.box(6.25, 11), ragMaterial, filter));
			
			armUpLeft = new Body(BodyType.DYNAMIC, new Vec2(x - 7.5, y + 15));
			armUpLeft.shapes.add(new Polygon(Polygon.box(5, 11), ragMaterial, filter));
			armUpRight = new Body(BodyType.DYNAMIC, new Vec2(x + 7.5, y + 15));
			armUpRight.shapes.add(new Polygon(Polygon.box(5, 11), ragMaterial, filter));
			armBottomLeft = new Body(BodyType.DYNAMIC, new Vec2(x - 7.6, y + 25.2));
			armBottomLeft.shapes.add(new Polygon(Polygon.box(3.85, 14.75), ragMaterial, filter));
			armBottomRight = new Body(BodyType.DYNAMIC, new Vec2(x + 7.6, y + 25.2));
			armBottomRight.shapes.add(new Polygon(Polygon.box(3.85, 14.75), ragMaterial, filter));
			
			headB.space = torsoB.space = legUpLeft.space = legUpRight.space = legBottomLeft.space = legBottomRight.space =  armUpLeft.space = armUpRight.space = armBottomLeft.space = armBottomRight.space = space;
			
			
			/*headB
			torsoB
			legUpLeft
			legUpRight
			legBottomLeft
			legBottomRight
			armUpLeft
			armUpRight
			armBottomLeft
			armBottomRight*/
			
			headB.userData = this;
			torsoB.userData = this;
			legUpLeft.userData = this;
			legUpRight.userData = this;
			legBottomLeft.userData = this;
			legBottomRight.userData = this;
			armUpLeft.userData = this;
			armUpRight.userData = this;
			armBottomLeft.userData = this;
			armBottomRight.userData = this;
			
			headB.type = BodyType.STATIC;
			torsoB.type = BodyType.STATIC;
			legUpLeft.type = BodyType.STATIC;
			legUpRight.type = BodyType.STATIC;
			legBottomLeft.type = BodyType.STATIC;
			legBottomRight.type = BodyType.STATIC;
			armUpLeft.type = BodyType.STATIC;
			armUpRight.type = BodyType.STATIC;
			armBottomLeft.type = BodyType.STATIC;
			armBottomRight.type = BodyType.STATIC;
		}
		
		public function activate() {
			headB.type = BodyType.DYNAMIC;
			torsoB.type = BodyType.DYNAMIC;
			legUpLeft.type = BodyType.DYNAMIC;
			legUpRight.type = BodyType.DYNAMIC;
			legBottomLeft.type = BodyType.DYNAMIC;
			legBottomRight.type = BodyType.DYNAMIC;
			armUpLeft.type = BodyType.DYNAMIC;
			armUpRight.type = BodyType.DYNAMIC;
			armBottomLeft.type = BodyType.DYNAMIC;
			armBottomRight.type = BodyType.DYNAMIC;
			
			filter.collisionGroup = 8;
			filter.collisionMask = 1;

			var headA:AngleJoint = new AngleJoint(headB, torsoB, -10 * Math.PI/180, 10 * Math.PI/180);
			headA.space = space;
			var headP:PivotJoint = new PivotJoint(headB, torsoB, new Vec2( 0, 12), new Vec2(0, -14));
			headP.space = space;
			headP.breakUnderForce = true;
			headP.maxForce = 500000;

			//pairs[headP] = headA;
			
			var torsoLeftArmA:AngleJoint = new AngleJoint(torsoB, armUpLeft, 20 * Math.PI/180, 180 * Math.PI/180);
			var torsoLeftArmP:PivotJoint = new PivotJoint(torsoB, armUpLeft, new Vec2( -7.5, -12), new Vec2(1, -5));
			var torsoRightArmA:AngleJoint = new AngleJoint(torsoB, armUpRight, -180 * Math.PI/180, -20 * Math.PI/180);
			var torsoRightArmP:PivotJoint = new PivotJoint(torsoB, armUpRight, new Vec2( 7.5, -12), new Vec2( -1, -5));
			torsoLeftArmP.breakUnderForce = true;
			torsoLeftArmP.maxForce = 500000;
	
			torsoRightArmP.breakUnderForce = true;
			torsoRightArmP.maxForce = 500000;
	
			//pairs[torsoLeftArmP] = torsoLeftArmA;
			//pairs[torsoRightArmP] = torsoRightArmA;
			
			var armsLeftA:AngleJoint = new AngleJoint(armUpLeft, armBottomLeft, -20 * Math.PI/180, 20 * Math.PI/180);
			var armsLeftP:PivotJoint = new PivotJoint(armUpLeft, armBottomLeft, new Vec2( -1, 4), new Vec2(0, -6.5));
			var armsRightA:AngleJoint = new AngleJoint(armUpRight, armBottomRight, -20 * Math.PI/180, 20 * Math.PI/180);
			var armsRightP:PivotJoint = new PivotJoint(armUpRight, armBottomRight, new Vec2( 1, 4), new Vec2(0, -6.5));
			armsLeftP.breakUnderForce = true;
			armsLeftP.maxForce = 500000;
		
			armsRightP.breakUnderForce = true;
			armsRightP.maxForce = 500000;
			
			//pairs[armsLeftP] = armsLeftA;
			//pairs[armsRightP] = armsRightA;
			
			torsoLeftArmA.space = torsoLeftArmP.space = torsoRightArmA.space = torsoRightArmP.space = armsLeftA.space = armsLeftP.space = armsRightA.space = armsRightP.space = space;
			
			var torsoLeftLegA:AngleJoint = new AngleJoint(torsoB, legUpLeft, -30 * Math.PI/180, 30 * Math.PI/180);
			var torsoLeftLegP:PivotJoint = new PivotJoint(torsoB, legUpLeft, new Vec2( -4, 11), new Vec2(0, -4));
			var torsoRightLegA:AngleJoint = new AngleJoint(torsoB, legUpRight, -30 * Math.PI/180, 30 * Math.PI/180);
			var torsoRightLegP:PivotJoint = new PivotJoint(torsoB, legUpRight, new Vec2( 4, 11), new Vec2(0, -4));
			torsoLeftLegP.breakUnderForce = true;
			torsoLeftLegP.maxForce = 1000000;

			torsoRightLegP.breakUnderForce = true;
			torsoRightLegP.maxForce = 1000000;

			//pairs[torsoLeftLegP] = torsoLeftLegA;
			//pairs[torsoRightLegP] = torsoRightLegA;
			
			torsoLeftLegA.space = torsoLeftLegP.space = torsoRightLegA.space = torsoRightLegP.space = space;
			
			var legsLeftA:AngleJoint = new AngleJoint(legUpLeft, legBottomLeft, -20 * Math.PI/180, 20 * Math.PI/180);
			var legsLeftP:PivotJoint = new PivotJoint(legUpLeft, legBottomLeft, new Vec2( -0.4, 4.6), new Vec2(0, -3.4));
			var legsRightA:AngleJoint = new AngleJoint(legUpRight, legBottomRight, -20 * Math.PI/180, 20 * Math.PI/180);
			var legsRightP:PivotJoint = new PivotJoint(legUpRight, legBottomRight, new Vec2( 0.4, 4.6), new Vec2(0, -3.4));
			legsLeftP.breakUnderForce = true;
			legsLeftP.maxForce = 500000;
	
			legsRightP.breakUnderForce = true;
			legsRightP.maxForce = 500000;
	
			//pairs[legsLeftP] = legsLeftA;
			//pairs[legsRightP] = legsRightA;
			
			legsLeftA.space = legsLeftP.space = legsRightA.space = legsRightP.space = space;
			
		}
}

class DummyNapeMain {
    static function main() {
        var c =flash.Lib.current;
        var debug = new BitmapDebug(600,600,0x333333);
        c.addChild(debug.display);

        var space = new Space(new Vec2(0,300));

        var ground = new Body(BodyType.STATIC);
        ground.shapes.add(new Polygon(Polygon.rect(0,550,600,50)));
        ground.space = space;

        var dolls = [];
        dolls.push(new Doll(300,100, space));

        c.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function (_) {
            for(i in dolls) i.activate();
        });

        var txt = new flash.text.TextField();
        c.addChild(txt);

        var tim =  new haxe.Timer(0);
        tim.run = function() {
            space.step(1/60,10,10);

            debug.clear();
            debug.draw(space);
            debug.flush();

            txt.text = Debug.TIMES(space);
        }
    }
}

#elseif false

/*

    Vertex < Edge[2] (actual colliding edges)
           < Bool concave
           < Bool inner (totally inner vertex)
           < Bool internals (connected to internals)

    Modification to SAT:
        max = -inf
        Iter edge p1.edges
            min = inf

            Iter vertex p2.vertices
                pen = vertex dot edge.normal - edge.projection
                if pen < 0
                    if(vertex.concave || vertex.inner) pen = -inf
                    else if(vertex.internals) {
                        var cx0 = cross(edge.normal, vertex.edge0.normal)
                        var cx1 = cross(edge.normal, vertex.edge1.normal)
                        if(cx0<0 || cx1>0) pen = -inf
                    }

            if(min>=0) return false;

            if(min>=max && !edge.inner) {
                max = min;
                emax = edge;
            }

        //same for other polygon

    This needs to be done on the ENTIRE polygon soup(s). not just shape-shape

    Need a way to choose when we can use multiple contact patches for concave intersections.

    Maybe choose minimum, then any in the same general direction.

*/

typedef EVertex = {pos:Vec2, e0:EEdge, e1:EEdge, concave:Bool, inner:Bool, internals:Bool};
typedef EEdge = {normal:Vec2, proj:Float, v0:EVertex, v1:EVertex, inner:Bool};

typedef EPolygon = {vertices:Array<EVertex>, edges:Array<EEdge>};

class DummyNapeMain {

    static inline function vert(x:Float, y:Float):EVertex {
        return {pos:new Vec2(x,y), e0:null, e1:null, concave:false, inner:false, internals:false};
    }
    static inline function edge(v0:EVertex, v1:EVertex, inner:Bool=false):EEdge {
        return {normal:null, proj:0.0, v0:v0, v1:v1, inner:inner};
    }
    static inline function vedges(vert:EVertex, e0:EEdge, e1:EEdge) {
        vert.e0 = e0;
        vert.e1 = e1;
    }

    static inline function poly(edges:Array<EEdge>):EPolygon {
        var verts = [];
        for(e in edges) verts.push(e.v0);
        var ret:EPolygon = {vertices:verts, edges:edges};
        return ret;
    }
    static inline function init_1(poly:EPolygon) {
        for(e in poly.edges) {
            vec_new(n); vec_sub(e.v1.pos.,e.v0.pos., n);
            swap(nx,ny);
            vec_normalise_slow(n);
            ny = -ny;
            e.normal = new Vec2(nx,ny);

            e.proj = vec_dot(e.v0.pos.,e.normal.);
        }
        for(v in poly.vertices) {
            v.internals = false;
            v.inner = true;
        }
    }
    static inline function init_2(poly:EPolygon) {
        for(v in poly.vertices) {
            var dot = vec_cross(v.e0.normal., v.e1.normal.);
            v.concave = dot<0;
        }
        for(e in poly.edges) {
            e.v0.inner = e.v0.inner && e.inner;
            e.v0.internals = e.v0.internals || e.inner;
        }
    }

    static inline function render(poly:EPolygon, dif:Vec2=null) {
        var g = flash.Lib.current.graphics;
        if(dif==null) dif = new Vec2(0,0);

        for(v in poly.vertices) {
            g.lineStyle(0.1,v.inner ? 0xff0000 : v.internals ? 0xff00 : 0xffffff,1);
            g.drawCircle(dif.x+v.pos.x,dif.y+v.pos.y,v.concave?1:3);

            if(!v.concave && v.internals) {
                g.lineStyle(0.1,0xff00,1);
                g.moveTo(dif.x+v.pos.x,dif.y+v.pos.y);
                g.lineTo(dif.x+v.pos.x+v.e0.normal.x*10,dif.y+v.pos.y+v.e0.normal.y*10);
                g.moveTo(dif.x+v.pos.x,dif.y+v.pos.y);
                g.lineTo(dif.x+v.pos.x+v.e1.normal.x*10,dif.y+v.pos.y+v.e1.normal.y*10);

                g.moveTo(dif.x+v.pos.x+v.e0.normal.x*10,dif.y+v.pos.y+v.e0.normal.y*10);
                var ang = Math.acos(vec_dot(v.e0.normal.,v.e1.normal.));
                for(i in 1...20) {
                    var aang = ang/20*i;
                    vec_new(a, Math.sin(aang), Math.cos(aang));
                    vec_new(r); vec_rotate(v.e0.normal., a, r);
                    g.lineTo(dif.x+v.pos.x+rx*10,dif.y+v.pos.y+ry*10);
                }
                g.lineTo(dif.x+v.pos.x+v.e1.normal.x*10,dif.y+v.pos.y+v.e1.normal.y*10);
            }
        }
        for(e in poly.edges) {
            g.lineStyle(0.1,e.inner?0xff0000:0xa0a0a0,1);
            g.moveTo(dif.x+e.v0.pos.x,dif.y+e.v0.pos.y);
            g.lineTo(dif.x+e.v1.pos.x,dif.y+e.v1.pos.y);
        }
    }

    static function main() {
        var c = flash.Lib.current;
        var g = c.graphics;

        var v0 = vert(150,150);
        var v1 = vert(300,200);
        var v2 = vert(450,150);
        var v3 = vert(450,400);
        var v4 = vert(300,450);
        var v5 = vert(150,400);

        var e0 = edge(v0,v1);
        var e1 = edge(v1,v2);
        var e2 = edge(v2,v3);
        var e3 = edge(v3,v4);
        var e4 = edge(v4,v5);
        var e5 = edge(v5,v0);

        var i0a = edge(v1,v4, true);
        var i0b = edge(v4,v1, true);

        var i1a = edge(v0,v4, true);
        var i1b = edge(v4,v0, true);

        var i2a = edge(v1,v3, true);
        var i2b = edge(v3,v1, true);

        vedges(v0, e5,e0);
        vedges(v1, e0,e1);
        vedges(v2, e1,e2);
        vedges(v3, e2,e3);
        vedges(v4, e3,e4);
        vedges(v5, e4,e5);

        var p0 = poly([e0,i0a,i1b]);
        var p1 = poly([i1a,e4,e5]);

        var p2 = poly([e1,e2,i2b]);
        var p3 = poly([i2a,e3,i0b]);

        var polys = [p0,p1,p2,p3];

        //

        var boxo = [new Vec2(-250,-250), new Vec2(250,-250), new Vec2(250,250), new Vec2(-250,250)];
        var boxv = [new Vec2(-250,-250), new Vec2(250,-250), new Vec2(250,250), new Vec2(-250,250)];
        var b0:EVertex = {pos:boxv[0], e0:null, e1:null, concave:false, inner:false, internals:false};
        var b1:EVertex = {pos:boxv[1], e0:null, e1:null, concave:false, inner:false, internals:false};
        var b2:EVertex = {pos:boxv[2], e0:null, e1:null, concave:false, inner:false, internals:false};
        var b3:EVertex = {pos:boxv[3], e0:null, e1:null, concave:false, inner:false, internals:false};

        var be0 = edge(b0,b1);
        var be1 = edge(b1,b2);
        var be2 = edge(b2,b3);
        var be3 = edge(b3,b0);

        vedges(b0,be3,be0);
        vedges(b1,be0,be1);
        vedges(b2,be1,be2);
        vedges(b3,be2,be3);

        var box = poly([be0,be1,be2,be3]);

        //

        var tim = new haxe.Timer(0);
        tim.run = function() {

            g.clear();

            vec_new(a, Math.sin(0.2), Math.cos(0.2));
            vec_new(mp, c.mouseX, c.mouseY);
            for(i in 0...4) {
                vec_new(t); vec_rotate(boxo[i]., a, t);
                //vec_set(boxo[i]., t);
                vec_add(mp, t, boxv[i].);
            }

            init_1(box);
            init_2(box);
            render(box);

            for(p in polys) init_1(p);
            for(p in polys) init_2(p);
            for(p in polys) render(p);

            var collide = function(a:EPolygon, b:EPolygon):{a:EPolygon, b:EPolygon, edge:EEdge, pen:Float, isa:Bool} {
                var max = -PR(Const).FMAX;
                var emax:EEdge = null;
                var isa:Bool = false;

                for(e in a.edges) {
                    var min = PR(Const).FMAX;
                    for(v in b.vertices) {
                        var pen = vec_dot(v.pos., e.normal.) - e.proj;
                        if(pen<0) {
                            var inner = true;
                            for(e in b.edges) {
                                if(e.v0 == v) inner = inner && e.inner;
                                if(e.v1 == v) inner = inner && e.inner;
                            }
                            if(v.concave || inner) pen = -PR(Const).FMAX;
                            else if(v.internals) {
                                var cx0 = vec_cross(v.e0.normal., e.normal.);
                                var cx1 = vec_cross(v.e1.normal., e.normal.);
                                if(cx0>0 || cx1<0) pen = -PR(Const).FMAX;
                            }
                        }
                        if(pen<min) min = pen;
                    }
                    if(min>=0) return null;
z
                    if(min>max && !e.inner) {
                        emax = e;
                        isa = true;
                        max = min;
                    }
                }

                for(e in b.edges) {
                    var min = PR(Const).FMAX;
                    for(v in a.vertices) {
                        var pen = vec_dot(v.pos., e.normal.) - e.proj;
                        if(pen<0) {
                            var inner = true;
                            for(e in a.edges) {
                                if(e.v0 == v) inner = inner && e.inner;
                                if(e.v1 == v) inner = inner && e.inner;
                            }
                            if(v.concave || inner) pen = -PR(Const).FMAX;
                            else if(v.internals) {
                                var cx0 = vec_cross(v.e0.normal., e.normal.);
                                var cx1 = vec_cross(v.e1.normal., e.normal.);
                                //include dot <= 0 for both too ?
                                if(cx0>=0 || cx1<=0) pen = -PR(Const).FMAX;
                            }
                        }
                        if(pen<min) min = pen;
                    }
                    if(min>=0) return null;

                    if(min>max && !e.inner) {
                        emax = e;
                        isa = false;
                        max = min;
                    }
                }

                return {a:a, b:b, edge:emax,pen:max,isa:isa};
            };

            var ress = [];

            var max = -PR(Const).FMAX;
            var maxr:{a:EPolygon, b:EPolygon, edge:EEdge, pen:Float, isa:Bool} = null;
            var cnt = 2;
            for(p in polys) {
                var px = collide(p,box);
                if(px!=null) ress.push(px);

                var cont = false;
                if(px!=null) {

                    cont = px.pen > max;
                    if(!cont && px.pen==max) {
                        //if(!px.edge.inner && maxr.edge.inner) cont = true;
                        var cnt2 = px.edge.inner ? 1 : 0;
                        var ay:EEdge = null;
                        var min = PR(Const).FMAX;
                        for(axis in (px.isa ? px.b : px.a).edges) {
                            var k = vec_dot(px.edge.normal.,axis.normal.);
                            if(k<min) {
                                min = k;
                                ay = axis;
                            }
                        }
                        cnt2 += ay.inner ? 1 : 0;

                        cont = cnt2 < cnt;
                    }
                }
                if(cont) {
                    max = px.pen;
                    maxr = px;

                    cnt = px.edge.inner ? 1 : 0;
                    var ay:EEdge = null;
                    var min = PR(Const).FMAX;
                    for(axis in (px.isa ? px.b : px.a).edges) {
                        var k = vec_dot(px.edge.normal.,axis.normal.);
                        if(k<min) {
                            min = k;
                            ay = axis;
                        }
                    }
                    cnt += ay.inner ? 1 : 0;
                }
            }

            var midp = function(xs:EPolygon) {
                g.lineStyle(1,0xffffff,1);
                var x = 0.0;
                var y = 0.0;
                for(v in xs.vertices) {
                    x += v.pos.x;
                    y += v.pos.y;
                }
                x /= xs.vertices.length;
                y /= xs.vertices.length;
                g.drawCircle(x,y,3);
            }

            if(maxr!=null) {
            for(px in ress) {
            if(px==maxr || ((vec_dot(px.edge.normal., maxr.edge.normal.) > 0.0)
            && ({
                var share = (px.edge.v0 == maxr.edge.v0) ? px.edge.v0
                          : (px.edge.v1 == maxr.edge.v0) ? px.edge.v1
                          : (px.edge.v0 == maxr.edge.v1) ? px.edge.v0
                          : (px.edge.v1 == maxr.edge.v1) ? px.edge.v1
                          : null;
                (share == null ? false : true) || (px.edge==maxr.edge);
            })
            )){
                var dist = px.isa ? -px.pen : px.pen;

                g.lineStyle(2,0xff00,1);
                g.moveTo(px.edge.v0.pos.x,px.edge.v0.pos.y);
                g.lineTo(px.edge.v1.pos.x,px.edge.v1.pos.y);

                var ax = px.edge;
                g.moveTo(0.5*(px.edge.v0.pos.x+px.edge.v1.pos.x),0.5*(px.edge.v0.pos.y+px.edge.v1.pos.y));
                g.lineTo(0.5*(px.edge.v0.pos.x+px.edge.v1.pos.x)+10*ax.normal.x,0.5*(px.edge.v0.pos.y+px.edge.v1.pos.y)+10*ax.normal.y);

                midp(px.a);
                midp(px.b);

                //render(box, px.edge.normal.mul(dist));

                $(mixin find(p1,p2) {
                    //incident edge on p2
                    var ay:EEdge = null;
                    var min = PR(Const).FMAX;
                    for(axis in p2.edges) {
                        var k = vec_dot(ax.normal.,axis.normal.);
                        if(k<min) {
                            min = k;
                            ay = axis;
                        }
                    }

                    vec_new(c0); vec_set(c0,ay.v0.pos.);
                    vec_new(c1); vec_set(c1,ay.v1.pos.);

                    g.lineStyle(2,0xff,1);
                    g.moveTo(c0x,c0y);
                    g.lineTo(c1x,c1y);

                    vec_new(dv); vec_sub(c1,c0,dv);
                    var d0 = vec_cross(c0,ax.normal.);
                    var d1 = vec_cross(c1,ax.normal.);
                    var den = 1/(d1-d0);

                    //clip c0
                    var t0 = (-vec_cross(ax.normal.,ax.v1.pos.) - d0)*den;
                    if(t0>PR(Const).EPSILON) vec_addeq(c0,dv,t0);
                    //clip c1
                    var t1 = (-vec_cross(ax.normal.,ax.v0.pos.) - d1)*den;
                    if(t1<-PR(Const).EPSILON) vec_addeq(c1,dv,t1);

                    vec_new(n); vec_mul(ax.normal.,px.isa?-1:1,n);
                    //position iterations

                    if(t0 <= 1 && vec_dot(c0,ax.normal.) <= ax.proj) {
                        g.lineStyle(2,0xff00ff,1);
                        g.drawCircle(c0x,c0y,4);
                        g.moveTo(c0x,c0y);
                        g.lineTo(c0x-nx*10,c0y-ny*10);
                        //var con = if(rev) arb.injectContact(c0x,c0y,-nx,-ny,dist,arb.rev ? 1 : 0)
                                  //else    arb.injectContact(c0x,c0y, nx, ny,dist,arb.rev ? 1 : 0);
                        //position iterations
                        //vec_subeq(c0,p2.body.pos);
                        //vec_revrot(c0,p2.body.axis,con.inner.lr1);
                    }
                    if(t1 >= -1 && vec_dot(c1,ax.normal.) <= ax.proj) {
                        g.lineStyle(2,0xff00ff,1);
                        g.drawCircle(c1x,c1y,4);
                        g.moveTo(c1x,c1y);
                        g.lineTo(c1x-nx*10,c1y-ny*10);
                        //var con = if(rev) arb.injectContact(c1x,c1y,-nx,-ny,dist,arb.rev ? 0 : 1);
                                  //else    arb.injectContact(c1x,c1y, nx, ny,dist,arb.rev ? 0 : 1);
                        //position iterations
                        //vec_subeq(c1,p2.body.pos);
                        //vec_revrot(c1,p2.body.axis,con.inner.lr1);
                    }

                });
                if(px.isa) find(px.a,px.b);
                else       find(px.b,px.a);
            }}}

        }
    }

}

#elseif true

class DummyNapeMain {

    static function main() {
        var c = flash.Lib.current;
        haxe.Log.setColor(0xffffff);

        var space = new Space(new Vec2(0,300));

        var walls = new Body(BodyType.STATIC);
        walls.shapes.add(new Polygon(Polygon.rect(0,0,50,600)));
        walls.shapes.add(new Polygon(Polygon.rect(600,0,-50,600)));
        walls.shapes.add(new Polygon(Polygon.rect(0,0,600,50)));
        walls.shapes.add(new Polygon(Polygon.rect(0,600,600,-50)));
        /*var vat:Shape;
        walls.shapes.add(vat = new Polygon(Polygon.rect(0,600,600,-200)));
        vat.fluidEnabled = true;
        vat.fluidProperties.density = 3;*/
        walls.space = space;

        //for(shape in walls.shapes) shape.material.elasticity = 10000;
        for(y in 0...20) {
            var pre:Body = null;
            for(x in 0...20) {
                var box = new Body();
                box.shapes.add(new Circle(7));
                box.position.setxy(100+x*15,100+y*15);
                box.space = space;

                if(pre!=null) {
                    var mid = pre.position.add(box.position).mul(0.5);
                    //var piv =
                    var piv:Constraint = null;
                    if((y%4)==0) piv = new LineJoint(pre,box, pre.worldToLocal(mid), box.worldToLocal(mid), new Vec2(0,1), -10,10);
                    if((y%4)==1) piv = new WeldJoint(pre,box, pre.worldToLocal(mid), box.worldToLocal(mid));
                    if((y%4)==2) piv = new PivotJoint(pre,box, pre.worldToLocal(mid), box.worldToLocal(mid));
                    if((y%4)==3) piv = new DistanceJoint(pre,box, pre.worldToLocal(mid), box.worldToLocal(mid), 0.5, 2.5);
                    //piv.space = space;
                    //piv.stiff = false;
                }
                pre = box;
                box.type = BodyType.STATIC;
            }
        }

        var debug = new BitmapDebug(600,600,0x333333);
        //var debug = new ShapeDebug(0x333333);
        //debug.drawShapeDetail = true;
        //debug.drawBodyDetail = true;
        //debug.drawShapeAngleIndicators = false;
        //debug.drawCollisionArbiters = true;
        //debug.drawFluidArbiters = true;
        debug.drawConstraints = true;
        c.addChild(debug.display);

        var mcon = new PivotJoint(space.world,space.world, new Vec2(), new Vec2());
        mcon.stiff = false;
        //mcon.maxForce = 8000;
        mcon.space = space;
        mcon.active = false;

		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
            var mp = new Vec2(c.mouseX,c.mouseY);
			var objs = space.bodiesUnderPoint(mp);
            for(obj in objs) {
                var b = obj;
                if(b.isDynamic()) {
                   /* mcon.body2 = obj;
                    mcon.anchor2 = obj.worldToLocal(mp);
                    mcon.active = true;
                    break;*/
                }else
                    b.type = BodyType.DYNAMIC;

                b.applyLocalImpulse(new Vec2(1000,0), new Vec2());
            }
		});
        c.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function(_) {
           mcon.active = false;
        });

        var tim = new haxe.Timer(0);
        tim.run = function() {
            mcon.anchor1.setxy(c.mouseX,c.mouseY);

            space.step(1/120,10,10);
            space.step(1/120,10,10);

            //debug.bgColor = Std.int(0xffffff*Math.random());
            debug.clear();
/*
            var cols = [0xff0000, 0x80ff00, 0xffff, 0x8000ff];

            for(j in 0...10) {
                var a = Math.random()*Math.PI*2;
                var ray = new Ray(new Vec2(Math.random()*700-50,Math.random()*700-50), new Vec2(Math.cos(a),Math.sin(a)));

                for(i in 0...25) {
                    var res = space.rayCast(ray);
                    if(res==null) break;

                    var cc = 0x0;

                    debug.drawLine(ray.origin, ray.at(res.distance), cc);
                    var body = res.shape.body;

                    ray.origin = ray.at(res.distance);

                    cc = 0x555555;
                    //debug.drawCircle(ray.origin, 1, cc);
                    var dot = ray.direction.x*res.normal.x + ray.direction.y*res.normal.y;
                    ray.direction.x -= 2*dot*res.normal.x;
                    ray.direction.y -= 2*dot*res.normal.y;
                }
            }
*/
            debug.draw(space);

            debug.flush();
        }
    }

	static function mains() {
        var c = flash.Lib.current;
        haxe.Log.setColor(0xffffff);
       /* c.addChild(new flash.display.Bitmap(bit));
        bytes.length = 600*600*4;
        bytes0.length = 600*600*4;
        for(i in 0...600*600*4) bytes0.writeByte(0);
        bytes.endian = flash.utils.Endian.LITTLE_ENDIAN;
        bytes0.endian = flash.utils.Endian.LITTLE_ENDIAN;
        flash.Memory.select(bytes);*/

		var space = new Space(new Vec2(0,400));
		var debug = new BitmapDebug(600,600,0x333333);
       // c.addChild(debug);
		//debug.drawCollisionArbiters = true;
        //debug.drawBodies = false;
		//debug.drawConstraints = true;

		/*for(i in 0...20) {
            var pre:Body = null;
        for(j in 0...20) {
			var box = new Body();
			box.position.setxy(40+j*11,580-7-i*14);
            if((i+j)%2==0)
                box.shapes.add(new Polygon(Polygon.box(10,14)));
            else
                box.shapes.add(new Circle(7));
            //box.shapes.add(new Polygon(Polygon.regular(16,16,Std.int(3+Math.random()*3))));
			box.space = space;
            //box.setShapeMaterials(new Material(10));
            box.angularVel = 4;
            //box.allowRotation = false;

            if(pre!=null) {
                //var con = new PivotJoint(pre,box,new Vec2(7.5,0), new Vec2(-7.5,0));
                var con = new DistanceJoint(pre,box, new Vec2(), new Vec2(), 15,15);
                //con.space = space;
                con.stiff = false;
            }
            pre = box;
		}
        }*/
        /*var N = 20;
        var w = 4;
        var h = 16;
        for(y in 0...N) {
            var cnt = y+1;
            for(x in 0...cnt) {
                var box = new Body();
                box.position.x = 300+(x-(cnt-1)/2)*h;
                box.position.y = 580-w/2 - (N-1-y)*(h+2*w);
                box.shapes.add(new Polygon(Polygon.box(h+0.5,w+0.5)));
                box.space = space;

                var box = new Body();
                box.position.x = 300+(x-(cnt-1)/2)*h;
                box.position.y = 580-w/2 - (N-1-y)*(h+2*w)-h-w;
                box.shapes.add(new Polygon(Polygon.box(h+0.5,w+0.5)));
                box.space = space;

                var box = new Body();
                box.position.x = 300+(x-(cnt-1)/2)*h;
                box.position.y = 580-h/2 - (N-1-y)*(h+2*w)-w;
                box.shapes.add(new Polygon(Polygon.box(w+0.5,h+0.5)));
                box.space = space;
            }
        }*/
        var N = 40;
        var M = 8;
        var w = 8;
        var h = 8;
        for(y in 0...N) {
            var cnt = (y%2==0) ? M : M-1;
            var cnt = y+1;
            var pre = null;
            for(x in 0...cnt) {
                var box = new Body(BodyType.DYNAMIC, new Vec2(300+(x-(cnt-1)/2)*w, 580-h/2-(N-1-y)*h));
                //box.shapes.add(new Polygon(Polygon.box(w+0.5,h+0.5)));
                if((x+y)%2==0)
                    box.shapes.add(new Polygon(Polygon.box(w-0.5,h-0.5)));
                else
                    box.shapes.add(new Circle(w<h?(w-0.5)/2:(h-0.5)/2));
                box.space = space;

                if(pre!=null) {
                    //var con = new PivotJoint(pre,box,new Vec2(w/2,0), new Vec2(-w/2,0));
                    //var con = new DistanceJoint(pre,box, new Vec2(w/2,0), new Vec2(-w/2,0), 5,5);
                    //con.space = space;
                    //con.frequency *= 2;
                    //con.stiff = false;
                }
                pre = box;
            }
        }
       /* var r = 65;
        var R = 2;
        for(x in 0...r) {
            for(y in 0...r) {
                var dix = x-r/2;
                var diy = y-r/2;
                if(dix*dix+diy*diy<=r*r*0.25) {
                    var circ = new Body(BodyType.DYNAMIC, new Vec2(300+dix*R*2,300+diy*R*2));
                    circ.shapes.add(new Circle(R,null,new Material(0,0.01,0.015,1,0.00001)));
                    circ.space = space;
                }
            }
        }*/
		
		var floor = new Body(BodyType.STATIC);
		floor.shapes.add(new Polygon(Polygon.rect(0,600,600,-20)));
        floor.shapes.add(new Polygon(Polygon.rect(0,0,600,20)));
        floor.shapes.add(new Polygon(Polygon.rect(0,0,20,600)));
        floor.shapes.add(new Polygon(Polygon.rect(600,0,-20,600)));
        /*var N = 40;
        var r1 = 250;
        var r2 = 350;
        for(i in 0...N) {
            var a0 = Math.PI*2/N*(i-0.25);
            var a1 = Math.PI*2/N*(i+1.25);
            floor.shapes.add(new Polygon([
                new Vec2(300+Math.cos(a0)*r1, 300+Math.sin(a0)*r1),
                new Vec2(300+Math.cos(a0)*r2, 300+Math.sin(a0)*r2),
                new Vec2(300+Math.cos(a1)*r2, 300+Math.sin(a1)*r2),
                new Vec2(300+Math.cos(a1)*r1, 300+Math.sin(a1)*r1)
            ]));
        }*/
		floor.space = space;
		
		var mcon = new PivotJoint(space.world,space.world, new Vec2(), new Vec2());
        mcon.stiff = false;
        //mcon.maxForce = 8000;
        mcon.breakUnderForce = true;
        mcon.removeOnBreak = false;
        mcon.space = space;
        mcon.active = false;

        //for(body in space.bodies) c.addChild(body.graphic = Debug.createGraphic(body));
		
        var txt = new flash.text.TextField();
        txt.x = 20;
        txt.defaultTextFormat = new flash.text.TextFormat(null,null,0xffffff);
        c.addChild(txt);

        /*var e_wake  = new BodyListener(CbEvent.WAKE, CbType.DEFAULT, function(b:Body) {
            b.graphic.alpha = 1.0;
            b.graphic.cacheAsBitmap = false;
        });
        var e_sleep = new BodyListener(CbEvent.SLEEP,CbType.DEFAULT, function(b:Body) {
            b.graphic.alpha = 0.5;
            b.graphic.cacheAsBitmap = true;
        });
        e_wake.space = space;
        e_sleep.space = space;*/

        var e_wake = new ConstraintListener(CbEvent.WAKE, CbType.DEFAULT, function (c:Constraint) {
        });
        e_wake.space = space;
        var e_sleep = new ConstraintListener(CbEvent.SLEEP, CbType.DEFAULT, function (c:Constraint) {
        });
        e_sleep.space = space;

        var e_break = new ConstraintListener(CbEvent.BREAK, CbType.DEFAULT, function (c:Constraint) {
            if(c.removeOnBreak) {
                //if constraint has been removed as a result of break, re-add and disable it.
                c.active = false;
                c.space = space;
            }
        });
        e_break.space = space;

        var pt = flash.Lib.getTimer();
        txt.width = 600;
        txt.height = 600;
        txt.selectable = false;

        debug.drawShapeAngleIndicators = false;
        debug.drawConstraints = true;
        c.stage.quality = flash.display.StageQuality.LOW;

        var cnt = 0;

        /*var tilde = new Body(BodyType.KINEMATIC, new Vec2(300,300));
        tilde.shapes.add(new Polygon(Polygon.box(440,10)));
        tilde.shapes.add(new Polygon(Polygon.box(10,440)));
        tilde.type = BodyType.DYNAMIC;
        tilde.rotation = Math.PI/4;
        tilde.space = space;

        var piv = new PivotJoint(space.world,tilde, new Vec2(300,300), new Vec2());
        piv.space = space;*/

		c.stage.addEventListener(flash.events.MouseEvent.MOUSE_DOWN, function(_) {
            var mp = new Vec2(c.mouseX,c.mouseY);
			var objs = space.bodiesUnderPoint(mp);
            for(obj in objs) {
                var b = obj.pr(inner);

                mcon.body2 = obj;
                mcon.anchor2 = obj.worldToLocal(mp);
                mcon.active = true;
                break;
            }
                /*
            var g = space.gravity;
            if(g.y>0) { g.x = g.y; g.y = 0; }
            else if(g.x>0) { g.y = -g.x; g.x = 0; }
            else if(g.y<0) { g.x = g.y; g.y = 0; }
            else { g.y = -g.x; g.x = 0; }*/
		});
        c.stage.addEventListener(flash.events.MouseEvent.MOUSE_UP, function(_) {
           mcon.active = false;
        });

        var sdebug = new Debug();
       // sdebug.drawCollisionArbiters = true;

		var tim = new haxe.Timer(0);
        tim.run = function() {
            /*if(cnt<Std.int(170*5/4)) {
                for(i in 0...4) {
                    var circ = new Body(BodyType.DYNAMIC, new Vec2(540+Math.random()*5,300-i*3));
                    circ.shapes.add(new Circle(2.5,null,new Material(0,0,0,1,0)));
                    //circ.shapes.add(new Polygon(Polygon.box(5,5),new Material(0,0,0,1,0)));
                    circ.space = space;
                    //circ.allowRotation = false;

                    var circ = new Body(BodyType.DYNAMIC, new Vec2(60+Math.random()*5,300-i*3));
                    circ.shapes.add(new Circle(2.5,null,new Material(0,0,0,1,0)));
                    //circ.shapes.add(new Polygon(Polygon.box(5,5),new Material(0,0,0,1,0)));
                    circ.space = space;
                    //circ.allowRotation = false;

                }
            }
            cnt++;*/

            var ct = flash.Lib.getTimer();
            var dt = (ct-pt)/1000;
            txt.text = "fps: "+Std.string(1/dt).substr(0,5);
            pt = ct;

            mcon.anchor1.setxy(c.mouseX,c.mouseY);

            if(space.liveBodies.empty()) {
                //txt.text = ""+space.zpp_inner.stamp;
            }else {
                if(dt>1/30) dt = 1/30;
                space.step(1/60,8,8);

                var pt = flash.Lib.getTimer();
                /*debug.clear();
                debug.draw(space);
                debug.flush();*/
                c.graphics.clear();
                //sdebug.draw(c.graphics,space);
                #if NAPE_TIMES Debug.DRAW += flash.Lib.getTimer()-pt; #end
                /*while(!space.callbacks.empty()) {
                    var cb = space.callbacks.pop();
                    if(cb.listener == e_wake) cb.body.graphic.alpha = 1.0;
                    else                      cb.body.graphic.alpha = 0.5;
                }*/
            }
            #if NAPE_TIMES
                txt.text += "\n\n";
                txt.text += "FOR:  "+Std.string(Debug.FOR/space.timeStamp).substr(0,5)+"ms"+"\n";
                txt.text += "COL:  "+Std.string(Debug.BROAD/space.timeStamp).substr(0,5)+"ms"+"\n";
                txt.text += "PRE:  "+Std.string(Debug.PRE/space.timeStamp).substr(0,5)+"ms"+"\n";
                txt.text += "POS:  "+Std.string(Debug.POS/space.timeStamp).substr(0,5)+"ms"+"\n";
                txt.text += "VEL:  "+Std.string(Debug.VEL/space.timeStamp).substr(0,5)+"ms"+"\n";
                txt.text += "DRAW: "+Std.string(Debug.DRAW/space.timeStamp).substr(0,5)+"ms"+"\n";
                txt.text += "\n\n";
                txt.text += "arb: "+Debug.ACNT+"\n";
                txt.text += "aarb: "+Debug.AACNT+"\n";
                txt.text += "con: "+Debug.CCNT+"\n";
                txt.text += "acon: "+Debug.ACCNT+"\n";
            #end
            //render(c.graphics,space);
		}
	}
}
#end
