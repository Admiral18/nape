package nape.phys;
$(import);

WrapList(Group,List(PR(Group)),Node(PR(Group)),$(mixin closure(x) x.outer) $(mixin erusolc(x) x.pr(inner)))

//--------------------------------------------------------------------------------------------------

class Group {
	public var pr(inner):PR(Group);

	property(id,Int,pr(inner).id)

	property(group,Group,{
		if(pr(inner).group==null) null else pr(inner).group.outer;
	},{
		DEBUG(if(group==this) throw "Error: Cannot assign Group to itself";)
		if(this.group!=group) {
			if(pr(inner).group!=null) pr(inner).group.outer.groups.remove(this);
			if(group!=null) group.groups.add(this);
			else pr(inner).group = null;
		}
	})

	property(ignore,Bool,pr(inner).ignore,{
		if(this.ignore!=ignore) {
			pr(inner).invalidate(true);
			pr(inner).ignore = ignore;
		}
	})
	property(virtual,Bool,pr(inner).virtual,{
		if(this.virtual!=virtual) {
			pr(inner).invalidate(true);
			pr(inner).virtual = virtual;
		}
	})

	property(bodies,BodyList,{
		if(pr(inner).wrap_bodies==null) pr(inner).setup_bodies();
		pr(inner).wrap_bodies;
	})
	property(constraints,ConstraintList,{
		if(pr(inner).wrap_constraints==null) pr(inner).setup_constraints();
		pr(inner).wrap_constraints;
	})
	property(groups,GroupList,{
		if(pr(inner).wrap_groups==null) pr(inner).setup_groups();
		pr(inner).wrap_groups;
	})

	public function new(?ignore=false,?virtual=false) {
		pr(inner) = new PR(Group)();
		pr(inner).outer = this;
		this.ignore = ignore;
		this.virtual = virtual;
	}

	public function toString() {
		var ret = "Group#"+id;
		if(virtual)  ret += ":virtual";
		elif(ignore) ret += ":ignore";
		return ret;
	}

	public function clear() {
		bodies.clear();
		constraints.clear();
		groups.clear();
	}

	public function addToSpace(space:Space) {
		Iter(b,pr(inner).bodies,b.outer.space = space);
		Iter(c,pr(inner).constraints,c.outer.space = space);
		Iter(g,pr(inner).groups,g.outer.addToSpace(space));
	}
	public inline function removeFromSpace() addToSpace(null)
}
