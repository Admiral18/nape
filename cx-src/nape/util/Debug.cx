package nape.util;

$(import);

class Debug {
    public static function version() {
        return "Milestone 5.3 7/08/11 - \"r10\" build 10:48 22/08/11";
    }

	public static function clearObjectPools() {
		$(expand global CLEARPOOL(T) {
			while(T.pr(pool)!=null) {
				var nxt = T.pr(pool).next;
				T.pr(pool).next = null;
				T.pr(pool) = nxt;
			}
			#if NAPE_POOL_STATS
			    T.POOL_TOT = T.POOL_CNT = T.POOL_ADDNEW = T.POOL_ADD = T.POOL_SUB = 0;
			#end
		});
		$(expand global PUBCLEARPOOL(T) {
			while(PR(PubPool).pool`T!=null) {
				var nxt = PR(PubPool).pool`T.pr(pool);
				PR(PubPool).pool`T.pr(pool) = null;
				PR(PubPool).pool`T = nxt;
			}
			#if NAPE_POOL_STATS
			    T.POOL_TOT = T.POOL_CNT = T.POOL_ADDNEW = T.POOL_ADD = T.POOL_SUB = 0;
			#end
		});
	}

    #if NAPE_TIMES
		static public var ltime = 0;
        static public function TIMES(space:Space) {
            var text = "";
			var dt = space.timeStamp - ltime;
            text += "Set-Forest:    "+Std.string(Debug.FOR/dt).substr(0,5)+"ms"+"\n";
            text += "Collision:     "+Std.string(Debug.BROAD/dt).substr(0,5)+"ms"+"\n";
            text += "Prestep:       "+Std.string(Debug.PRE/dt).substr(0,5)+"ms"+"\n";
            text += "Position It.:  "+Std.string(Debug.POS/dt).substr(0,5)+"ms"+"\n";
            text += "Velocity It.:  "+Std.string(Debug.VEL/dt).substr(0,5)+"ms"+"\n";
            text += "Debug Draw:    "+Std.string(Debug.DRAW/dt).substr(0,5)+"ms"+"\n";
            text += "\n";
            text += "arb:        "+Debug.ACNT+"\n";
            text += "active arb: "+Debug.AACNT+"\n";
            text += "con:        "+Debug.CCNT+"\n";
            text += "active con: "+Debug.ACCNT+"\n";
			text += "\n";
			text += "hash collisions: "+Std.string(Debug.HASH/Debug.HASHT*100).substr(0,5)+"%\n";

			if(space.timeStamp-ltime > 50) {
				Debug.FOR = Debug.BROAD = Debug.PRE = Debug.POS = Debug.VEL = Debug.DRAW = 0;
				ltime = space.timeStamp;
			}

            return text;
        }

        static public var ACNT = 0;
        static public var AACNT = 0;
        static public var CCNT = 0;
        static public var ACCNT = 0;

        static public var FOR = 0;
        static public var PRE = 0;
        static public var VEL = 0;
        static public var POS = 0;
        static public var BROAD = 0;
        static public var DRAW = 0;

		static public var HASH = 0;
		static public var HASHT = 0;
    #end

    ///---------------------------------------------------------------------------------------------

    #if (flash9||nme)

    keep public static function createGraphic(body:Body):flash.display.Shape {
		DEBUG(if(body==null) throw "Error: Cannot create debug graphic for null Body";)
		var ret = new flash.display.Shape();
		var graphics = ret.graphics;

        var idc:Int = fastint(0xffffff*Math.exp(-body.id/1500));
        var _r = (((idc&0xff0000)>>16))*0.7;
        var _g = (((idc&0xff00)>>8))*0.7;
        var _b = (idc&0xff)*0.7;
	
        var col = ((fastint(_r))<<16)|((fastint(_g))<<8)|(fastint(_b));
        graphics.lineStyle(0.1,col,1);

		for(s in body.shapes) {
			if(s.isCircle()) graphics.drawCircle(s.circle.localCOM.x,s.circle.localCOM.y,s.circle.radius);
			else {
				graphics.moveTo(s.localCOM.x,s.localCOM.y);
				for(i in 0...s.polygon.worldVerts.length) {
					var p = s.polygon.localVerts.at(i);
					graphics.lineTo(p.x,p.y);
				}
				var p = s.polygon.localVerts.at(0);
				graphics.lineTo(p.x,p.y);
			}

			if(s.isCircle()) {
				var c = s.circle;
				graphics.moveTo(c.localCOM.x+c.radius*0.3,c.localCOM.y);
				graphics.lineTo(c.localCOM.x+c.radius,c.localCOM.y);
			}
		}
			
		return ret;
    }

    ///---------------------------------------------------------------------------------------------

	public var pr(inner):PR(Debug);

    public var drawCollisionArbiters:Bool;
	public var drawFluidArbiters:Bool;
	public var drawSensorArbiters:Bool;
	
	public var drawBodies:Bool;
	public var drawBodyDetail:Bool; //requires drawBodies
	public var drawShapeDetail:Bool; //requires drawBodies
	public var drawShapeAngleIndicators:Bool; //requires drawBodies

	public var drawConstraints:Bool;
	public var drawConstraintSprings:Bool; //requires drawConstraints=true
	public var drawConstraintErrors:Bool; //requires drawconstraints=true

    property(bgColor,Int,{
		pr(inner).bg_col;
    },{
		#if flash10
			if(pr(inner).isbmp) pr(inner).d_bmp.setbg(bgColor);
			else                pr(inner).d_shape.setbg(bgColor);
		#else
			pr(inner).d_shape.setbg(bgColor);
		#end
    })

    ///---------------------------------------------------------------------------------------------

	public function new() {
        DEBUG(
            if(!PR(Debug).internal)
                throw "Error: Cannot instantiate Debug derp!";
        )

		drawCollisionArbiters = false;
		drawFluidArbiters = false;
		drawSensorArbiters = false;
		drawBodies = true;
        drawShapeAngleIndicators = true;
		drawBodyDetail = false;
		drawShapeDetail = false;
		drawConstraints = false;
		drawConstraintSprings = true;
		drawConstraintErrors = false;

		cullingEnabled = false;
	}

    ///---------------------------------------------------------------------------------------------

    property(display, flash.display.DisplayObject, {
		#if flash10
			var ret:flash.display.DisplayObject;
			if(pr(inner).isbmp) ret = pr(inner).d_bmp.bitmap;
			else                ret = pr(inner).d_shape.shape;
			ret;
		#else
			pr(inner).d_shape.shape;
		#end
    })

	public var cullingEnabled:Bool;

    ///---------------------------------------------------------------------------------------------

	property(transform, Mat23, {
		if(pr(inner).xform==null) pr(inner).setform();
		pr(inner).xform.outer;
	}, {
		DEBUG(if(transform==null) throw "Error: Cannot set Debug::transform to null";)
		this.transform.set(transform);
	})

    public function clear():Void {}
    public function flush():Void {}

    ///---------------------------------------------------------------------------------------------

    public function draw(object:Dynamic):Void {}

    public function drawLine  (start:Vec2, end:Vec2, colour:Int):Void {}
    public function drawCircle(position:Vec2, radius:Float, colour:Int):Void {}
    public function drawAABB  (aabb:AABB, colour:Int):Void {}
    
    public function drawFilledTriangle(p0:Vec2, p1:Vec2, p2:Vec2, colour:Int):Void {}
    public function drawFilledCircle(position:Vec2, radius:Float, colour:Int):Void {}

	public function drawPolygon (poly:Array<Vec2>, colour:Int):Void {}

	//this method is generally not as effecient as could be with the container casts to arrays etc!
	public function drawFilledPolygon (poly:Array<Vec2>, colour:Int) {
		DEBUG(if(poly==null) throw "Error: Cannot render null polygon";)
		if(poly.length<3) drawPolygon(poly,colour);
		else {
			$(mixin render(gp) {
				var p = gp.toArray(); //<-- evil
				for(i in 1...p.length-1)
					drawFilledTriangle(p[0],p[i],p[i+1],colour);
			});

			var gpoly = new GeomPoly(poly);
			if(!gpoly.isSimple()) {
				drawPolygon(poly,colour);
			}else {
				if(gpoly.isConvex()) {
					render(gpoly);
				}else {
					//replace this with triangularisation would be better.
					//but no such util exists yet.
					var polys = gpoly.convex_decomposition();
					for(p in polys) render(p);

					var polys = gpoly.monotone_decomposition();
					for(p in polys) drawPolygon(p.toArray(),0xff00);
				}
			}
		}
	}

    #end
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

$(mixin __draw(obj) {
	DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

	if(pr(inner).xnull) {
	    if  (Std.is(obj,Space))      pr(inner_zn).draw_space(cast(obj,Space     ).pr(inner), null,1.0,true);
	    elif(Std.is(obj,Body ))      pr(inner_zn).draw_body (cast(obj,Body      ).pr(inner), null,1.0,true);
	    elif(Std.is(obj,Shape))      pr(inner_zn).draw_shape(cast(obj,Shape     ).pr(inner), null,1.0,true);
	    elif(Std.is(obj,Constraint)) pr(inner_zn).draw_con  (cast(obj,Constraint).pr(inner), null,1.0,true);
	    DEBUG(else throw "Error: Unhandled object type for Debug draw";)
	}else {
	    if  (Std.is(obj,Space))      pr(inner_zn).draw_space(cast(obj,Space     ).pr(inner), pr(inner).xform,pr(inner).xdet,false);
	    elif(Std.is(obj,Body ))      pr(inner_zn).draw_body (cast(obj,Body      ).pr(inner), pr(inner).xform,pr(inner).xdet,false);
	    elif(Std.is(obj,Shape))      pr(inner_zn).draw_shape(cast(obj,Shape     ).pr(inner), pr(inner).xform,pr(inner).xdet,false);
	    elif(Std.is(obj,Constraint)) pr(inner_zn).draw_con  (cast(obj,Constraint).pr(inner), pr(inner).xform,pr(inner).xdet,false);
	    DEBUG(else throw "Error: Unhandled object type for Debug draw";)
	}

});

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

#if (flash9||nme)

class ShapeDebug extends Debug {
    public var pr(inner_zn):PR(ShapeDebug);

    public function new(width:Int,height:Int,bgColor=0x333333) {
        DEBUG(if(width <=0) throw "Error: Debug width must be > 0";)
        DEBUG(if(height<=0) throw "Error: Debug height must be > 0";)

        DEBUG(PR(Debug).internal = true;)
        super();
        DEBUG(PR(Debug).internal = false;)

        pr(inner_zn) = new PR(ShapeDebug)(width,height);
        pr(inner_zn).outer_zn = this;
		pr(inner) = pr(inner_zn);
		pr(inner).outer = this;

        this.bgColor = bgColor;
    }

    ///---------------------------------------------------------------------------------------------

    public override function clear() pr(inner_zn).graphics.clear()

    ///---------------------------------------------------------------------------------------------

    public override function drawLine(start:Vec2, end:Vec2, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Disposed(start,Vec2);
		Disposed(end,Vec2);
        DEBUG(
            if(start==null) throw "Error: drawLine::start cannot be null";
            if(end  ==null) throw "Error: drawLine::end cannot be null";
        )
        var g = pr(inner_zn).graphics;

        g.lineStyle(0.1,colour&0xffffff,1);
		if(pr(inner).xnull) {
	        g.moveTo(start.x,start.y);
	        g.lineTo(end.x,end.y);
		}else {
			var v = pr(inner).xform.outer.transform(start);
			g.moveTo(v.x,v.y); v.dispose();
			v = pr(inner).xform.outer.transform(end);
			g.lineTo(v.x,v.y); v.dispose();
		}
    }

    public override function drawCircle(position:Vec2, radius:Float, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Disposed(position,Vec2);
        DEBUG(
            if(position==null) throw "Error: drawCircle::position cannot be null";
            if(isNaN(radius) || radius<0) throw "Error: drawCircle::radius must be >=0";
        )
        var g = pr(inner_zn).graphics;

        g.lineStyle(0.1,colour&0xffffff,1);
		if(pr(inner).xnull)
	        g.drawCircle(position.x,position.y,radius);
		else {
			var v = pr(inner).xform.outer.transform(position);
			g.drawCircle(v.x,v.y,radius*pr(inner).xdet);
			v.dispose();
		}
    }

    public override function drawAABB(aabb:AABB, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

        DEBUG(if(aabb==null) throw "Error: drawAABB::aabb cannot be null";)
        var g = pr(inner_zn).graphics;

        g.lineStyle(0.1,colour&0xffffff,1);
		if(pr(inner).xnull)
	        g.drawRect(aabb.x,aabb.y,aabb.width,aabb.height);
		else {
			var v = pr(inner).xform.outer.transform(aabb.min);
			var w = Vec2.get(aabb.width,0);  var w2 = pr(inner).xform.outer.transform(w,true);
			var h = Vec2.get(aabb.height,0); var h2 = pr(inner).xform.outer.transform(h,true);

			g.moveTo(v.x,v.y);
			g.lineTo(v.x+w2.x,v.y+w2.y);
			g.lineTo(v.x+w2.x+h2.x,v.y+w2.y+h2.y);
			g.lineTo(v.x+h2.x,v.y+h2.y);
			g.lineTo(v.x,v.y);

			v.dispose();
			w.dispose(); w2.dispose();
			h.dispose(); h2.dispose();
		}
    }
    
    public override function drawFilledTriangle(p0:Vec2, p1:Vec2, p2:Vec2, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Disposed(p0,Vec2);
		Disposed(p1,Vec2);
		Disposed(p2,Vec2);
        DEBUG(if(p0==null || p1==null || p2==null) throw "Error: drawFilledTriangle can't use null points";)
        var g = pr(inner_zn).graphics;
        g.lineStyle(0,0,0);
        g.beginFill(colour&0xffffff,1);
		if(pr(inner).xnull) {
	        g.moveTo(p0.x,p0.y);
	        g.lineTo(p1.x,p1.y);
	        g.lineTo(p2.x,p2.y);
		}else {
			var v = pr(inner).xform.outer.transform(p0);
			g.moveTo(v.x,v.y); v.dispose();
			v = pr(inner).xform.outer.transform(p1);
			g.lineTo(v.x,v.y); v.dispose();
			v = pr(inner).xform.outer.transform(p2);
			g.lineTo(v.x,v.y); v.dispose();
		}
        g.endFill();
    }

    public override function drawFilledCircle(position:Vec2, radius:Float, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Disposed(position,Vec2);
        DEBUG(
            if(position==null) throw "Error: drawFilledCircle::position cannot be null";
            if(isNaN(radius) || radius<0) throw "Error: drawFilledCircle::radius must be >=0";
        )
        var g = pr(inner_zn).graphics;
        g.lineStyle(0,0,0);
        g.beginFill(colour&0xffffff,1);
		if(pr(inner).xnull)
	        g.drawCircle(position.x,position.y,radius);
		else {
			var v = pr(inner).xform.outer.transform(position);
			g.drawCircle(v.x,v.y,radius*pr(inner).xdet);
			v.dispose();
		}
        g.endFill();
    }

	public override function drawPolygon(poly:Array<Vec2>, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)
		DEBUG(if(poly==null) throw "Error: Cannot draw null Vec2 list";)
		DEBUG(
			for(p in poly) Disposed(p,Vec2);
		)

		var g = pr(inner_zn).graphics;
		g.lineStyle(0.1,colour&0xffffff,1.0);
		var fst = poly[poly.length-1];
		g.moveTo(fst.x,fst.y);
		for(p in poly) g.lineTo(p.x,p.y);
	}

    ///---------------------------------------------------------------------------------------------

    public override function draw(object:Dynamic) __draw(object)
}

#end

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

#if flash10

class BitmapDebug extends Debug {
    public var pr(inner_zn):PR(BitmapDebug);

    public function new(width:Int, height:Int, bgColor:Int = 0x333333, transparent:Bool=false) {
        DEBUG(if(width <=0) throw "Error: Debug width must be > 0";)
        DEBUG(if(height<=0) throw "Error: Debug height must be > 0";)

        DEBUG(PR(Debug).internal = true;)
        super();
        DEBUG(PR(Debug).internal = false;)

        pr(inner_zn) = new PR(BitmapDebug)(width,height,bgColor,transparent);
        pr(inner_zn).outer_zn = this;
		pr(inner) = pr(inner_zn);
		pr(inner).outer = this;
    }

    ///---------------------------------------------------------------------------------------------

    public override function clear() pr(inner_zn).clear()
    public override function flush() pr(inner_zn).flush()

    ///---------------------------------------------------------------------------------------------

    public override function drawLine(start:Vec2, end:Vec2, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Disposed(start,Vec2);
		Disposed(end,Vec2);
        DEBUG(
            if(start==null) throw "Error: drawLine::start cannot be null";
            if(end  ==null) throw "Error: drawLine::end cannot be null";
        )
		if(pr(inner).xnull) {
	        var x0:Int = fastint(start.x+0.5);
	        var y0:Int = fastint(start.y+0.5);
	        var x1:Int = fastint(end.x+0.5);
	        var y1:Int = fastint(end.y+0.5);
	        pr(inner_zn).__line(x0,y0,x1,y1,colour|0xff000000);
		}else {
			var v = pr(inner).xform.outer.transform(start);
			var x0:Int = fastint(v.x+0.5);
			var y0:Int = fastint(v.y+0.5);
			v.dispose();
			v = pr(inner).xform.outer.transform(end);
			var x1:Int = fastint(v.x+0.5);
			var y1:Int = fastint(v.y+0.5);
			v.dispose();
	        pr(inner_zn).__line(x0,y0,x1,y1,colour|0xff000000);
		}
    }

    public override function drawCircle(position:Vec2, radius:Float, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Disposed(position,Vec2);
        DEBUG(
            if(position==null) throw "Error: drawCircle::position cannot be null";
            if(isNaN(radius) || radius<0) throw "Error: drawCircle::radius must be >=0";
        )
		if(pr(inner).xnull) {
	        var x:Int = fastint(position.x+0.5);
	        var y:Int = fastint(position.y+0.5);
	        var r:Int = fastint(radius+0.5);
	        pr(inner_zn).__circle(x,y,r, colour|0xff000000);
		}else {
			var v = pr(inner).xform.outer.transform(position);
			var x:Int = fastint(v.x+0.5);
			var y:Int = fastint(v.y+0.5);
			v.dispose();
			var r:Int = fastint(radius*pr(inner).xdet+0.5);
			pr(inner_zn).__circle(x,y,r, colour|0xff000000);
		}
    }

    public override function drawAABB(aabb:AABB, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

        DEBUG(if(aabb==null) throw "Error: drawAABB::aabb cannot be null";)
		if(pr(inner).xnull)
	        pr(inner_zn).__aabb(aabb.pr(inner), colour);
		else {
			var v = pr(inner).xform.outer.transform(aabb.min);
			var w = Vec2.get(aabb.width,0);  var w2 = pr(inner).xform.outer.transform(w,true);
			var h = Vec2.get(0,aabb.height); var h2 = pr(inner).xform.outer.transform(h,true);

			var x0:Int = fastint(v.x+0.5);
			var y0:Int = fastint(v.y+0.5);
			var x1:Int = fastint(v.x+w2.x+0.5);
			var y1:Int = fastint(v.y+w2.y+0.5);
			var x2:Int = fastint(v.x+w2.x+h2.x+0.5);
			var y2:Int = fastint(v.y+w2.y+h2.y+0.5);
			var x3:Int = fastint(v.x+h2.x+0.5);
			var y3:Int = fastint(v.y+h2.y+0.5);

			v.dispose();
			w.dispose(); w2.dispose();
			h.dispose(); h2.dispose();

			var col = colour|0xff000000;
	        pr(inner_zn).__line(x0,y0,x1,y1,col);
	        pr(inner_zn).__line(x1,y1,x2,y2,col);
	        pr(inner_zn).__line(x2,y2,x3,y3,col);
	        pr(inner_zn).__line(x3,y3,x0,y0,col);
		}
    }

    public override function drawFilledTriangle(p0:Vec2, p1:Vec2, p2:Vec2, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Disposed(p0,Vec2); Disposed(p1,Vec2); Disposed(p2,Vec2);
        DEBUG(if(p0==null || p1==null || p2==null) throw "Error: drawFilledTriangle can't use null points";)
        pr(inner_zn).__tri(p0,p1,p2, colour);
    }

    public override function drawFilledCircle(position:Vec2, radius:Float, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Disposed(position,Vec2);
        DEBUG(
            if(position==null) throw "Error: drawFilledCircle::position cannot be null";
            if(isNaN(radius) || radius<0) throw "Error: drawFilledCircle::radius must be >=0";
        )
		if(pr(inner).xnull) {
	        var x:Int = fastint(position.x+0.5);
	        var y:Int = fastint(position.y+0.5);
	        var r:Int = fastint(radius+0.5);
	        pr(inner_zn).__fcircle(x,y,r, colour|0xff000000);
		}else {
			var v = pr(inner).xform.outer.transform(position);
			var x:Int = fastint(v.x+0.5);
			var y:Int = fastint(v.y+0.5);
			v.dispose();
			var r:Int = fastint(radius*pr(inner).xdet+0.5);
	        pr(inner_zn).__fcircle(x,y,r, colour|0xff000000);
 		}
    }

	public override function drawPolygon(poly:Array<Vec2>, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)
		DEBUG(if(poly==null) throw "Error: Cannot draw null Vec2 list";)
		DEBUG(
			for(p in poly) Disposed(p,Vec2);
		)

		var col = colour|0xff000000;
		var fst = poly[poly.length-1];
		var px:Int,py:Int;
		if(pr(inner).xnull) {
			px = fastint(fst.x+0.5);
			py = fastint(fst.y+0.5);
		}else {
			var v = pr(inner).xform.outer.transform(fst);
			px = fastint(v.x+0.5);
			py = fastint(v.y+0.5);
			v.dispose();
		}

		for(p in poly) {
			var cx:Int,cy:Int;
			if(pr(inner).xnull) {
				cx = fastint(p.x+0.5);
				cy = fastint(p.y+0.5);
			}else {
				var v = pr(inner).xform.outer.transform(p);
				cx = fastint(v.x+0.5);
				cy = fastint(v.y+0.5);
				v.dispose();
			}
			pr(inner_zn).__line(px,py,cx,cy,col);
			px = cx; py = cy;
		}
	}

    ///---------------------------------------------------------------------------------------------

    public override function draw(object:Dynamic) __draw(object)
}

#end

///-------------------------------------------------------------------------------------------------

#if false

    public function linearWave(graphics:Graphics, x1:Float,y1:Float, x2:Float,y2:Float) {
		vec_new(d, x2-x1, y2-y1);
		vec_diveq(d,8);
		
		vec_new(n); vec_set(n,d);
		if(vec_lsq(n)<0.1) return;
		
		vec_normal(n); vec_muleq(n,4); //2*r
		
		graphics.moveTo(x1,y1);
		graphics.curveTo(x1+dx  +nx,y1+dy  +ny, x1+dx*2,y1+dy*2);
		graphics.curveTo(x1+dx*3-nx,y1+dy*3-ny, x1+dx*4,y1+dy*4);
		graphics.curveTo(x1+dx*5+nx,y1+dy*5+ny, x1+dx*6,y1+dy*6);
		graphics.curveTo(x1+dx*7-nx,y1+dy*7-ny, x2,y2);
	}
	public function linearSaw(graphics:Graphics, x1:Float,y1:Float, x2:Float,y2:Float) {
		vec_new(d, x2-x1, y2-y1);
		vec_diveq(d,8);
		
		vec_new(n); vec_set(n,d);
		if(vec_lsq(n)<0.1) return;
		
		vec_normal(n); vec_muleq(n,2); //r
		
		graphics.moveTo(x1,y1);
		graphics.lineTo(x1+dx  +nx,y1+dy  +ny);
		
		graphics.moveTo(x1+dx  -nx,y1+dy  -ny);
		graphics.lineTo(x1+dx*3+nx,y1+dy*3+ny);
		
		graphics.moveTo(x1+dx*3-nx,y1+dy*3-ny);
		graphics.lineTo(x1+dx*5+nx,y1+dy*5+ny);
		
		graphics.moveTo(x1+dx*5-nx,y1+dy*5-ny);
		graphics.lineTo(x1+dx*7+nx,y1+dy*7+ny);
		
		graphics.moveTo(x1+dx*7-nx,y1+dy*7-ny);
		graphics.lineTo(x2,y2);
	}

#end
