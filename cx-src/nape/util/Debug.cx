package nape.util;

$(import);

class Debug {

    public static function version() {
		return PR(HaxeMacros).cversion();
    }

	public static function clearObjectPools() {
		$(expand global CLEARITERATOR(T) {
			while(T.pr(pool)!=null) {
				var nxt = T.pr(pool).pr(next);
				T.pr(pool).pr(next) = null;
				T.pr(pool) = nxt;
			}
		});
		$(expand global CLEARPOOL(T) {
			while(T.pr(pool)!=null) {
				var nxt = T.pr(pool).next;
				T.pr(pool).next = null;
				T.pr(pool) = nxt;
			}
			DEBUG(T.POOL_CNT = 0;)
		});
		$(expand global PUBCLEARPOOL(T) {
			while(PR(PubPool).pool`T!=null) {
				var nxt = PR(PubPool).pool`T.pr(pool);
				PR(PubPool).pool`T.pr(pool) = null;
				PR(PubPool).pool`T = nxt;
			}
			DEBUG(ZPP_`STATS`T.POOL_CNT = 0;)
		});
	}

	#if (!NAPE_RELEASE_BUILD)
		public static function objectPoolStats() {
			function pad(s:String,l:Int,?x:String):String {
				if(x==null) x = " ";
				var ret = s;
				while(ret.length<l) ret += x;
				return ret;
			}

			var max = "objectPoolStats::".length;
			var maxcnt = "size#".length;
			var maxget = "alloc#".length;
			var maxfree = "free#".length;

			var strs = [];
			$(expand global POOLSTATS(T,A) {
				if(A.POOL_CNT!=0 || A.POOL_GET!=0 || A.POOL_FREE!=0) {

					if($str(T).length > max) max = $str(T).length;
					var cnt  = Std.string(A.POOL_CNT);
					var get  = Std.string(A.POOL_GET); A.POOL_GET = 0;
					var free = Std.string(A.POOL_FREE); A.POOL_FREE = 0;
					if(cnt.length > maxcnt) maxcnt = cnt.length;
					if(get.length > maxget) maxget = get.length;
					if(free.length>maxfree) maxfree=free.length;

					strs.push({str:$str(T),cnt:cnt,get:get,free:free});
				}
			});
			var ret = pad("objectPoolStats::",max)
			     +" "+pad("size#",maxcnt)
				 +" "+pad("alloc#",maxget)
				 +" "+pad("free#",maxfree)
				 +"\n";

			ret += pad("",max+1+maxcnt+1+maxfree+1,"-") + "\n";

			for(s in strs) {
				ret += pad(s.str,max)
				  +" "+pad(s.cnt,maxcnt)
				  +" "+pad(s.get,maxget)
				  +" "+pad(s.free,maxfree)
				  +"\n";
			}

			return ret;
		}
	#end

    #if NAPE_TIMES
		static public var ltime = 0;
        static public function TIMES(space:Space) {
            var text = "";
			var dt = space.timeStamp - ltime;
	    text += "Validation:    "+Std.string(Debug.VALID/dt).substr(0,5)+"ms\n";
            text += "Broadphase:    "+Std.string((Debug.BROAD-Debug.NARROW)/dt).substr(0,5)+"ms :: total = "+Std.string(Debug.BROAD/dt).substr(0,5)+"ms\n";
			text += "Narrowphase:   "+Std.string(Debug.NARROW/dt).substr(0,5)+"ms\n";
            text += "Set-Forest:    "+Std.string(Debug.FOR/dt).substr(0,5)+"ms\n";
            text += "Prestep:       "+Std.string(Debug.PRE/dt).substr(0,5)+"ms\n";
			text += "Contact sort:  "+Std.string(Debug.SORT/dt).substr(0,5)+"ms\n";
            text += "Position It.:  "+Std.string(Debug.POS/dt).substr(0,5)+"ms\n";
            text += "Velocity It.:  "+Std.string(Debug.VEL/dt).substr(0,5)+"ms\n";
            text += "Debug Draw:    "+Std.string(Debug.DRAW/dt).substr(0,5)+"ms\n";
            text += "\n";
            text += "arb:        "+Debug.ACNT+"\n";
            text += "active arb: "+Debug.AACNT+"\n";
            text += "con:        "+Debug.CCNT+"\n";
            text += "active con: "+Debug.ACCNT+"\n";
			text += "\n";
			text += "hash collisions: "+Std.string(Debug.HASH/Debug.HASHT*100).substr(0,5)+"%\n";
			text += "\n";
			text += "Broadphase adjustments: "+Std.string(BROADCLASH/BROADTOTAL*100).substr(0,5)+"%\n";

			if(space.timeStamp-ltime > 50) {
				Debug.FOR = Debug.BROAD = Debug.PRE = Debug.POS = Debug.VEL = Debug.DRAW = Debug.VALID = Debug.SORT = Debug.NARROW = Debug.BROADCLASH = Debug.BROADTOTAL = 0;
				ltime = space.timeStamp;
			}

            return text;
        }

        static public var ACNT = 0;
        static public var AACNT = 0;
        static public var CCNT = 0;
        static public var ACCNT = 0;

        static public var FOR = 0;
        static public var PRE = 0;
        static public var VEL = 0;
        static public var POS = 0;
        static public var BROAD = 0;
		static public var NARROW = 0;
        static public var DRAW = 0;
		static public var VALID = 0;
		static public var SORT = 0;

		static public var HASH = 0;
		static public var HASHT = 0;

		static public var BROADCLASH = 0;
		static public var BROADTOTAL = 0;
    #end

    ///---------------------------------------------------------------------------------------------

    #if (flash9||nme)

    keep public static function createGraphic(body:Body):flash.display.Shape {
		Destroyed(body,Body)
		DEBUG(if(body==null) throw "Error: Cannot create debug graphic for null Body";)
		var ret = new flash.display.Shape();
		var graphics = ret.graphics;

        var idc:Int = fastint(0xffffff*Math.exp(-body.id/1500));
        var _r = (((idc&0xff0000)>>16))*0.7;
        var _g = (((idc&0xff00)>>8))*0.7;
        var _b = (idc&0xff)*0.7;
	
        var col = ((fastint(_r))<<16)|((fastint(_g))<<8)|(fastint(_b));
        graphics.lineStyle(0.1,col,1);

		for(s in body.shapes) {
			if(s.isCircle()) {
				var c = s.castCircle;
				graphics.drawCircle(c.localCOM.x,c.localCOM.y,c.radius);	
			} else {
				var p = s.castPolygon;
				graphics.moveTo(s.localCOM.x,s.localCOM.y);
				for(i in 0...p.worldVerts.length) {
					var px = p.localVerts.at(i);
					graphics.lineTo(px.x,px.y);
				}
				var px = p.localVerts.at(0);
				graphics.lineTo(px.x,px.y);
			}

			if(s.isCircle()) {
				var c = s.castCircle;
				graphics.moveTo(c.localCOM.x+c.radius*0.3,c.localCOM.y);
				graphics.lineTo(c.localCOM.x+c.radius,c.localCOM.y);
			}
		}
			
		return ret;
    }

    ///---------------------------------------------------------------------------------------------

	public var pr(inner):PR(Debug);

    public var drawCollisionArbiters:Bool;
	public var drawFluidArbiters:Bool;
	public var drawSensorArbiters:Bool;
	
	public var drawBodies:Bool;
	public var drawBodyDetail:Bool; //requires drawBodies
	public var drawShapeDetail:Bool; //requires drawBodies
	public var drawShapeAngleIndicators:Bool; //requires drawBodies

	public var drawConstraints:Bool;
	public var drawConstraintSprings:Bool; //requires drawConstraints=true
	public var drawConstraintErrors:Bool; //requires drawconstraints=true

    property(bgColor,Int,{
		pr(inner).bg_col;
    },{
		#if flash10
			if(pr(inner).isbmp) pr(inner).d_bmp.setbg(bgColor);
			else                pr(inner).d_shape.setbg(bgColor);
		#else
			pr(inner).d_shape.setbg(bgColor);
		#end
    })

	public var colour:Int->Int;

    ///---------------------------------------------------------------------------------------------

	public function new() {
        DEBUG(
            if(!PR(Debug).internal)
                throw "Error: Cannot instantiate Debug derp! Use ShapeDebug, or BitmapDebug on flash10+";
        )

		drawCollisionArbiters = false;
		drawFluidArbiters = false;
		drawSensorArbiters = false;
		drawBodies = true;
        drawShapeAngleIndicators = true;
		drawBodyDetail = false;
		drawShapeDetail = false;
		drawConstraints = false;
		drawConstraintSprings = true;
		drawConstraintErrors = false;

		cullingEnabled = false;

		colour = null;
	}

    ///---------------------------------------------------------------------------------------------

    property(display, flash.display.DisplayObject, {
		#if flash10
			var ret:flash.display.DisplayObject;
			if(pr(inner).isbmp) ret = pr(inner).d_bmp.bitmap;
			else                ret = pr(inner).d_shape.shape;
			ret;
		#else
			pr(inner).d_shape.shape;
		#end
    })

	public var cullingEnabled:Bool;

    ///---------------------------------------------------------------------------------------------

	property(transform, Mat23, {
		if(pr(inner).xform==null) pr(inner).setform();
		pr(inner).xform.outer;
	}, {
		DEBUG(if(transform==null) throw "Error: Cannot set Debug::transform to null";)
		this.transform.set(transform);
	})

    public function clear():Void {}
    public function flush():Void {}

    ///---------------------------------------------------------------------------------------------

    public function draw(object:Dynamic):Void {}

    public function drawLine  (start:Vec2, end:Vec2, colour:Int):Void {}
	public function drawCurve (start:Vec2, control:Vec2, end:Vec2, colour:Int):Void {}
    public function drawCircle(position:Vec2, radius:Float, colour:Int):Void {}
    public function drawAABB  (aabb:AABB, colour:Int):Void {}
    
    public function drawFilledTriangle(p0:Vec2, p1:Vec2, p2:Vec2, colour:Int):Void {}
    public function drawFilledCircle(position:Vec2, radius:Float, colour:Int):Void {}

	public function drawPolygon (polygon:Dynamic, colour:Int):Void {}
	public function drawFilledPolygon (polygon:Dynamic, colour:Int):Void {}

	public function drawSpring(start:Vec2,end:Vec2,colour:Int,?coils=3,?radius=3.0):Void {}

    #end
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

$(mixin __draw(obj) {
	DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

	if(pr(inner).xnull) {
	    if  (Std.is(obj,Space))      pr(inner_zn).draw_space(cast(obj,Space     ).pr(inner), null,1.0,true);
	    elif(Std.is(obj,Body )) {
			Destroyed(cast(obj,Body),Body)
			pr(inner_zn).draw_body (cast(obj,Body).pr(inner), null,1.0,true);
		}
	    elif(Std.is(obj,Shape)) {
			Destroyed(cast(obj,Shape),Shape)
			pr(inner_zn).draw_shape(cast(obj,Shape).pr(inner), null,1.0,true);
		}
	    elif(Std.is(obj,Constraint)) cast(obj,Constraint).pr(inner).draw(this); 
	    DEBUG(else throw "Error: Unhandled object type for Debug draw";)
	}else {
	    if  (Std.is(obj,Space))      pr(inner_zn).draw_space(cast(obj,Space     ).pr(inner), pr(inner).xform,pr(inner).xdet,false);
	    elif(Std.is(obj,Body)) { 
			Destroyed(cast(obj,Body),Body)
			pr(inner_zn).draw_body (cast(obj,Body).pr(inner), pr(inner).xform,pr(inner).xdet,false);
		}
	    elif(Std.is(obj,Shape)) {
			Destroyed(cast(obj,Shape),Shape)
			pr(inner_zn).draw_shape(cast(obj,Shape).pr(inner), pr(inner).xform,pr(inner).xdet,false);
		}
	    elif(Std.is(obj,Constraint)) cast(obj,Constraint).pr(inner).draw(this);
	    DEBUG(else throw "Error: Unhandled object type for Debug draw";)
	}

});

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

#if (flash9||nme)

class ShapeDebug extends Debug {
    public var pr(inner_zn):PR(ShapeDebug);

	public var thickness:Float;

	flibopts(1)
    public function new(width:Int,height:Int,bgColor=0x333333) {
        DEBUG(if(width <=0) throw "Error: Debug width must be > 0";)
        DEBUG(if(height<=0) throw "Error: Debug height must be > 0";)

        DEBUG(PR(Debug).internal = true;)
        super();
        DEBUG(PR(Debug).internal = false;)

        pr(inner_zn) = new PR(ShapeDebug)(width,height);
        pr(inner_zn).outer_zn = this;
		pr(inner) = pr(inner_zn);
		pr(inner).outer = this;

        this.bgColor = bgColor;
		this.thickness = 0.1;
    }

    ///---------------------------------------------------------------------------------------------

    public override function clear() pr(inner_zn).graphics.clear()

    ///---------------------------------------------------------------------------------------------

    public override function drawLine(start:Vec2, end:Vec2, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(start,Vec2);
		Destroyed(end,Vec2);
        DEBUG(
            if(start==null) throw "Error: drawLine::start cannot be null";
            if(end  ==null) throw "Error: drawLine::end cannot be null";
        )
        var g = pr(inner_zn).graphics;

        g.lineStyle(0.1,colour&0xffffff,1);
		if(pr(inner).xnull) {
	        g.moveTo(start.x,start.y);
	        g.lineTo(end.x,end.y);
		}else {
			var v = pr(inner).xform.outer.transform(start);
			g.moveTo(v.x,v.y); v.destroy();
			v = pr(inner).xform.outer.transform(end);
			g.lineTo(v.x,v.y); v.destroy();
		}

		WEAK(start);
		WEAK(end);
    }

	public override function drawCurve (start:Vec2, control:Vec2, end:Vec2, colour:Int):Void {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(start,Vec2);
		Destroyed(control,Vec2);
		Destroyed(end,Vec2);
		DEBUG(
			if(start==null) throw "Error: drawCurve::start cannot be null";
			if(control==null) throw "Error: drawCurve::control cannot be null";
			if(end==null) throw "Error: drawCurve::end cannot be null";
		)
		var g = pr(inner_zn).graphics;

		g.lineStyle(0.1,colour&0xffffff,1);
		if(pr(inner).xnull) {
			g.moveTo(start.x,start.y);
			g.curveTo(control.x,control.y,end.x,end.y);
		}else {
			var u = pr(inner).xform.outer.transform(start);
			var v = pr(inner).xform.outer.transform(control);
			var q = pr(inner).xform.outer.transform(end);
			g.moveTo(u.x,u.y);
			g.curveTo(v.x,v.y,q.x,q.y);
			u.destroy();
			v.destroy();
			q.destroy();
		}

		WEAK(start);
		WEAK(control);
		WEAK(end);
	}

    public override function drawCircle(position:Vec2, radius:Float, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(position,Vec2);
        DEBUG(
            if(position==null) throw "Error: drawCircle::position cannot be null";
            if(isNaN(radius) || radius<0) throw "Error: drawCircle::radius must be >=0";
        )
        var g = pr(inner_zn).graphics;

        g.lineStyle(0.1,colour&0xffffff,1);
		if(pr(inner).xnull)
	        g.drawCircle(position.x,position.y,radius);
		else {
			var v = pr(inner).xform.outer.transform(position);
			g.drawCircle(v.x,v.y,radius*pr(inner).xdet);
			v.destroy();
		}

		WEAK(position);
    }

    public override function drawAABB(aabb:AABB, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

        DEBUG(if(aabb==null) throw "Error: drawAABB::aabb cannot be null";)
        var g = pr(inner_zn).graphics;

        g.lineStyle(0.1,colour&0xffffff,1);
		if(pr(inner).xnull)
	        g.drawRect(aabb.x,aabb.y,aabb.width,aabb.height);
		else {
			var v = pr(inner).xform.outer.transform(aabb.min);
			var w = Vec2.get(aabb.width,0);  var w2 = pr(inner).xform.outer.transform(w,true);
			var h = Vec2.get(aabb.height,0); var h2 = pr(inner).xform.outer.transform(h,true);

			g.moveTo(v.x,v.y);
			g.lineTo(v.x+w2.x,v.y+w2.y);
			g.lineTo(v.x+w2.x+h2.x,v.y+w2.y+h2.y);
			g.lineTo(v.x+h2.x,v.y+h2.y);
			g.lineTo(v.x,v.y);

			v.destroy();
			w.destroy(); w2.destroy();
			h.destroy(); h2.destroy();
		}
    }
    
    public override function drawFilledTriangle(p0:Vec2, p1:Vec2, p2:Vec2, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(p0,Vec2);
		Destroyed(p1,Vec2);
		Destroyed(p2,Vec2);
        DEBUG(if(p0==null || p1==null || p2==null) throw "Error: drawFilledTriangle can't use null points";)
        var g = pr(inner_zn).graphics;
        g.lineStyle(0,0,0);
        g.beginFill(colour&0xffffff,1);
		if(pr(inner).xnull) {
	        g.moveTo(p0.x,p0.y);
	        g.lineTo(p1.x,p1.y);
	        g.lineTo(p2.x,p2.y);
		}else {
			var v = pr(inner).xform.outer.transform(p0);
			g.moveTo(v.x,v.y); v.destroy();
			v = pr(inner).xform.outer.transform(p1);
			g.lineTo(v.x,v.y); v.destroy();
			v = pr(inner).xform.outer.transform(p2);
			g.lineTo(v.x,v.y); v.destroy();
		}
        g.endFill();

		WEAK(p0); WEAK(p1); WEAK(p2);
    }

    public override function drawFilledCircle(position:Vec2, radius:Float, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(position,Vec2);
        DEBUG(
            if(position==null) throw "Error: drawFilledCircle::position cannot be null";
            if(isNaN(radius) || radius<0) throw "Error: drawFilledCircle::radius must be >=0";
        )
        var g = pr(inner_zn).graphics;
        g.lineStyle(0,0,0);
        g.beginFill(colour&0xffffff,1);
		if(pr(inner).xnull)
	        g.drawCircle(position.x,position.y,radius);
		else {
			var v = pr(inner).xform.outer.transform(position);
			g.drawCircle(v.x,v.y,radius*pr(inner).xdet);
			v.destroy();
		}
        g.endFill();

		WEAK(position);
    }

	public override function drawPolygon(polygon:Dynamic, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)
		DEBUG(if(polygon==null) throw "Error: Cannot draw null polygon";)

		var g = pr(inner_zn).graphics;
		g.lineStyle(0.1,colour&0xffffff,1.0);
		var fst = null;
		var fsttime = true;
		if(pr(inner).xnull) {
			PolyIter(p,polygon,{ if(fsttime) { fst = p.copy(); g.moveTo(p.x,p.y); } else g.lineTo(p.x,p.y); fsttime = false; });
			g.lineTo(fst.x,fst.y);
			fst.destroy();
		}else {
			PolyIter(p,polygon, {
				var v = pr(inner).xform.outer.transform(p);
				if(fsttime) { fst = v; g.moveTo(v.x,v.y); } else g.lineTo(v.x,v.y);
				if(!fsttime) v.destroy();
				fsttime = false;
			});
			g.lineTo(fst.x,fst.y);
			fst.destroy();
		}
		PolyWeak(polygon);
	}

	public override function drawFilledPolygon (polygon:Dynamic, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)
		DEBUG(if(polygon==null) throw "Error: Cannot draw null polygon!";)

		var g = pr(inner_zn).graphics;
		g.beginFill(colour&0xffffff,1.0);
		g.lineStyle(0,0,0);
		var fst = null;
		var fsttime = true;
		if(pr(inner).xnull) {
			PolyIter(p,polygon,{ if(fsttime) { fst = p.copy(); g.moveTo(p.x,p.y); } else g.lineTo(p.x,p.y); fsttime = false; });
			g.lineTo(fst.x,fst.y);
			fst.destroy();
		}else {
			PolyIter(p,polygon, {
				var v = pr(inner).xform.outer.transform(p);
				if(fsttime) { fst = v; g.moveTo(v.x,v.y); } else g.lineTo(v.x,v.y);
				if(!fsttime) v.destroy();
				fsttime = false;
			});
			g.lineTo(fst.x,fst.y);
			fst.destroy();
		}
		g.endFill();
		PolyWeak(polygon);
	}
    ///---------------------------------------------------------------------------------------------

    public override function draw(object:Dynamic) __draw(object)
	public override function drawSpring(start:Vec2,end:Vec2,colour:Int,?coils=3,?radius=3.0) __spring(start,end,colour,coils,radius)
}

#end

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

#if flash10

class BitmapDebug extends Debug {
    public var pr(inner_zn):PR(BitmapDebug);

	flibopts(2)
    public function new(width:Int, height:Int, bgColor:Int = 0x333333, transparent:Bool=false) {
        DEBUG(if(width <=0) throw "Error: Debug width must be > 0";)
        DEBUG(if(height<=0) throw "Error: Debug height must be > 0";)

        DEBUG(PR(Debug).internal = true;)
        super();
        DEBUG(PR(Debug).internal = false;)

        pr(inner_zn) = new PR(BitmapDebug)(width,height,bgColor,transparent);
        pr(inner_zn).outer_zn = this;
		pr(inner) = pr(inner_zn);
		pr(inner).outer = this;
    }

    ///---------------------------------------------------------------------------------------------

    public override function clear() {
		pr(inner_zn).prepare();
		pr(inner_zn).clear();
	}
    public override function flush() {
		pr(inner_zn).prepare();
		pr(inner_zn).flush();
	}

    ///---------------------------------------------------------------------------------------------

    public override function drawLine(start:Vec2, end:Vec2, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(start,Vec2);
		Destroyed(end,Vec2);
        DEBUG(
            if(start==null) throw "Error: drawLine::start cannot be null";
            if(end  ==null) throw "Error: drawLine::end cannot be null";
        )
		pr(inner_zn).prepare();
		if(pr(inner).xnull) {
	        var x0:Int = fastint(start.x+0.5);
	        var y0:Int = fastint(start.y+0.5);
	        var x1:Int = fastint(end.x+0.5);
	        var y1:Int = fastint(end.y+0.5);
	        pr(inner_zn).__line(x0,y0,x1,y1,colour|0xff000000);
		}else {
			var v = pr(inner).xform.outer.transform(start);
			var x0:Int = fastint(v.x+0.5);
			var y0:Int = fastint(v.y+0.5);
			v.destroy();
			v = pr(inner).xform.outer.transform(end);
			var x1:Int = fastint(v.x+0.5);
			var y1:Int = fastint(v.y+0.5);
			v.destroy();
	        pr(inner_zn).__line(x0,y0,x1,y1,colour|0xff000000);
		}

		WEAK(start);
		WEAK(end);
    }

	public override function drawCurve (start:Vec2, control:Vec2, end:Vec2, colour:Int):Void {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(start,Vec2);
		Destroyed(control,Vec2);
		Destroyed(end,Vec2);
		DEBUG(
			if(start==null) throw "Error: drawCurve::start cannot be null";
			if(control==null) throw "Error: drawCurve::control cannot be null";
			if(end==null) throw "Error: drawCurve::end cannot be null";
		)
		pr(inner_zn).prepare();
		if(pr(inner).xnull) {
			pr(inner_zn).__curve(start,control,end,colour);
		}else {
			var u = pr(inner).xform.outer.transform(start);
			var v = pr(inner).xform.outer.transform(control);
			var q = pr(inner).xform.outer.transform(end);
			pr(inner_zn).__curve(u,v,q,colour);
			u.destroy();
			v.destroy();
			q.destroy();
		}

		WEAK(start);
		WEAK(control);
		WEAK(end);
	}

    public override function drawCircle(position:Vec2, radius:Float, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(position,Vec2);
        DEBUG(
            if(position==null) throw "Error: drawCircle::position cannot be null";
            if(isNaN(radius) || radius<0) throw "Error: drawCircle::radius must be >=0";
        )
		pr(inner_zn).prepare();
		if(pr(inner).xnull) {
	        var x:Int = fastint(position.x+0.5);
	        var y:Int = fastint(position.y+0.5);
	        var r:Int = fastint(radius+0.5);
	        pr(inner_zn).__circle(x,y,r, colour|0xff000000);
		}else {
			var v = pr(inner).xform.outer.transform(position);
			var x:Int = fastint(v.x+0.5);
			var y:Int = fastint(v.y+0.5);
			v.destroy();
			var r:Int = fastint(radius*pr(inner).xdet+0.5);
			pr(inner_zn).__circle(x,y,r, colour|0xff000000);
		}

		WEAK(position);
    }

    public override function drawAABB(aabb:AABB, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

        DEBUG(if(aabb==null) throw "Error: drawAABB::aabb cannot be null";)
		pr(inner_zn).prepare();
		if(pr(inner).xnull)
	        pr(inner_zn).__aabb(aabb.pr(inner), colour);
		else {
			var v = pr(inner).xform.outer.transform(aabb.min);
			var w = Vec2.get(aabb.width,0);  var w2 = pr(inner).xform.outer.transform(w,true);
			var h = Vec2.get(0,aabb.height); var h2 = pr(inner).xform.outer.transform(h,true);

			var x0:Int = fastint(v.x+0.5);
			var y0:Int = fastint(v.y+0.5);
			var x1:Int = fastint(v.x+w2.x+0.5);
			var y1:Int = fastint(v.y+w2.y+0.5);
			var x2:Int = fastint(v.x+w2.x+h2.x+0.5);
			var y2:Int = fastint(v.y+w2.y+h2.y+0.5);
			var x3:Int = fastint(v.x+h2.x+0.5);
			var y3:Int = fastint(v.y+h2.y+0.5);

			v.destroy();
			w.destroy(); w2.destroy();
			h.destroy(); h2.destroy();

			var col = colour|0xff000000;
	        pr(inner_zn).__line(x0,y0,x1,y1,col);
	        pr(inner_zn).__line(x1,y1,x2,y2,col);
	        pr(inner_zn).__line(x2,y2,x3,y3,col);
	        pr(inner_zn).__line(x3,y3,x0,y0,col);
		}
    }

    public override function drawFilledTriangle(p0:Vec2, p1:Vec2, p2:Vec2, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(p0,Vec2); Destroyed(p1,Vec2); Destroyed(p2,Vec2);
        DEBUG(if(p0==null || p1==null || p2==null) throw "Error: drawFilledTriangle can't use null points";)
		pr(inner_zn).prepare();
        pr(inner_zn).__tri(p0,p1,p2, colour);

		WEAK(p0); WEAK(p1); WEAK(p2);
    }

    public override function drawFilledCircle(position:Vec2, radius:Float, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)

		Destroyed(position,Vec2);
        DEBUG(
            if(position==null) throw "Error: drawFilledCircle::position cannot be null";
            if(isNaN(radius) || radius<0) throw "Error: drawFilledCircle::radius must be >=0";
        )
		pr(inner_zn).prepare();
		if(pr(inner).xnull) {
	        var x:Int = fastint(position.x+0.5);
	        var y:Int = fastint(position.y+0.5);
	        var r:Int = fastint(radius+0.5);
	        pr(inner_zn).__fcircle(x,y,r, colour|0xff000000);
		}else {
			var v = pr(inner).xform.outer.transform(position);
			var x:Int = fastint(v.x+0.5);
			var y:Int = fastint(v.y+0.5);
			v.destroy();
			var r:Int = fastint(radius*pr(inner).xdet+0.5);
	        pr(inner_zn).__fcircle(x,y,r, colour|0xff000000);
 		}

		WEAK(position);
    }

	public override function drawPolygon(polygon:Dynamic, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)
		DEBUG(if(polygon==null) throw "Error: Cannot draw null Vec2 list";)

		pr(inner_zn).prepare();
		var col = colour|0xff000000;
		var fx:Int,fy:Int;

		var fst = null;
		var px:Int,py:Int;

		fx = fy = px = py = 0;
		PolyIter(p, polygon, {
			var cx:Int, cy:Int;
			var fsttime = fst==null;
			if(pr(inner).xnull) {
				cx = fastint(p.x+0.5);
				cy = fastint(p.y+0.5);
				if(fsttime) fst = p.copy();
			}else {
				var v = pr(inner).xform.outer.transform(p);
				cx = fastint(v.x+0.5);
				cy = fastint(v.y+0.5);
				if(fsttime) fst = v;
				else v.destroy();
			}
			if(fsttime) {
				fx = px = cx;
				fy = py = cy;
			}else {
				pr(inner_zn).__line(px,py,cx,cy,col);
				px = cx; py = cy;
			}
		});
		pr(inner_zn).__line(px,py,fx,fy,col);
		fst.destroy();
		PolyWeak(polygon);
	}

	public override function drawFilledPolygon(polygon:Dynamic, colour:Int) {
		DEBUG(if(pr(inner).xform!=null && !pr(inner).xform.outer.equiorthogonal()) throw "Error: Debug draw can only operate with an equiorthogonal transform!";)
		DEBUG(if(polygon==null) throw "Error: Cannot render null polygon";)

		var col = colour|0xff000000;
		//render with scan lines from line intersections, avoid use of geometric utility so that it could
		//be seperated as a module, as well as because this is more stable.
		var miny = Math.POSITIVE_INFINITY;
		var maxy = Math.NEGATIVE_INFINITY;

		var vertices:Array<Vec2> = [];
		PolyIter(p, polygon, {
			var v:Vec2;
			if(pr(inner).xnull)
				vertices.push(v = p.copy());
			else {
				v = pr(inner).xform.outer.transform(p);
				vertices.push(v);
			}
			if(v.y<miny) miny = v.y;
			if(v.y>maxy) maxy = v.y;
		});
		PolyWeak(polygon);

		var y0 = fastint(miny+0.5);
		var y1 = fastint(maxy+0.5);
		if(y1<0 || y0>=pr(inner).height) return;

		if(y0<0) y0 = 0;
		if(y1>=pr(inner).height) y1 = pr(inner).height-1;

		for(y in y0...y1+1) {
			var xs:Array<Int> = [];
			for(i in 0...vertices.length) {
				var q = vertices[i];
				var p = vertices[(i+1)%vertices.length];

				if ((p.y < y && q.y >= y
				 ||  q.y < y && p.y >= y)
				) {
					var x = p.x + (y-p.y)/(q.y-p.y)*(q.x-p.x);
					xs.push(fastint(x+0.5));
				}
			}
			xs.sort(function (a,b) return a-b);

			var i = 0;
			while(i+1<xs.length) {
				var u = xs[i++];
				var v = xs[i++];
				if(v<0) continue;
				if(u>=pr(inner).width) break;

				if(u<0) u = 0;
				if(v>=pr(inner).width) v = pr(inner).width-1;

				var ind = pr(inner_zn).index(u,y);
				for(x in u...v+1)
					pr(inner_zn).setpix(ind++,col);
			}
		}

		while(vertices.length>0) vertices.pop().destroy();
	}

    ///---------------------------------------------------------------------------------------------

    public override function draw(object:Dynamic) {
		pr(inner_zn).prepare();
		__draw(object);
	}

	public override function drawSpring(start:Vec2,end:Vec2,colour:Int,?coils=3,?radius=3.0) {
		pr(inner_zn).prepare();
		__spring(start,end,colour,coils,radius);
	}
}

#end

///-------------------------------------------------------------------------------------------------

$(mixin __spring(start,end,colour,coils,radius) {
	Destroyed(start,Vec2)
	Destroyed(end,Vec2)
	DEBUG(if(start==null) throw "Error: drawCurve::start cannot be null";)
	DEBUG(if(end==null) throw "Error: drawCurve::end cannot be null";)
	DEBUG(if(coils<0) throw "Error: drawCurve::coils must be >= 0";)

	if(coils==0) drawLine(start,end,colour);
	else {
		vec_new(d, end.x-start.x, end.y-start.y);
		vec_diveq(d,coils*4);
	
		vec_new(n); vec_set(n,d);
		if(vec_lsq(n)<0.1) return;
		vec_normal(n); vec_muleq(n,radius*2);
	
		var u = start.copy();
		var v = Vec2.get();
		var q = Vec2.get();
		for(i in 0...coils) {
			v.x = u.x + dx + nx; v.y = u.y + dy + ny;
			q.x = u.x + dx*2;    q.y = u.y + dy*2;
			drawCurve(u,v,q,colour);
			u.x = q.x; u.y = q.y;

			v.x = u.x + dx - nx; v.y = u.y + dy - ny;
			q.x = u.x + dx*2;    q.y = u.y + dy*2;
			drawCurve(u,v,q,colour);
			u.x = q.x; u.y = q.y;
		}
		u.destroy();
		v.destroy();
		q.destroy();
	}

	WEAK(start);
	WEAK(end);
});
