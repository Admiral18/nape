package nape.constraint;
$(import);

withConstraint(

class AngleJoint extends Constraint {
	public var pr(inner_zn):PR(AngleJoint);

	wrap_body_new(body1,b1, $(mixin new(b) pr(inner_zn).b2!=b) new)
	wrap_body_new(body2,b2, $(mixin new(b) pr(inner_zn).b1!=b) new)

    property(jointMin,Float,pr(inner_zn).jointMin,{
		DEBUG(if(isNaN(jointMin)) throw "Error: AngleJoint::jointMin cannot be NaN";)
		if(this.jointMin != jointMin) {
			pr(inner_zn).jointMin = jointMin;
			pr(inner).wake();
		}
	})
	
    property(jointMax,Float,pr(inner_zn).jointMax,{
		DEBUG(if(isNaN(jointMax)) throw "Error: AngleJoint::jointMax cannot be NaN";)
		if(this.jointMax != jointMax) {
			pr(inner_zn).jointMax = jointMax;
			pr(inner).wake();
		}
	})

    property(ratio,Float,pr(inner_zn).ratio,{
		DEBUG(if(isNaN(ratio)) throw "Error: AngleJoint::ratio cannot be NaN";)
		if(this.ratio != ratio) {
			pr(inner_zn).ratio = ratio;
			pr(inner).wake();
		}
	})
	
    property(slack,Bool,pr(inner_zn).slack)
	
	//-----------------------------------
	
	public function new(body1:Body, body2:Body, jointMin:Float, jointMax:Float) {
		DEBUG(try { super(); } catch (e:Dynamic) {})
		RELEASE(super();)
		
		pr(inner_zn) = new PR(AngleJoint)();
		pr(inner) = pr(inner_zn);
		pr(inner).outer = this;
		pr(inner_zn).outer_zn = this;
		
		this.body1 = body1;
		this.body2 = body2;
		this.jointMin = jointMin;
		this.jointMax = jointMax;
	}
	
	public override function impulse() {
		var ret = new MatMN(1,1);
		ret.setx(0,0, pr(inner_zn).jAcc);
		return ret;
	}
	
	public override function bodyImpulse(body:Body) {
		DEBUG(if(body==null) throw "Error: Cannot evaluate impulse on null body";
			  if(body!=body1 && body!=body2) throw "Error: Body is not linked to this constraint";
		)
		if(!active) return new Vec3();
		else        return pr(inner_zn).bodyImpulse(body.pr(inner));
	}
	
}

)
