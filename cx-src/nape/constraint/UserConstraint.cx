package nape.constraint;
$(import);

class UserConstraint extends Constraint {
	public var pr(inner_zn):PR(UserConstraint);

	property(__copy, Void->Constraint, pr(inner_zn).ucopy, {
		DEBUG(if(__copy==null) throw "Error: UserConstraint::__copy should not be null";)
		pr(inner_zn).ucopy = __copy;
	})
	property(__destroy,Void->Void, pr(inner_zn).udest, {
		pr(inner_zn).udest = __destroy;
	})
	property(__validation,Void->Void, pr(inner_zn).valid, {
		pr(inner_zn).valid = __validation;
	})

	property(__pos_error 


	public function new(dimensions:Int) {
		DEBUG(try { super(); } catch (e:Dynamic) {})
		RELEASE(super();)

		DEBUG(if(dimensions<1) throw "Error: Constraint dimension must be at least 1";)

		pr(inner_zn) = new PR(UserConstraint)(dimensions);
		pr(inner) = pr(inner_zn);
		pr(inner).outer = this;
		pr(inner_zn).outer_zn = this;
	}

	public override function impulse() {
		var ret = new MatMN(pr(inner_zn).dim,1);
		for(i in 0...pr(inner_zn).dim)
			ret.setx(i,0, pr(inner_zn).jAcc[i] + pr(inner_zn).pjAcc[i]);
		return ret;
	}

	public override function bodyImpulse(body:Body) {
		DEBUG(
			if(body==null) throw "Error: Cannot evaluate impulse on null body";
			var found = false;
			for(b in pr(inner_zn).bodies) {
				if(b.body==body.pr(inner)) { found = true; break; }
			}
			if(!found) throw "Error: Body is not linked to this constraint";
		)
		if(!active) return new Vec3();
		else        return pr(inner_zn).bodyImpulse(body.pr(inner));
	}

	public function registerBody(body:Body) {
		pr(inner).immutable_midstep("UserConstraint::registerBody");
		DEBUG(if(body==null) throw "Error: Cannot register null body";)
		pr(inner_zn).addBody(body.pr(inner));
	}
	public function unregisterBody(body:Body) {
		pr(inner).immutable_midstep("UserConstraint::unregisterBody");
		DEBUG(if(body==null) throw "Error: Cannot unregister null body";)
		if(!pr(inner_zn).remBody(body.pr(inner))) {
			DEBUG(throw "Error: Body is not registered to the constraint";)
		}
	}

}
