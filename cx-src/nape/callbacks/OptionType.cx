package nape.callbacks;
$(import);

class OptionType {
	public var pr(inner):PR(OptionType);

	$(mixin ANY(T)
		public static var ANY_`T(flibget_ANY_`T,never):OptionType;
		force_inline static function flibget_ANY_`T() {
			return new OptionType(PR(CbType).ANY_`T.wrapper());
		}
	);
	ANY(BODY) ANY(SHAPE) ANY(COMPOUND)

	property(negated, Bool, pr(inner).negated)
	property(cbType, CbType, pr(inner).cbType.outer)

	public function new(cbType:CbType, negated:Bool=false) {
		DEBUG(if(cbType==null) throw "Error: Cannot construct OptionType from null CbType";)
		pr(inner) = new PR(OptionType)();
		pr(inner).cbType = cbType.pr(inner);
		pr(inner).negated = negated;
		pr(inner).outer = this;
	}

	public static function choice(types:Dynamic):OptionTypeList return PR(OptionType).toPublicList(types)
	public static function not(types:Dynamic):OptionTypeList {
		var ret = choice(types);
		for(x in ret) x.pr(inner).negated = !x.pr(inner).negated;
		return ret;
	}
	public function except(types:Dynamic) return or(not(types))

	public function or(types:Dynamic):OptionTypeList return choice([this,types])

	@:$keep public function toString() {
		return (negated ? "not " : "") + cbType.toString();
	}
}
