package nape.callbacks;
$(import);

Flags(PreFlag,
    prop(ACCEPT,1)
    prop(IGNORE,2)
    prop(ACCEPT_ONCE,3)
    prop(IGNORE_ONCE,4)
)

Flags(ListenerType,
    prop(BODY,0)
    prop(CONSTRAINT,1)
    prop(INTERACTION,2)
	prop(PRE,3)
)

Flags(InteractionType,
	prop(COLLISION,1)
	prop(SENSOR,2)
	prop(FLUID,4)
	prop(ANY,7)
)

WrapList(Listener,List(PR(Listener)),Node(PR(Listener)),$(mixin closure(x) x.outer) $(mixin erusolc(x) x.pr(inner)))

///-------------------------------------------------------------------------------------------------

class Listener {
    public var pr(inner):PR(Listener);

    property(type,ListenerType,{
        [ListenerType.BODY,ListenerType.CONSTRAINT,ListenerType.INTERACTION,ListenerType.PRE][pr(inner).type];
    })
    property(event,CbEvent,{
        [CbEvent.BEGIN,CbEvent.END,CbEvent.WAKE,CbEvent.SLEEP,CbEvent.BREAK,CbEvent.PRE][pr(inner).event];
    },{
        DEBUG(if(event==null) throw "Error: Cannot set listener event type to null";)
        if(this.event!=event) {
            var xevent = event == CbEvent.BEGIN   ? Flag(CbEvent,BEGIN)   :
						 event == CbEvent.ONGOING ? Flag(CbEvent,ONGOING) :
                         event == CbEvent.END     ? Flag(CbEvent,END)     :
                         event == CbEvent.SLEEP   ? Flag(CbEvent,SLEEP)   :
                         event == CbEvent.WAKE    ? Flag(CbEvent,WAKE)    :
						 event == CbEvent.PRE     ? Flag(CbEvent,PRE)     :
                         Flag(CbEvent,BREAK);
            if(pr(inner).type == Flag(ListenerType,BODY))
                pr(inner).body.swapEvent(xevent);
            else if(pr(inner).type == Flag(ListenerType,CONSTRAINT))
                pr(inner).constraint.swapEvent(xevent);
			else
				pr(inner).interaction.swapEvent(xevent);
        }
    })

    ///---------------------------------------------------------------------------------------------

    public function new() {
        DEBUG(if(!PR(Listener).internal) throw "Error: Cannot instantiate Listener derp!";)
    }

    ///---------------------------------------------------------------------------------------------

    property(space,Space,{
        if(pr(inner).space==null) null else pr(inner).space.outer;
    },{
        if(this.space!=space) {
            if(pr(inner).space!=null) pr(inner).space.outer.listeners.remove(this);
            if(space!=null) space.listeners.add(this); 
            else pr(inner).space = null;
        }
    })

    ///---------------------------------------------------------------------------------------------

    @:$keep public function toString() {
        var event = ["BEGIN","END","WAKE","SLEEP","BREAK","PRE","ONGOING"][pr(inner).event];
        if(pr(inner).type == Flag(ListenerType,BODY)) {
            var body = pr(inner).body;
            return "BodyListener{"+event+"::"+body.outer_zn.cbType+"}";
        }else if(pr(inner).type == Flag(ListenerType,CONSTRAINT)) {
            var con = pr(inner).constraint;
            return "ConstraintListener{"+event+"::"+con.outer_zn.cbType+"}";
		}else {
			var con = pr(inner).interaction;
			var itype = switch(con.itype) {
				case Flag(InteractionType,COLLISION): "COLLISION";
				case Flag(InteractionType,SENSOR):    "SENSOR";
				case Flag(InteractionType,FLUID):     "FLUID";
				default: "ALL";
			}
			var ret = if(pr(inner).type==Flag(ListenerType,INTERACTION))
				 "InteractionListener{"+event+"#";
			else "PreListener{";
			return ret+itype+"::"+con.outer_zni.cbType1+":"+con.outer_zni.cbType2+"}";
		}
    }
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class BodyListener extends Listener {
    public var pr(inner_zn):PR(BodyListener);

    property(cbType,CbType,pr(inner_zn).cbType.wrapper(),{
        DEBUG(if(cbType==null) throw "Error: Cannot assign null CbType to Listener";)

        var body = pr(inner_zn);
        if(body.cbType==null || body.cbType!=cbType.pr(inner))
            body.swapCbType(cbType.pr(inner));
    })

    property(handler,Body->Void,pr(inner_zn).handler,pr(inner_zn).handler = handler)

    ///---------------------------------------------------------------------------------------------

	flibopts(1)
    public function new(event:CbEvent, cbType:CbType, ?handler:Body->Void=null) {
        PR(Listener).internal = true; super(); PR(Listener).internal = false;

        var xevent = -1;
        if     (event==CbEvent.WAKE)  xevent = Flag(CbEvent,WAKE);
        else if(event==CbEvent.SLEEP) xevent = Flag(CbEvent,SLEEP);
        DEBUG(else throw "Error: cbEvent '"+event.toString()+"' is not a valid event type for a BodyListener";)
        DEBUG(if(cbType==null) throw "Error: BodyListener cbType cannot be null";)

        pr(inner_zn) = new PR(BodyListener)(xevent,handler);
        pr(inner) = pr(inner_zn);
        pr(inner).outer = this;
        pr(inner_zn).outer_zn = this;

        this.cbType = cbType;
    }
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class ConstraintListener extends Listener {
    public var pr(inner_zn):PR(ConstraintListener);

    property(cbType,CbType,pr(inner_zn).cbType.wrapper(),{
        DEBUG(if(cbType==null) throw "Error: Cannot assign null CbType to Listener";)

        var con = pr(inner_zn);
        if(con.cbType==null || con.cbType!=cbType.pr(inner))
            con.swapCbType(cbType.pr(inner));
    })

    property(handler,Constraint->Void,pr(inner_zn).handler,pr(inner_zn).handler = handler)

    ///---------------------------------------------------------------------------------------------

	flibopts(1)
    public function new(event:CbEvent, cbType:CbType, ?handler:Constraint->Void=null) {
        PR(Listener).internal = true; super(); PR(Listener).internal = false;

        var xevent = -1;
        if     (event==CbEvent.WAKE)  xevent = Flag(CbEvent,WAKE);
        else if(event==CbEvent.SLEEP) xevent = Flag(CbEvent,SLEEP);
        else if(event==CbEvent.BREAK) xevent = Flag(CbEvent,BREAK);
        DEBUG(else throw "Error: cbEvent '"+event.toString()+"' is not a valid event type for a ConstraintListener";)
        DEBUG(if(cbType==null) throw "Error: ConstraintListener cbType cannot be null";)

        pr(inner_zn) = new PR(ConstraintListener)(xevent,handler);
        pr(inner) = pr(inner_zn);
        pr(inner).outer = this;
        pr(inner_zn).outer_zn = this;

        this.cbType = cbType;
    }
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class InteractionListener extends Listener {
	public var pr(inner_zn):PR(InteractionListener);

	property(cbType1,CbType,pr(inner_zn).cb1.wrapper(),{
		DEBUG(if(cbType1==null) throw "Error: Cannot assign null CbType to Listener";)

		var con = pr(inner_zn);
		if(con.cb1==null || con.cb1!=cbType1.pr(inner))
			con.swapCbType(1, cbType1.pr(inner));
	})
	property(cbType2,CbType,pr(inner_zn).cb2.wrapper(),{
		DEBUG(if(cbType2==null) throw "Error: Cannot assign null CbType to Listener";)

		var con = pr(inner_zn);
		if(con.cb2==null || con.cb2!=cbType2.pr(inner))
			con.swapCbType(2, cbType2.pr(inner));
	})

	property(interactionType,InteractionType,{
		var ret = pr(inner_zn).itype;
		if  (ret==Flag(InteractionType,COLLISION)) InteractionType.COLLISION;
		elif(ret==Flag(InteractionType,SENSOR))    InteractionType.SENSOR;
		elif(ret==Flag(InteractionType,FLUID))     InteractionType.FLUID;
		elif(ret==Flag(InteractionType,ANY))       InteractionType.ANY;
		else null;
	},{
        DEBUG(if(interactionType==null) throw "Error: Cannot set listener interaction type to null";)
        if(this.interactionType!=interactionType) {
            var xtype = interactionType == InteractionType.COLLISION ? Flag(InteractionType,COLLISION) :
                        interactionType == InteractionType.SENSOR    ? Flag(InteractionType,SENSOR)    :
                        interactionType == InteractionType.FLUID     ? Flag(InteractionType,FLUID)     :
                        Flag(InteractionType,ANY);
			pr(inner_zn).settype(xtype);
        }
	})

    property(handler,Interactor->Interactor->ArbiterList->Void,pr(inner_zn).handleri,pr(inner_zn).handleri = handler)

    ///---------------------------------------------------------------------------------------------

	flibopts(1)
	public function new(event:CbEvent, interactionType:InteractionType, cbType1:CbType, cbType2:CbType, ?handler:Interactor->Interactor->ArbiterList->Void=null) {
		PR(Listener).internal = true; super(); PR(Listener).internal = false;

		DEBUG(if(event==null) throw "Error: CbEvent cannot be null for InteractionListener";)
		var xevent = -1;
		if     (event==CbEvent.BEGIN)   xevent = Flag(CbEvent,BEGIN);
		else if(event==CbEvent.END)     xevent = Flag(CbEvent,END);
		else if(event==CbEvent.ONGOING) xevent = Flag(CbEvent,ONGOING);
		DEBUG(else throw "Error: CbEvent '"+event.toString()+"' is not a valid event type for InteractionListener";)
		
		DEBUG(if(cbType1==null) throw "Error: InteractionListener cbType1 cannot be null";)
		DEBUG(if(cbType2==null) throw "Error: InteractionListener cbType2 cannot be null";)

		pr(inner_zn) = new PR(InteractionListener)(xevent,Flag(ListenerType,INTERACTION));
		pr(inner) = pr(inner_zn);
		pr(inner).outer = this;
		pr(inner_zn).outer_zni = this;

		pr(inner_zn).handleri = handler;
		this.cbType1 = cbType1;
		this.cbType2 = cbType2;
		this.interactionType = interactionType;
	}
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PreListener extends Listener {
	public var pr(inner_zn):PR(InteractionListener);

	property(cbType1,CbType,pr(inner_zn).cb1.wrapper(),{
		DEBUG(if(cbType1==null) throw "Error: Cannot assign null CbType to Listener";)

		var con = pr(inner_zn);
		if(con.cb1==null || con.cb1!=cbType1.pr(inner))
			con.swapCbType(1, cbType1.pr(inner));
	})
	property(cbType2,CbType,pr(inner_zn).cb2.wrapper(),{
		DEBUG(if(cbType2==null) throw "Error: Cannot assign null CbType to Listener";)

		var con = pr(inner_zn);
		if(con.cb2==null || con.cb2!=cbType1.pr(inner))
			con.swapCbType(2, cbType2.pr(inner));
	})

	//do not need to wake bodies here!
	//the contract of ACCEPT/IGNORE are that you hand control over to nape
	//and have no further say, so any change to output is not in the domain of accepted behaviour
	//
	//in the case of #_ONCE, the objects are forced to stay awake (in space)
	//and so any change to handler does not need to wake any objects already.
	property(handler,Arbiter->PreFlag,pr(inner_zn).handlerp,{
		DEBUG(if(handler==null) throw "Error: PreListener must take a non-null handler!";)
		pr(inner_zn).handlerp = handler;

		//we do not check that handler is not the same, as we want to allow this to be used
		//to notify nape of a change to a non-pure handler that user has decided to say is pure
		//anyways!

		pr(inner_zn).wake();
	})

	//pure handlers allows nape to make optimisations, specifically allowing bodies to sleep
	//even if there is a pre-handler returning IGNORE_ONCE or ACCEPT_ONCE where otherwise
	//we cannot allow the bodies to sleep as the handler may change it's return.
	property(pure,Bool,pr(inner_zn).pure,{
		if(!pure)
			pr(inner_zn).wake();
		pr(inner_zn).pure = pure;
	})

	property(interactionType,InteractionType,{
		var ret = pr(inner_zn).itype;
		if  (ret==Flag(InteractionType,COLLISION)) InteractionType.COLLISION;
		elif(ret==Flag(InteractionType,SENSOR))    InteractionType.SENSOR;
		elif(ret==Flag(InteractionType,FLUID))     InteractionType.FLUID;
		elif(ret==Flag(InteractionType,ANY))       InteractionType.ANY;
		else null;
	},{
        DEBUG(if(interactionType==null) throw "Error: Cannot set listener interaction type to null";)
        if(this.interactionType!=interactionType) {
            var xtype = interactionType == InteractionType.COLLISION ? Flag(InteractionType,COLLISION) :
                        interactionType == InteractionType.SENSOR    ? Flag(InteractionType,SENSOR)    :
                        interactionType == InteractionType.FLUID     ? Flag(InteractionType,FLUID)     :
                        Flag(InteractionType,ANY);
			pr(inner_zn).settype(xtype);
        }
	})

    ///---------------------------------------------------------------------------------------------

	flibopts(1)
	public function new(interactionType:InteractionType, cbType1:CbType, cbType2:CbType, handler:Arbiter->PreFlag, ?pure=false) {
		PR(Listener).internal = true; super(); PR(Listener).internal = false;

		DEBUG(if(cbType1==null) throw "Error: PreListener CbType1 cannot be null";)
		DEBUG(if(cbType2==null) throw "Error: PreListener CbType2 cannot be null";)

		DEBUG(if(handler==null) throw "Error: PreListener must take a handler!";)

		pr(inner_zn) = new PR(InteractionListener)(Flag(CbEvent,PRE),Flag(ListenerType,PRE));
		pr(inner) = pr(inner_zn);
		pr(inner).outer = this;
		pr(inner_zn).outer_znp = this;

		pr(inner_zn).pure = pure;
		pr(inner_zn).handlerp = handler;
		this.cbType1 = cbType1;
		this.cbType2 = cbType2;
		this.interactionType = interactionType;
	}
}
