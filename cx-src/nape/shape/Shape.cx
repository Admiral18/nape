package nape.shape;
$(import);

Flags(ShapeType,
	prop(CIRCLE,0)
	prop(POLYGON,1)
)

//--------------------------------------------------------------------------------------------------

WrapList(Shape,List(PR(Shape)),Node(PR(Shape)),$(mixin closure(x) x.outer) $(mixin erusolc(x) x.pr(inner)))

class Shape extends Interactor {
	public var pr(inner):PR(Shape);
	
    property(type,ShapeType,{
		Destroyed(this,Shape)
        [ShapeType.CIRCLE,ShapeType.POLYGON][pr(inner).type];
    })
	
	keep public function isCircle () {
		Destroyed(this,Shape)
		return pr(inner).isCircle();
	}
	keep public function isPolygon() {
		Destroyed(this,Shape)
		return pr(inner).isPolygon();
	}
	
	//----------------------------------------------------------------------------------------------
	
	function new() {
		DEBUG(try { super(); } catch (e:Dynamic) {})
		RELEASE(super();)

		DEBUG(throw "Error: Shape cannot be instantiated derp!";)
	}

	public override function destroy(recursive:Bool=false) {
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::destroy()");
		DEBUG(
			if(body!=null) throw "Error: Cannot destroy a Shape that is inside a Body, remove it first";
		)

		pr(inner).__destroy();
		pr(inner) = null;
	}
	
	//----------------------------------------------------------------------------------------------
	
    property(body,Body,{
		Destroyed(this,Shape)
		if(pr(inner).body!=null) pr(inner).body.outer else null;
	},{
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::body");
		if(this.body!=body) {
			if(pr(inner).body!=null) this.body.shapes.remove(this);
			if(body!=null) body.shapes.add(this);
		}
	})
	
    property(castCircle, Circle, {
		Destroyed(this,Shape)
		if(isCircle())  pr(inner).circle.outer_zn  else null;
	})
	property(castPolygon,Polygon, {
		Destroyed(this,Shape)
		if(isPolygon()) pr(inner).polygon.outer_zn else null;
	})

	//----------------------------------------------------------------------------------------------
	
	property(worldCOM,Vec2,{
		Destroyed(this,Shape)
		if(pr(inner).wrap_worldCOM==null) {
			pr(inner).wrap_worldCOM = Vec2.get(pr(inner).worldCOMx,pr(inner).worldCOMy);
			pr(inner).wrap_worldCOM.pr(inner).inuse = true;
			pr(inner).wrap_worldCOM.pr(inner).immutable = true;
			pr(inner).wrap_worldCOM.pr(inner)._validate = pr(inner).getworldCOM;
		}
		pr(inner).wrap_worldCOM;
	})
	
	property(localCOM,Vec2,{
		Destroyed(this,Shape)
		if(pr(inner).wrap_localCOM==null) {
			if(isCircle()) pr(inner).circle.setupLocalCOM();
			else           pr(inner).polygon.setupLocalCOM();
		}
		pr(inner).wrap_localCOM;
	},{
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Body::localCOM");
		Destroyed(localCOM,Vec2);
		DEBUG(if(localCOM==null) throw "Error: Shape::localCOM cannot be null";)
        this.localCOM.set(localCOM);
    })
	
	//----------------------------------------------------------------------------------------------
	
    property(area,   Float, { Destroyed(this,Shape) pr(inner).validate_area_inertia(); pr(inner).area;    })
    property(inertia,Float, { Destroyed(this,Shape) pr(inner).validate_area_inertia(); pr(inner).inertia; })
    property(angDrag,Float, { Destroyed(this,Shape) pr(inner).validate_angDrag();      pr(inner).angDrag; })

	//----------------------------------------------------------------------------------------------
	
    property(material,Material,{
		Destroyed(this,Shape)
		pr(inner).material.wrapper();
	},{
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::material");
        DEBUG(if(material==null) throw "Error: Cannot assign null as Shape material";)
        pr(inner).setMaterial(material.pr(inner));
    })
	
    property(filter,InteractionFilter,{
		Destroyed(this,Shape)
		pr(inner).filter.wrapper();
	},{
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::filter");
		DEBUG(if(filter==null) throw "Error: Cannot assign null as Shape filter";)
		pr(inner).setFilter(filter.pr(inner));
	})
	
    property(fluidProperties,FluidProperties,{
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::fluidProperties");
		if(pr(inner).fluidProperties==null) pr(inner).setFluid(new FluidProperties().pr(inner));
		pr(inner).fluidProperties.wrapper();
	},{
		Destroyed(this,Shape)
		DEBUG(if(fluidProperties==null) throw "Error: Cannot assign null as Shape fluidProperties, disable fluids by setting fluidEnabled to false";)
		pr(inner).setFluid(fluidProperties.pr(inner));
	})
	
    property(fluidEnabled,Bool,{
		Destroyed(this,Shape)
		pr(inner).fluidEnabled;
	},{
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::fluidEnabled");
		pr(inner).fluidEnabled = fluidEnabled;
		if(fluidEnabled && pr(inner).fluidProperties==null) this.fluidProperties = new FluidProperties();
		pr(inner).wake();
	})
	
	//----------------------------------------------------------------------------------------------
   
    property(bounds,AABB,{
		Destroyed(this,Shape)
		pr(inner).aabb.wrapper();
	})
	
	//----------------------------------------------------------------------------------------------
	
	keep public function translate(displacement:Vec2) {
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::translate()");
		Destroyed(displacement,Vec2);
		DEBUG(
			if(pr(inner).body!=null && pr(inner).body.space!=null && pr(inner).body.isStatic())
				throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
			if(displacement==null) throw "Error: Cannot displace Shape by null Vec2";
		)
		if(displacement.lsq() > 0) {
			if(isCircle()) pr(inner).circle.__translate(displacement.x,displacement.y);
			else           pr(inner).polygon.__translate(displacement.x,displacement.y);
		}
		WEAK(displacement);
	}
	keep public function scale(scalex:Float,scaley:Float) {
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::scale()");
		DEBUG(
            if(pr(inner).body!=null && pr(inner).body.space!=null && pr(inner).body.isStatic())
                    throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
                if(isNaN(scalex) || isNaN(scaley)) throw "Error: Cannot scale Shape by NaN";
		)
		if(scalex!=0 && scaley!=0) {
			if(isCircle()) {
				var d = scalex*scalex-scaley*scaley;
				if(d*d<PR(Const).EPSILON) {
					pr(inner).circle.__scale(scalex,scaley);
				}DEBUG(else
					throw "Error: Cannot perform a non equal scaling on a Circle";
				)
			}else pr(inner).polygon.__scale(scalex,scaley);
		}
	}
	keep public function rotate(angle:Float) {
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::rotate()");
		DEBUG(
			if(pr(inner).body!=null && pr(inner).body.space!=null && pr(inner).body.isStatic())
				throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
			if(isNaN(angle)) throw "Error: Cannot rotate Shape by NaN";
		)
		var dr = angle%(2*Math.PI);
		if(dr!=0.0) {
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);
			if(isCircle()) pr(inner).circle.__rotate(sin,cos);
			else           pr(inner).polygon.__rotate(sin,cos);
		}
	}
	
	keep public function transform(matrix:Mat23) {
		Destroyed(this,Shape)
		pr(inner).immutable_midstep("Shape::transform()");
		DEBUG(
			if(pr(inner).body!=null && pr(inner).body.space!=null && pr(inner).body.isStatic())
				throw "Error: Cannot modify Shape belonging to a static Object once inside a Space";
			if(matrix==null) throw "Error: Cannot transform Shape by null matrix";
			if(matrix.singular()) throw "Error: Cannot transform Shape by a singular matrix";
		)
		
		if(isCircle()) {
			if(matrix.equiorthogonal()) {
				pr(inner).circle.__transform(matrix);
			}DEBUG(else
				throw "Error: Cannot transform Circle by a non equiorthogonal matrix";
			)
		}else
			pr(inner).polygon.__transform(matrix);
	}
	
	//----------------------------------------------------------------------------------------------

	keep public function contains(point:Vec2) {
		Destroyed(this,Shape)
		Destroyed(point,Vec2);
		DEBUG(if(point==null) throw "Cannot check null point for containment";)
		DEBUG(if(body==null) throw "Error: Shape is not well defined without a Body";)	

		PR(Geom).validateShape(pr(inner));
		return PR(Collide).shapeContains(pr(inner),point.pr(inner));
	}

	//----------------------------------------------------------------------------------------------
	
	keep public static function copy(shape:Shape) {
		Destroyed(shape,Shape)
		DEBUG(if(shape==null)
			throw "Error: Cannot copy null Shape";
		)
		var ret = shape.pr(inner).copy();
		ret.userData = shape.userData;
		return ret;
	}
	
	//----------------------------------------------------------------------------------------------
	
	@:$keep public override function toString() {
		Destroyed(this,Shape)
		var ret = isCircle() ? "Circle" : "Polygon";
		return ret + "#" + id;
	}
}
