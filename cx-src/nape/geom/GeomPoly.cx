package nape.geom;
$(import);

$(mixin Vertex() PR(GeomVert));

Flags(Winding,
	prop(UNDEFINED,0)
	prop(CLOCKWISE,1)
	prop(ANTICLOCKWISE,2)
)

WrapList(GeomPoly,List(PR(GeomPoly)),Node(PR(GeomPoly)),$(mixin closure(x) x.outer) $(mixin erusolc(x) x.pr(inner)))

geom(

class GeomPoly {
	$(mixin verts() pr(inner).vertices);
	public var pr(inner):PR(GeomPoly);

	public inline function empty() return mix_circular(Vertex,empty(verts))
	public inline function size () return mix_circular(Vertex,size(verts))

	public inline function push(x:Vec2) {
		DEBUG(if(x==null) throw "Error: Cannot push null vertex";)
		Disposed(x,Vec2);

		mix_circular(Vertex,
			verts = push_after(verts, Vertex.get(x.x,x.y));
		)
	}
	public inline function pop():Vec2 {
		mix_circular(Vertex,
			DEBUG(if(empty(verts)) throw "Error: Cannot pop from empty polygon";)
			var retv = verts;
			verts = pop_ret_before(verts);
			var ret = Vec2.get(retv.x,retv.y);
			Free(Vertex,retv);
			return ret;
		)
	}

	public inline function unshift(x:Vec2) {
		DEBUG(if(x==null) throw "Error: Cannot unshift null vertex";)
		Disposed(x,Vec2);

		mix_circular(Vertex,
			verts = push_before(verts, Vertex.get(x.x,x.y));
		)
	}
	public inline function shift() {
		mix_circular(Vertex,
			DEBUG(if(empty(verts)) throw "Error: Cannot shift from empty polygon";)
			var retv = verts;
			verts = pop_ret_after(verts);
			var ret = Vec2.get(retv.x,retv.y);
			Free(Vertex,retv);
			return ret;
		)
	}

	public function skip_forward(times:Int) {
		mix_circular(Vertex,
			if(!empty(verts)) {
				if(times>0) {
					while(times-->0) verts = verts.next;
				}elif(times<0) {
					while(times++<0) verts = verts.prev;
				}
			}
		)
	}
	public function skip_backwards(times:Int) skip_forward(-times)

	public function erase(count:Int) {
		mix_circular(Vertex,
			while(count!=0 && !empty(verts)) {
				var retv = verts;
				if(count>0) {
					verts = pop_ret_after(verts);
					count--;
				}elif(count<0) {
					verts = pop_ret_before(verts);
					count++;
				}
				Free(Vertex,retv);
			}
		)
	}

	public function copy() {
		var ret = new GeomPoly();
		mix_circular(Vertex,
			for_iter(v, verts, ret.verts = push_after(ret.verts, Vertex.get(v.x,v.y)));
		)
	}

	public function new(vertices:Array<Vec2>=null) {
		pr(inner) = new PR(GeomPoly)(this);
		if(vertices!=null) {
			mix_circular(Vertex,
				for(v in vertices)
					verts = push_after(verts, Vertex.get(v.x,v.y)); 
			)
		}
	}
	@:$keep public function toString() {
		var ret = "GeomPoly[";
		mix_circular(PR(GeomVert),{
			for_iter(v, verts, {
				if(v.prev!=verts) ret += ",";
				ret += "{"+v.x+","+v.y+"}";
			});
		})
		return ret+"]";
	}

	$(mixin size_lt_3() ({
		verts == null || verts.next == null || verts.prev == verts.next;
	}));

	public function area() {
		return if(size_lt_3) 0.0;
		else area(verts);
	}

	public function winding() {
		return if(size_lt_3) Winding.UNDEFINED
		else {
			var area = signed_area(verts);
			if  (area >0) Winding.CLOCKWISE;
			elif(area==0) Winding.UNDEFINED;
			else          Winding.ANTICLOCKWISE;
		}
	}

	public function isClockwise() return winding()==Winding.CLOCKWISE

	public function isConvex() {
		return if(size_lt_3) true;
		else convex(verts);
	}

	public function isMonotone() {
		return if(size_lt_3) true
		else PR(Monotone).isMonotone(verts);
	}

	public function isSimple() {
		return if(size_lt_3) true;
		else PR(Simple).isSimple(verts);
	}

	public function isDegenerate() {
		return if(size_lt_3) true;
		else area() < PR(Const).EPSILON;
	}

	public function simple_decomposition() {
		DEBUG(if(isDegenerate()) throw "Error: Cannot decompose a degenerate polygon";)
		var MPs = PR(Simple).decompose(verts);
		var ret = new GeomPolyList();
		Iter(MP, MPs, {
			var x = new GeomPoly();
			x.verts = MP;
			ret.add(x);
		});
		return ret;
	}

	public function convex_decomposition() {
		DEBUG(if(isDegenerate()) throw "Error: Cannot decompose a degenerate polygon";)
		DEBUG(if(!isSimple()) throw "Error: Cannot perform a convex decomposition of a non-simple polygon, consider use of simple_decomposition first";)
		var MPs = PR(Greene).decompose(verts);
		var ret = new GeomPolyList();
		Iter(MP, MPs, {
			var x = new GeomPoly();
			x.verts = MP;
			ret.add(x);
		});
		return ret;
	}
	public function monotone_decomposition() {
		DEBUG(if(isDegenerate()) throw "Error: Cannot decompose a degenerate polygon";)
		DEBUG(if(!isSimple()) throw "Error: Cannot perform a monotone decomposition of a non-simple polygon, consider use of simple_decomposition first";)
		var MPs = PR(Monotone).decompose(verts);
		var ret = new GeomPolyList();
		Iter(MP, MPs, {
			var x = new GeomPoly();
			x.verts = MP;
			ret.add(x);
		});
		return ret;
	}

	public function toArray() {
		var ret = new Array<Vec2>();
		mix_circular(Vertex,
			for_iter(p,verts,ret.push(Vec2.get(p.x,p.y)));
		)
		return ret;
	}
}

)
