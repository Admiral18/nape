package nape.geom;
$(import);

$(mixin Vertex() PR(GeomVert));

Flags(Winding,
	prop(UNDEFINED,0)
	prop(CLOCKWISE,1)
	prop(ANTICLOCKWISE,2)
)

WrapList(GeomPoly,List(PR(GeomPoly)),Node(PR(GeomPoly)),$(mixin closure(x) x.outer) $(mixin erusolc(x) x.pr(inner)))

geom(

class GeomVertexIterator {
	public var pr(inner):PR(GeomVertexIterator);

	public function new() {
		DEBUG(if(!PR(GeomVertexIterator).internal) throw "Error: Cannot instantiate GeomVertexIterator";)
	}

	public inline function hasNext() {
		DEBUG(if(pr(inner)==null) throw "Error: Iterator has been disposed";)
		var ret = pr(inner).ptr != pr(inner).start || pr(inner).first;
		pr(inner).first = false;
		if(!ret) 
			Free(PR(GeomVertexIterator),pr(inner));
		return ret;
	}
	public inline function next() {
		DEBUG(if(pr(inner)==null) throw "Error: Iterator has been disposed";)
		var ret = pr(inner).ptr.wrapper();
		if(pr(inner).forward)
			 pr(inner).ptr = pr(inner).ptr.next;
		else pr(inner).ptr = pr(inner).ptr.prev;
		return ret;
	}
}

class GeomPoly {
	$(mixin verts() pr(inner).vertices);
	public var pr(inner):PR(GeomPoly);

	public inline function empty() return mix_circular(Vertex,empty(verts))
	public inline function size () return mix_circular(Vertex,size(verts))

	public inline function iterator() return PR(GeomVertexIterator).get(verts,true)
	public inline function forward_iterator  () return PR(GeomVertexIterator).get(verts,true)
	public inline function backwards_iterator() return PR(GeomVertexIterator).get(verts,false)

	public inline function current() {
		DEBUG(if(empty()) throw "Error: GeomPoly is empty";)
		return verts.wrapper();
	}

	public inline function push(x:Vec2) {
		DEBUG(if(x==null) throw "Error: Cannot push null vertex";)
		Disposed(x,Vec2);

		mix_circular(Vertex,
			verts = push_after(verts, Vertex.get(x.x,x.y));
		)

		return current();
	}
	public inline function pop() {
		mix_circular(Vertex,
			DEBUG(if(empty(verts)) throw "Error: Cannot pop from empty polygon";)
			var retv = verts;
			verts = pop_ret_before(verts);
			Free(Vertex,retv);
		)
	}

	public inline function unshift(x:Vec2) {
		DEBUG(if(x==null) throw "Error: Cannot unshift null vertex";)
		Disposed(x,Vec2);

		mix_circular(Vertex,
			verts = push_before(verts, Vertex.get(x.x,x.y));
		)

		return current();
	}
	public inline function shift() {
		mix_circular(Vertex,
			DEBUG(if(empty(verts)) throw "Error: Cannot shift from empty polygon";)
			var retv = verts;
			verts = pop_ret_after(verts);
			Free(Vertex,retv);
		)
	}

	public function skip_forward(times:Int) {
		mix_circular(Vertex,
			if(!empty(verts)) {
				if(times>0) {
					while(times-->0) verts = verts.next;
				}elif(times<0) {
					while(times++<0) verts = verts.prev;
				}
			}
		)
	}
	public function skip_backwards(times:Int) skip_forward(-times)

	public function erase(count:Int) {
		mix_circular(Vertex,
			while(count!=0 && !empty(verts)) {
				var retv = verts;
				if(count>0) {
					verts = pop_ret_after(verts);
					count--;
				}elif(count<0) {
					verts = pop_ret_before(verts);
					count++;
				}
				Free(Vertex,retv);
			}
		)
	}

	public function clear() {
		mix_circular(Vertex,
			clear_with(verts, $(mixin cb(x) Free(Vertex,x)));
		)	
	}

	public function copy() {
		var ret = new GeomPoly();
		mix_circular(Vertex,
			for_iter(v, verts, ret.verts = push_after(ret.verts, Vertex.get(v.x,v.y)));
		)
		return ret;
	}

	public function new(vertices:Dynamic=null) {
		pr(inner) = new PR(GeomPoly)(this);
		if(vertices!=null)
			PolyIter(v,vertices,mix_circular(Vertex, verts = push_after(verts,Vertex.get(v.x,v.y))));
	}
	@:$keep public function toString() {
		var ret = "GeomPoly[";
		mix_circular(PR(GeomVert),{
			for_iter(v, verts, {
				if(v!=verts) ret += ",";
				ret += "{"+v.x+","+v.y+"}";
			});
		})
		return ret+"]";
	}

	$(mixin size_lt_3() ({
		verts == null || verts.next == null || verts.prev == verts.next;
	}));

	public function area() {
		return if(size_lt_3) 0.0;
		else area(verts);
	}

	public function winding() {
		return if(size_lt_3) Winding.UNDEFINED
		else {
			var area = signed_area(verts);
			if  (area >0) Winding.CLOCKWISE;
			elif(area==0) Winding.UNDEFINED;
			else          Winding.ANTICLOCKWISE;
		}
	}

	public function contains(point:Vec2) {
		DEBUG(if(point==null) throw "Error: GeomPoly::contains point cannot be null";)
		Disposed(point,Vec2);

		return contains(verts, point.x,point.y);
	}

	public function isClockwise() return winding()==Winding.CLOCKWISE

	public function isConvex() {
		return if(size_lt_3) true;
		else convex(verts);
	}

	public function isMonotone() {
		return if(size_lt_3) true
		else PR(Monotone).isMonotone(verts);
	}

	public function isSimple() {
		return if(size_lt_3) true;
		else PR(Simple).isSimple(verts);
	}

	public function isDegenerate() {
		return if(size_lt_3) true;
		else area() < PR(Const).EPSILON;
	}

	public function simplify(epsilon:Float) {
		DEBUG(if(epsilon<=0.0) throw "Error: Epsilon should be > 0 for simplifying a GeomPoly";)
		if(size_lt_3) return copy();
		else {
			var x = PR(Simplify).simplify(verts,epsilon);
			var ret = new GeomPoly();
			ret.verts = x;
			return ret;
		}
	}

	public function simple_decomposition() {
		DEBUG(if(size_lt_3) throw "Error: Cannot decompose a degenerate polygon";)
		var MPs = PR(Simple).decompose(verts);
		var ret = new GeomPolyList();
		Iter(MP, MPs, {
			var x = new GeomPoly();
			x.verts = MP;
			ret.add(x);
		});
		return ret;
	}

	public function convex_decomposition() {
		DEBUG(if(isDegenerate()) throw "Error: Cannot decompose a degenerate polygon";)
		#if (!NAPE_RELEASE_BUILD&&!NAPE_ASSERT) try { #end
			var MPs = PR(Greene).decompose(verts);
			var ret = new GeomPolyList();
			Iter(MP, MPs, {
				var x = new GeomPoly();
				x.verts = MP;
				ret.add(x);
			});
			return ret;
		#if (!NAPE_RELEASE_BUILD&&!NAPE_ASSERT)
			} catch(e:Dynamic) {
				throw "Error: Cannot decompose a non-weakly simple polygon! Consider use of the simple_decomposition() routine";
				return new GeomPolyList();
			}
		#end
	}
	public function monotone_decomposition() {
		DEBUG(if(isDegenerate()) throw "Error: Cannot decompose a degenerate polygon";)
		#if (!NAPE_RELEASE_BUILD&&!NAPE_ASSERT) try { #end
			var MPs = PR(Monotone).decompose(verts);
			var ret = new GeomPolyList();
			Iter(MP, MPs, {
				var x = new GeomPoly();
				x.verts = MP;
				ret.add(x);
			});
			return ret;
		#if (!NAPE_RELEASE_BUILD&&!NAPE_ASSERT)
			} catch(e:Dynamic) {
				throw toString();
				throw "Error: Cannot decompose a non-weakly simple polygon! Consider use of the simple_decomposition() routine";
				return new GeomPolyList();
			}
		#end
	}

	public function bounds() {
		DEBUG(if(empty()) throw "Error: empty GeomPoly has no defineable bounds";)
		vec_new(min, PR(Const).FMAX, PR(Const).FMAX);
		vec_new(max,-PR(Const).FMAX,-PR(Const).FMAX);
		for_iter(v, verts, {
			if(v.x < minx) minx = v.x;
			if(v.y < miny) miny = v.y;
			if(v.x > maxx) maxx = v.x;
			if(v.y > maxy) maxy = v.y;
		});
		return new AABB(minx,miny,maxx-minx,maxy-miny);
	}

	public function top() {
		DEBUG(if(empty()) throw "Error: empty GeomPoly has no defineable topmost vertex";)
		var min = verts;
		Iter(v, verts.next, verts, if(v.y<min.y) min = v);
		return min.wrapper();
	}
	public function bottom() {
		DEBUG(if(empty()) throw "Error: empty GeomPoly has no defineable bottommost vertex";)
		var max = verts;
		Iter(v, verts.next, verts, if(v.y>max.y) max = v);
		return max.wrapper();
	}
	public function left() {
		DEBUG(if(empty()) throw "Error: empty GeomPoly has no defineable leftmost vertex";)
		var min = verts;
		Iter(v, verts.next, verts, if(v.x<min.x) min = v);
		return min.wrapper();
	}
	public function right() {
		DEBUG(if(empty()) throw "Error: empty GeomPoly has no defineable rightmmost vertex";)
		var max = verts;
		Iter(v, verts.next, verts, if(v.x>max.x) max = v);
		return max.wrapper();
	}
}
)
