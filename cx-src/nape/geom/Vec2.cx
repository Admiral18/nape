package nape.geom;
$(import);

//use_inline false allows sub-class PR(MixVec2List) to be defined and work transparently.
WrapList(Vec2,List(PR(Vec2)),Node(PR(Vec2)),$(mixin closure(x) x.wrapper()) $(mixin erusolc(x) x.pr(inner)) $(mixin inline() $(->)) $(mixin use_inline false) $(mixin copy_elt(x) x.copy()))

MixDerivedList(Vec2,MixList(PR(Vec2)),PR(Vec2),$(mixin closure(x) x.wrapper()) $(mixin erusolc(x) x.pr(inner)) $(mixin copy_elt(x) x.copy()))

class Vec2 {
	public var pr(inner):PR(Vec2);

	PublicMixPool(Vec2)

	$(mixin global isWEAK(x) (x.pr(inner).weak));
	$(mixin global WEAK(x) ({ if(isWEAK(x)) { x.destroy(); true; } else false; }));

	public static function weak(?x:Float=0,?y:Float=0) return get(x,y,true)
	public static function get(?x:Float=0,?y:Float=0,?weak:Bool=false) {
		DEBUG(if(isNaN(x) || isNaN(y)) throw "Error: Vec2 components cannot be NaN";)
		var ret = PublicGet(Vec2);
		if(ret.pr(inner)==null) ret.pr(inner) = PR(Vec2).get(x,y);
		else ret.setxy(x,y);
		if(weak) ret.pr(inner).weak = true;
		return ret;
	}
	public function destroy() {
		Destroyed(this,Vec2);
		DEBUG(if(pr(inner).inuse) throw "Error: This Vec2 is not destroyable";)
		pr(inner).__destroy();
	}

	public function new(?x:Float=0, ?y:Float=0) {
		DEBUG(if(isNaN(x) || isNaN(y)) throw "Error: Vec2 components cannot be NaN";)
		pr(inner) = PR(Vec2).get(x,y);
		pr(inner).outer = this;
	}
	keep public function copy(?weak:Bool=false) {
		Destroyed(this,Vec2);
		return Vec2.get(x,y,weak); 
	}

	//----------------------------------------------------------------------------------------------
	
	#if flash9
		keep public static function fromPoint(point:flash.geom.Point, ?weak:Bool=false) {
			DEBUG(
				if(point==null) throw "Error: Cannot create Vec2 from null Point object";
				if(isNaN(point.x) || isNaN(point.y))
					throw "Error: Error: Vec2 components cannot be NaN";
			)
			return Vec2.get(point.x,point.y,weak);
		}
	#end
	
	keep public static function fromPolar(length:Float,angle:Float, ?weak:Bool=false) {
		DEBUG(
			if(isNaN(length)) throw "Error: Vec2::length cannot be NaN";
			if(isNaN(angle))  throw "Error: Vec2::angle cannot be NaN";
		)
		return Vec2.get(length*Math.cos(angle),length*Math.sin(angle),weak);
	}
	
	//----------------------------------------------------------------------------------------------
	
	$(mixin comp(n)
        property(n,Float,{
			Destroyed(this,Vec2);

            pr(inner).validate();
            pr(inner).n;
        },{
			Destroyed(this,Vec2);

			DEBUG(
				if(pr(inner).immutable) throw "Error: Vec2 is immutable";
				if(pr(inner)._immutable!=null) pr(inner)._immutable();
			)
			
			if(this.n!=n) {
				DEBUG(if(isNaN(n)) throw "Error: Vec2::"+$str(n)+" cannot be NaN";)
				pr(inner).n = n;
				pr(inner).invalidate();
			}
		})
	);
	comp(x)
	comp(y)
	
	//----------------------------------------------------------------------------------------------
		
    property(length,Float,{
		Destroyed(this,Vec2);

		vec_length_slow(this.);
	},{
		Destroyed(this,Vec2);

		DEBUG(
			if(pr(inner).immutable) throw "Error: Vec2 is immutable";
		
			if(isNaN(length)) throw "Error: Vec2::length cannot be NaN";
			if(vec_lsq(this.)==0) throw "Error: Cannot set length of a zero vector";
		)
		vec_muleq(this., length/vec_length_slow(this.));
		pr(inner).invalidate();
	})
	
	keep public function lsq() {
		Destroyed(this,Vec2);

		return vec_lsq(this.);
	}
	
	//----------------------------------------------------------------------------------------------
	
	public function set(p:Vec2) {
		Destroyed(this,Vec2);
		Destroyed(p,Vec2);

		DEBUG(
			if(pr(inner).immutable) throw "Error: Vec2 is immutable";
		
			if(p==null) throw "Error: Cannot assign null Vec2";
		)
		var ret = setxy(p.x,p.y);
		WEAK(p);
		return ret;
	}
	public function setxy(x:Float,y:Float) {
		Destroyed(this,Vec2);

		DEBUG(
			if(pr(inner).immutable) throw "Error: Vec2 is immutable";
		
			if(isNaN(x) || isNaN(y)) throw "Error: Vec2 components cannot be NaN";
		)
		if(!vec_eq(this.,$(->))) {
			vec_set(pr(inner).,$(->));
			pr(inner).invalidate();
		}
		return this;
	}
	
	//----------------------------------------------------------------------------------------------
	
    property(angle,Float, {
		Destroyed(this,Vec2);

		if(x==y && x==0) 0.0 else Math.atan2(y,x);
	},{
		Destroyed(this,Vec2);

		DEBUG(
			if(pr(inner).immutable) throw "Error: Vec2 is immutable";
		
			if(isNaN(angle))  throw "Error: Vec2::angle cannot be NaN";
		)
		var l = length;
		setxy(l*Math.cos(angle),l*Math.sin(angle));
	})

	keep public function rotate(angle:Float) {
		Destroyed(this,Vec2);
		DEBUG(if(isNaN(angle)) throw "Error: Cannot rotate Vec2 by NaN";)

		var ax = Math.sin(angle);
		var ay = Math.cos(angle);
		vec_rotateq(pr(inner).,a);

		return this;
	}
	
	//----------------------------------------------------------------------------------------------
	
	keep public function add  (a:Vec2, ?weak:Bool=false) {
		Destroyed(this,Vec2);
		Destroyed(a,Vec2);

		DEBUG(if(a==null) throw "Error: Cannot add null vectors";)
		var ret = Vec2.get(vec_iadd($(->),a.),weak);
		WEAK(a);
		return ret;
	}
	keep public function sub  (a:Vec2, ?weak:Bool=false) {
		Destroyed(this,Vec2);
		Destroyed(a,Vec2);

		DEBUG(if(a==null) throw "Error: Cannot subtract null vectors";)
		var ret = Vec2.get(vec_isub($(->),a.),weak);
		WEAK(a);
		return ret;
	}
	keep public function mul (s:Float, ?weak:Bool=false) {
		Destroyed(this,Vec2);

		DEBUG(if(isNaN(s)) throw "Error: Cannot multiply with NaN";)
		return Vec2.get(vec_imul($(->),s),weak);
	}
	keep public function addeq(a:Vec2) {
		Destroyed(this,Vec2);
		Destroyed(a,Vec2);

		DEBUG(
			if(pr(inner).immutable) throw "Error: Vec2 is immutable";
			if(a==null) throw "Error: Cannot add null vectors";
		)
		var ret = setxy(vec_iadd($(->),a.));
		WEAK(a);
		return ret;
	}
	keep public function subeq(a:Vec2) {
		Destroyed(this,Vec2);
		Destroyed(a,Vec2);

		DEBUG(
			if(pr(inner).immutable) throw "Error: Vec2 is immutable";
			if(a==null) throw "Error: Cannot subtract null vectors";
		)
		var ret = setxy(vec_isub($(->),a.));
		WEAK(a);	
		return ret;
	}
	keep public function muleq(s:Float) {
		Destroyed(this,Vec2);

		DEBUG(
			if(pr(inner).immutable) throw "Error: Vec2 is immutable";
			if(isNaN(s)) throw "Error: Cannot multiply with NaN";
		)
		return setxy(vec_imul($(->),s));
	}
	keep public function dot  (a:Vec2) {
		Destroyed(this,Vec2);
		Destroyed(a,Vec2);

		DEBUG(if(a==null) throw "Error: Cannot take dot product with null vector";)
		var ret = vec_dot($(->),a.);
		WEAK(a);
		return ret;
	}
	keep public function cross(a:Vec2) {
		Destroyed(this,Vec2);
		Destroyed(a,Vec2);

		DEBUG(if(a==null) throw "Error: Cannot take cross product with null vector";)
		var ret = vec_cross($(->),a.);
		WEAK(a);
		return ret;
	}

	keep public function perp(weak=false) {
		Destroyed(this,Vec2);
		return Vec2.get(-y,x,weak);
	}
	
	//----------------------------------------------------------------------------------------------
	
	//keep is only for swc, use standard metadata
	@:$keep public function toString() {
		Destroyed(this,Vec2);

		pr(inner).validate();
		return pr(inner).toString();
	}
}
