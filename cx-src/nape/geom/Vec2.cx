package nape.geom;
$(import);

!!/**
!! * 2 Dimensional vector.
!! *
!! * Vec2 class represents a 2-dimensional vector.
!! * <br/>
!! * Note that in many cases of a Vec2 object being returned by a Nape function
!! * the Vec2 object will be marked internally as an 'immutable' Vec2. This will
!! * always be documented and trying to mutate such a Vec2 will result in an
!! * error being thrown.
!! * <br/>
!! * Vec2 objects can make use of a global object pool, attempting to make use
!! * of a disposed Vec2 will also result in an error with the object pool
!! * working in a FILO order to increase the likelihood of such misuse being
!! * caught.
!! * <br/>
!! * Additionally Vec2 objects can be created as 'weak'. Passing a weak Vec2 to
!! * any Nape function as an argument will result in the automatic disposal of
!! * the Vec2 once the method has finished with it. There may be exceptions to
!! * this rule which will also be documented; a notable case being the appending
!! * of a weak Vec2 to a Nape Vec2List in which case the disposal of the weak
!! * Vec2 is performed when that Vec2List is handed to a Nape function instead.
!! * <br/>
!! * Example:
!! * <pre>
!! * var vertices = Polygon.box(20, 20, true);
!! * var polygon = new Polygon(vertices);
!! * </pre>
!! * In this example, passing <code>true</code> to the Polygon.box method means
!! * that we will be returned a Vec2List containing only 'weak' Vec2s. Upon
!! * passing this Vec2List to the Polygon constructor, all of the Vec2s from
!! * that list will be automatically disposed.
!! */
class Vec2 {
    !!/**
    !! * @private
    !! */
    public var pr(inner):PR(Vec2);

    // Vec2 is poolable as a public object.
    PublicMixPool(Vec2)

    //
    // Global macros to facilitate auto disposal of weak Vec2's
    //
    $(mixin global isWEAK(x) ({
        /*return*/ x.pr(inner).weak;
    }));
    $(mixin global WEAK(x) ({
        if (isWEAK(x)) {
            x.dispose();
            /*return*/ true;
        }
        else {
            /*return*/ false;
        }
    }));

    !!/**
    !! * Allocate a weak Vec2 from global object pool.
    !! *
    !! * Allocates a Vec2 from the global object pool which will be automaticaly
    !! * released back to the object pool when supplied as an argument to a Nape
    !! * function.
    !! * <br/>
    !! * Note that <code>Vec2.weak(x, y)</code> is exactly equivalent to <code>
    !! * Vec2.get(x, y, true)</code>.
    !! *
    !! * @param x The x coordinate for the vector. (default 0)
    !! * @param y The y coordiante for the vector. (default 0)
    !! * @return  The allocated weak Vec2 with given x/y values.
    !! */
    public static inline function weak(x:Float = 0, y:Float = 0):Vec2 {
        return get(x, y, true);
    }

    !!/**
    !! * Allocate a Vec2 from the global object pool.
    !! *
    !! * Allocates a Vec2 from the global object pool.
    !! * <br/>
    !! * Note that <code>Vec2.get(x, y, true)</code> is exactly equivalent to
    !! * <code>Vec2.weak(x, y)</code> and should be preferred.
    !! *
    !! * @param x    The x coordinate for the vector. (default 0)
    !! * @param y    The y coordinate for the vector. (default 0)
    !! * @param weak If true, then a weak Vec2 will be allocated which will be
    !! *             automatically released to object pool when passed as an
    !! *             argument to a Nape function. (default false)
    !! * @return     The allocated, possibly weak Vec2 with given x/y values.
    !! */
    public static function get(x:Float = 0, y:Float = 0, weak:Bool = false):Vec2 {
        DEBUG(
            if (isNaN(x) || isNaN(y)) {
                throw "Error: Vec2 components cannot be NaN";
            }
        )

        var ret = PublicGet(Vec2);
        if (ret.pr(inner) == null) {
            ret.pr(inner) = PR(Vec2).get(x, y);
            ret.pr(inner).outer = ret;
        }else
        {
            ret.setxy(x, y);
        }

        ret.pr(inner).weak = weak;

        return ret;
    }

    !!/**
    !! * Release this Vec2 to global object pool.
    !! *
    !! * Release this Vec2 to the global object pool. Once diposed this Vec2
    !! * will be accessible to Nape internals for re-allocation and should
    !! * not be touched (Good practice would be to set any references to this
    !! * Vec2 to null to help ensure this).
    !! * <br/>
    !! * In debug mode, should you attempt to access this Vec2 after disposal
    !! * and the Vec2 is still in the object pool, you will be given an Error.
    !! * The object pool operates on a First-In-Last-Out principal in debug
    !! * mode to help catch these sort of errors.
    !! * <br/>
    !! * An error will be thrown if this Vec2 is already in the object pool, or
    !! * is marked as immutable.
    !! */
    public function dispose():Void {
        Disposed(this, Vec2);
        pr(inner).immutable();

        DEBUG(
            if (pr(inner)._inuse) {
                throw "Error: This Vec2 is not disposable";
            }
        )

        var inner = pr(inner);
        pr(inner).outer = null;
        pr(inner) = null;
        PublicFree(Vec2, this);
        Free(PR(Vec2), inner);
    }

    !!/**
    !! * Construct a new Vec2.
    !! *
    !! * Construct a new Vec2, this constructor will obviously not make use of
    !! * the global object pool: <code>Vec2.get</code> should be used in
    !! * preference noting that <code>new Vec2(x, y)</code> is semantically
    !! * equivalent to <code>Vec2.get(x, y)</code>.
    !! *
    !! * @param x The x coordinate for the vector. (default 0)
    !! * @param y The y coordinate for the vector. (default 0)
    !! * @return  The newly constructed Vec2 object with given x/y values.
    !! */
    public function new(x:Float = 0, y:Float = 0) {
        DEBUG(
            if (isNaN(x) || isNaN(y)) {
                throw "Error: Vec2 components cannot be NaN";
            }
        )

        pr(inner) = PR(Vec2).get(x, y);
        pr(inner).outer = this;
    }

    !!/**
    !! * Produce a copy of this Vec2.
    !! *
    !! * Produce a possibly weak copy of this Vec2 with the same x/y values.
    !! * The Vec2 will be allocated from the global object pool.
    !! *
    !! * @param weak If true, then a weak Vec2 will be allocated which will be
    !! *             automatically released to the object pool when passed as an
    !! *             argument to any Nape function. (default false)
    !! * @return     The possibly weak copy of this Vec2.
    !! */
    keep public function copy(weak:Bool = false):Vec2 {
        Disposed(this, Vec2);
        return Vec2.get(x, y, weak);
    }

    #if flash9

    !!
    !!/**
    !! * Allocate a Vec2 from AS3 Point object.
    !! *
    !! * (flash9+) Allocates a Vec2 given an AS3 flash.geom.Point object. This
    !! * Vec2 will be allocated from the global object pool.
    !! *
    !! * @param point The AS3 Point to initialise Vec2 with, this value cannot
    !! *              be equal to null.
    !! * @param weak  If true, then a weak Vec2 will be allocated which will be
    !! *              automatically released to the object pool when passed as
    !! *              an argument to any Nape function. (default false)
    !! * @return      The possibly weak Vec2 allocated with same values as input
    !! *              Point object.
    !! */
    keep public static function fromPoint(
        point:flash.geom.Point, weak:Bool = false
    ):Vec2 {
        DEBUG(
            if (point == null) {
                throw "Error: Cannot create Vec2 from null Point object";
            }
            if (isNaN(point.x) || isNaN(point.y)) {
                throw "Error: Error: Vec2 components cannot be NaN";
            }
        )

        return Vec2.get(point.x, point.y, weak);
    }

    #end

    !!
    !!/**
    !! * Allocate a Vec2 given polar coordinates.
    !! *
    !! * Allocates a Vec2 given a pair of polar coordinates. This Vec2 will be
    !! * allocated from the global object pool.
    !! * <br/>
    !! * This method will assign x/y values equal respectively to: <code>length
    !! * &#42Math.cos(angle)</code>, <code>length&#42Math.sin(angle)</code>
    !! *
    !! * @param length The length of the Vec2. This value may be negative.
    !! * @param angle  The angle of the Vec2 as measured in radians clockwise
    !! *               from the positive x axis.
    !! * @param weak   If true, then a weak Vec2 will be allocated which will be
    !! *               automatically released to the object pool when passed as
    !! *               an argument to any Nape function. (default false)
    !! * @return       The possibly weak Vec2 allocated with given polar values.
    !! */
    keep public static function fromPolar(
        length:Float, angle:Float, weak:Bool = false
    ):Vec2 {
        DEBUG(
            if (isNaN(length)) {
                throw "Error: Vec2::length cannot be NaN";
            }
            if (isNaN(angle)) {
                throw "Error: Vec2::angle cannot be NaN";
            }
        )

        return Vec2.get(length*Math.cos(angle), length*Math.sin(angle), weak);
    }

    $(mixin comp(n)

    !!/**
    $doc($$*$$n coordinate of vector)
    !! *
    $doc($$*$$n coordinate of vector.)
    !! * <br/>
    !! * In debug mode, attempting to access or mutate this value whilst the
    !! * Vec2 is in the global object pool will result in an error.
    !! * Attempting to mutate this value for an immutable Vec2 will also result
    !! * in an error in debug mode.
    !! *
    !! * @default 0
    !! */
    property(n,Float,{
        Disposed(this, Vec2);

        pr(inner).validate();
        /*return*/ pr(inner).n;
    }, {
        Disposed(this, Vec2);
        pr(inner).immutable();

        if (this.n != n) {
            DEBUG(
                if (isNaN(n)) {
                    throw "Error: Vec2::"+$str(n)+" cannot be NaN";
                }
            )

            pr(inner).n = n;
            pr(inner).invalidate();
        }
    })

    );
    comp(x)
    comp(y)

    !!/**
    !! * Length of this Vec2.
    !! *
    !! * The length of this Vec2 in pixels. This value can be set and may
    !! * be set to negative values so that <code>length &#42= -1</code> is a
    !! * valid - if sub-optimal - way of negating a Vec2.
    !! * <br/>
    !! * In debug mode, attempting to access or mutate this value whilst the
    !! * Vec2 is in the global object pool will result in an error.
    !! * Attempting to mutate this value for an immutable Vec2 will also result
    !! * in an error in debug mode.
    !! *
    !! * @default 0
    !! */
    property(length,Float,{
        Disposed(this, Vec2);

        // TODO: Cache this value.
        vec_length_slow(this.);
    },{
        Disposed(this, Vec2);
        pr(inner).immutable();

        DEBUG(
            if (isNaN(length)) {
                throw "Error: Vec2::length cannot be NaN";
            }
            if (vec_lsq(this.) == 0) {
                throw "Error: Cannot set length of a zero vector";
            }
        )

        vec_muleq(this., length / vec_length_slow(this.));
        pr(inner).invalidate();
    })

    !!/**
    !! * Compute squared length of this Vec2.
    !! *
    !! * Computes the squared length of this Vec2.
    !! * This is exactly the same as performing <code>this.length &#42
    !! * this.length</code> except for being more effecient.
    !! * <br/>
    !! * Attempting to call this method on a Vec2 that is in the global
    !! * object pool will result in an error in debug mode.
    !! *
    !! * @return The squared length of this Vec2.
    !! */
    keep public function lsq():Float {
        Disposed(this, Vec2);

        return vec_lsq(this.);
    }

    !!/**
    !! * Set values of this Vec2 to those of the argument.
    !! *
    !! * Set the x/y values of this Vec2 to those of the Vec2 passed as
    !! * argument.
    !! * <br/>
    !! * Note that <code>set(p)</code> is semantically equivalent to
    !! * <code>setxy(p.x, p.y)</code>.
    !! * <br/>
    !! * Attempting to call this method on a Vec2 that is in the global
    !! * object pool, or is immutable will result in an error in debug
    !! * mode.
    !! * Attempting to call this method with a Vec2 as argument that is
    !! * in the global object pool will also result in an error in debug
    !! * mode.
    !! *
    !! * @param p The Vec2 to set the values of this Vec2 with. This value
    !! *          must not be null.
    !! * @return  A reference to 'this' Vec2.
    !! */
    public inline function set(p:Vec2):Vec2 {
        Disposed(this, Vec2);
        Disposed(p, Vec2);
        pr(inner).immutable();

        DEBUG(
            if (p == null) {
                throw "Error: Cannot assign null Vec2";
            }
        )
        var ret = setxy(p.x, p.y);

        WEAK(p);
        return ret;
    }

    !!/**
    !! * Set values of this Vec2 given pair of x/y values.
    !! *
    !! * Set the x/y values of this Vec2 to those given as arguments.
    !! * <br/>
    !! * Atempting to call this method on a Vec2 that is in the global
    !! * object pool, or is immutable will result in an error in debug
    !! * mode.
    !! *
    !! * @param x The x value to set this Vec2's x value to.
    !! * @param y The y value to set this Vec2's y value to.
    !! * @return  A reference to 'this' Vec2.
    !! */
    public inline function setxy(x:Float, y:Float):Vec2 {
        Disposed(this, Vec2);
        pr(inner).immutable();

        DEBUG(
            if (isNaN(x) || isNaN(y)) {
                throw "Error: Vec2 components cannot be NaN";
            }
        )
        if (!vec_eq(this., $(->))) {
            vec_set(pr(inner)., $(->));
            pr(inner).invalidate();
        }
        return this;
    }

    !!/**
    !! * Angle of this Vec2.
    !! *
    !! * The angle of this Vec2 in radians as measured clockwise from the
    !! * positive x axis. The value will be given in the range -pi to pi.
    !! * <br/>
    !! * If the x/y values of this Vec2 are both 0, then the angle value will
    !! * default to 0.
    !! * <br/>
    !! * This value can also be set (to any value) so that <code>angle +=
    !! * Math.PI</code> is a valid - if sub-optimial - way of negating a Vec2.
    !! * <br/>
    !! * In debug mode, attempting to access or mutate this value whilst the
    !! * Vec2 is in the global object pool will result in an error.
    !! * Attempting to mutate this value for an immutable Vec2 will also result
    !! * in an error in debug mode.
    !! *
    !! * @default 0
    !! */
    property(angle,Float, {
        Disposed(this, Vec2);

        //TODO: cache this value
        if (x==y && x==0) {
            /*return*/ 0.0;
        }
        else {
            /*return*/ Math.atan2(y,x);
        }
    }, {
        Disposed(this, Vec2);
        pr(inner).immutable();

        DEBUG(
            if (isNaN(angle)) {
                throw "Error: Vec2::angle cannot be NaN";
            }
        )

        var l = length;
        setxy(l*Math.cos(angle), l*Math.sin(angle));
    })

    !!/**
    !! * Rotate Vec2 in-place by given angle.
    !! *
    !! * Rotate this Vec2 by the given number of radians in the clockwise
    !! * direction.
    !! * <br/>
    !! * The Vec2 will be mutated, with it's new x/y values being the result
    !! * of the rotation.
    !! * <br/>
    !! * Attempting to call this method on a Vec2 that is in the global object
    !! * pool, or that is immutable will result in an error in debug mode.
    !! *
    !! * @param angle The number of radians to rotate Vec2 by in the clockwise
    !! *              direction.
    !! * @return A reference to 'this' Vec2.
    !! */
    keep public function rotate(angle:Float):Vec2 {
        Disposed(this, Vec2);
        pr(inner).immutable();

        DEBUG(
            if (isNaN(angle)) {
                throw "Error: Cannot rotate Vec2 by NaN";
            }
        )

        if ((angle % (Math.PI * 2)) != 0) {
            var ax = Math.sin(angle);
            var ay = Math.cos(angle);
            vec_rotateq(pr(inner)., a);
            pr(inner).invalidate();
        }

        return this;
    }

    //
    // Arithmetic
    //
    // 'add' : Add this to another vector
    // 'sub' : Subtract this and another vector
    // 'mul' : Multiply this with scalar
    // 'addeq' : Add another vector mutating this
    // 'subeq' : Subtract another vector mutating this
    // 'muleq' : Multiple with scalar mutating this
    //
    keep public function add(a:Vec2, weak:Bool = false):Vec2 {
        Disposed(this, Vec2);
        Disposed(a, Vec2);

        DEBUG(
            if(a == null) {
                throw "Error: Cannot add null vectors";
            }
        )

        var ret = Vec2.get(vec_iadd($(->), a.), weak);

        WEAK(a);
        return ret;
    }

    keep public function sub(a:Vec2, weak:Bool = false):Vec2 {
        Disposed(this, Vec2);
        Disposed(a, Vec2);

        DEBUG(
            if(a == null) {
                throw "Error: Cannot subtract null vectors";
            }
        )

        var ret = Vec2.get(vec_isub($(->), a.), weak);

        WEAK(a);
        return ret;
    }

    keep public function mul(s:Float, weak:Bool = false):Vec2 {
        Disposed(this, Vec2);

        DEBUG(
            if(isNaN(s)) {
                throw "Error: Cannot multiply with NaN";
            }
        )

        return Vec2.get(vec_imul($(->), s), weak);
    }

    keep public function addeq(a:Vec2):Vec2 {
        Disposed(this, Vec2);
        Disposed(a, Vec2);
        pr(inner).immutable();

        DEBUG(
            if(a == null) {
                throw "Error: Cannot add null vectors";
            }
        )

        var ret = setxy(vec_iadd($(->), a.));

        WEAK(a);
        return ret;
    }

    keep public function subeq(a:Vec2):Vec2 {
        Disposed(this, Vec2);
        Disposed(a, Vec2);
        pr(inner).immutable();

        DEBUG(
            if(a == null) {
                throw "Error: Cannot subtract null vectors";
            }
        )


        var ret = setxy(vec_isub($(->), a.));
        WEAK(a);
        return ret;
    }

    keep public function muleq(s:Float):Vec2 {
        Disposed(this, Vec2);
        pr(inner).immutable();

        DEBUG(
            if(isNaN(s)) {
                throw "Error: Cannot multiply with NaN";
            }
        )

        return setxy(vec_imul($(->), s));
    }

    //
    // Dot, cross and perp.
    //
    // 'dot'   : Compute dot product of this and another vector
    // 'cross' : Compute cross (perp-dot) product of this and another vector
    // 'perp'  : Produce perp vector, so that a.cross(b) == a.perp().dot(b)
    //
    keep public function dot(a:Vec2):Float {
        Disposed(this, Vec2);
        Disposed(a, Vec2);

        DEBUG(
            if(a == null) {
                throw "Error: Cannot take dot product with null vector";
            }
        )

        var ret = vec_dot($(->), a.);

        WEAK(a);
        return ret;
    }

    keep public function cross(a:Vec2):Float {
        Disposed(this, Vec2);
        Disposed(a, Vec2);

        DEBUG(
            if(a == null) {
                throw "Error: Cannot take cross product with null vector";
            }
        )

        var ret = vec_cross($(->), a.);

        WEAK(a);
        return ret;
    }

    keep public function perp(weak:Bool = false):Vec2 {
        Disposed(this, Vec2);

        return Vec2.get(-y, x, weak);
    }

    @:$keep public function toString():String {
        Disposed(this, Vec2);

        pr(inner).validate();
        return pr(inner).toString();
    }
}
