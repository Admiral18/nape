package nape.geom;
$(import);

class RayResult {
	public var normal:Vec2;
	public var distance:Float;
	public var inner:Bool;
	public var shape:Shape;
	
	flibopts(0)
	public function new(normal:Vec2, distance:Float, inner:Bool, shape:Shape) {
		DEBUG(if(!PR(Ray).internal) throw "Error: RayResult cannot be instantiated derp!";)
		
		this.normal = normal;
		this.distance = distance;
		this.inner = inner;
		this.shape = shape;
	}
	
	@:$keep public function toString() {
		return "{ shape: "+shape+" distance: "+distance +" ?inner: "+inner+" }";
	}
}

WrapList(RayResult,List(RayResult),Node(RayResult),$(mixin closure(x) x) $(mixin erusolc(x) x))

class Ray {
	public var pr(inner):PR(Ray);
	
	public var userData:Dynamic;

	public function destroy() {
		Destroyed(this,Ray)
		userData = null;
		pr(inner).__destroy();
		pr(inner) = null;
	}
	
	//----------------------------------------------------------------------------
	
    property(origin,Vec2,{
		Destroyed(this,Ray)
		pr(inner).origin;
	},{
		Destroyed(this,Ray)
		Destroyed(origin,Vec2);
        DEBUG(if(origin==null) throw "Error: Ray::origin cannot be null";)
		pr(inner).origin.set(origin);
    })

    property(direction,Vec2,{
		Destroyed(this,Ray)
		pr(inner).direction;
	},{
		Destroyed(this,Ray)
		Destroyed(direction,Vec2);
        DEBUG(
			if(direction==null) throw "Error: Ray::direction cannot be null";
			if(direction.lsq()<PR(Const).EPSILON) throw "Error: Ray::direction cannot be degenerate";
		)
		pr(inner).direction.set(direction);
		pr(inner).invalidate_dir();
    })
	
    property(maxDistance,Float,{
		Destroyed(this,Ray)
		pr(inner).maxdist;
	},{
		Destroyed(this,Ray)
        DEBUG(if(isNaN(maxDistance)) throw "Error: maxDistance cannot be NaN";)
		pr(inner).maxdist = maxDistance;
    })
	
	//----------------------------------------------------------------------------

    public function aabb() {
		Destroyed(this,Ray)
		return pr(inner).rayAABB().wrapper();
	}

    //----------------------------------------------------------------------------
	
	public function copy() {
		Destroyed(this,Ray)
		var ret = new Ray(origin,direction);
		ret.maxDistance = maxDistance;
		return ret;
	}
	
	public function at(distance:Float,?weak:Bool=false) {
		Destroyed(this,Ray)
		pr(inner).validate_dir();
		return Vec2.get(origin.x+distance*pr(inner).dirx,origin.y+distance*pr(inner).diry,weak);
	}
	
	//----------------------------------------------------------------------------
	
	flibopts(0)
	public function new(origin:Vec2, direction:Vec2) {
		Destroyed(origin,Vec2);
		Destroyed(direction,Vec2);
		pr(inner) = new PR(Ray)();
		this.origin = origin;
		this.direction = direction;
		pr(inner).maxdist = PR(Const).POSINF;
	}
	
	public static function fromSegment(start:Vec2,end:Vec2) {
		Destroyed(start,Vec2);
		Destroyed(end,Vec2);
		DEBUG(
			if(start==null) throw "Error: Ray::fromSegment::start is null";
			if(end  ==null) throw "Error: Ray::fromSegment::end is null";
		)
		var dir = end.sub(start,true);
		var ret = new Ray(start,dir);
		ret.maxDistance = Math.sqrt(vec_dsq(start.,end.));
		WEAK(start);
		WEAK(end);
		return ret;
	}
}
