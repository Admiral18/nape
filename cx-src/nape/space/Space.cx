package nape.space;
$(import);

Flags(Broadphase,
    prop(DYNAMIC_AABB_TREE, 0)
    prop(SWEEP_AND_PRUNE, 1)
)

class Space {
	public var pr(inner):PR(Space);

	property(id,Int,pr(inner).id)
	public var userData:Dynamic;
	
	//----------------------------------------------------------------------------------------------
	
    property(gravity,Vec2,{
		if(pr(inner).wrap_gravity==null) pr(inner).getgravity();
		pr(inner).wrap_gravity;
	},{
		Disposed(gravity,Vec2);
		DEBUG(if(gravity==null) throw "Error: Space::gravity cannot be null";)
        this.gravity.set(gravity);
    })

	property(broadphase,Broadphase,{
		pr(inner).bphase.is_sweep ? Broadphase.SWEEP_AND_PRUNE : Broadphase.DYNAMIC_AABB_TREE;
	})

	property(sortContacts,Bool,pr(inner).sortcontacts,{
		pr(inner).sortcontacts = sortContacts;
	})
	
	//----------------------------------------------------------------------------------------------
	
    //bodies ]= statics,dynamics,kinematics
    //dynamics ]= liveBodies
	property(compounds,CompoundList,pr(inner).wrap_compounds)
    property(bodies,    BodyList,pr(inner).wrap_bodies)
	property(liveBodies,BodyList,pr(inner).wrap_live)

    //constraints ]= liveConstraints
    property(constraints,    ConstraintList,pr(inner).wrap_constraints)
    property(liveConstraints,ConstraintList,pr(inner).wrap_livecon)

	//----------------------------------------------------------------------------------------------
	
    //for use with constraints for a world-constant anchor
    property(world,Body,pr(inner).__static)
	
	//----------------------------------------------------------------------------------------------
	
    property(arbiters,ArbiterList,{
		if(pr(inner).wrap_arbiters==null) {
			var ret = new PR(SpaceArbiterList)();
			ret.space = pr(inner);
			pr(inner).wrap_arbiters = ret;
		}
		pr(inner).wrap_arbiters;
	})
	
    //----------------------------------------------------------------------------------------------

    property(callbacks,CallbackQueue,{
        if(pr(inner).wrap_callbacks==null) {
            PR(Callback).internal = true;
            var ret = new CallbackQueue();
            PR(Callback).internal = false;
            ret.pr(inner) = pr(inner).callbacks;
            pr(inner).wrap_callbacks = ret;
        }
        pr(inner).wrap_callbacks;
    })

    property(listeners,ListenerList,pr(inner).wrap_listeners)

	//----------------------------------------------------------------------------------------------

	keep public inline function clear() {
		DEBUG(if(pr(inner).midstep) throw "Error: Space::clear() cannot be called during space step()";)
		pr(inner).clear();
	}

	//----------------------------------------------------------------------------------------------
	
	keep public function step(deltaTime:Float, ?velocityIterations:Int = 10, ?positionIterations:Int = 10) {
		DEBUG(
			if(isNaN(deltaTime)) throw "Error: deltaTime cannot be NaN"; //TVB is a cunt. ;)
			if(deltaTime<=0) throw "Error: deltaTime must be strictly positive";
			if(velocityIterations<=0) throw "Error: must use atleast one velocity iteration";
			if(positionIterations<=0) throw "Error: must use atleast one position iteration";
		)
		pr(inner).step(deltaTime,velocityIterations,positionIterations);
	}
	
    property(timeStamp,Int,pr(inner).stamp)
    property(elapsedTime,Float,pr(inner).time)

	//----------------------------------------------------------------------------------------------

	public function new(?gravity:Vec2,?broadphase:Broadphase) {
		Disposed(gravity,Vec2);
		pr(inner) = new PR(Space)(gravity==null?null:gravity.pr(inner),broadphase);
		pr(inner).outer = this;
		if(gravity!=null) WEAK(gravity);
	}
	
	//----------------------------------------------------------------------------------------------

	keep public function shapesUnderPoint(point:Vec2,?filter:InteractionFilter=null) {
		Disposed(point,Vec2);
		DEBUG(if(point==null) throw "Error: Cannot evaluate shapes under a null point :)";)
		var ret = pr(inner).shapesUnderPoint(point.x,point.y,filter==null?null:filter.pr(inner));
		WEAK(point);
		return ret;
	}
	keep public function bodiesUnderPoint(point:Vec2,?filter:InteractionFilter=null) {
		Disposed(point,Vec2);
		DEBUG(if(point==null) throw "Error: Cannot evaluate objects under a null point :)";)
		var ret = pr(inner).bodiesUnderPoint(point.x,point.y,filter==null?null:filter.pr(inner));
		WEAK(point);
		return ret;
	}

	keep public function shapesInAABB(aabb:AABB,?containment:Bool=false,?strict:Bool=true,?filter:InteractionFilter=null) {
		Destroyed(aabb,AABB)
		DEBUG(
			if(aabb==null) throw "Error: Cannot evaluate shapes in a null AABB :)";
			if(aabb.width==0 || aabb.height==0) throw "Error: Cannot evaluate shapes in degenerate AABB :/";
		)
		return pr(inner).shapesInAABB(aabb,strict,containment,filter==null?null:filter.pr(inner));
	}
	keep public function bodiesInAABB(aabb:AABB,?containment:Bool=false,?strict:Bool=true,?filter:InteractionFilter=null) {
		Destroyed(aabb,AABB)
		DEBUG(
			if(aabb==null) throw "Error: Cannot evaluate objects in a null AABB :)";
			if(aabb.width==0 || aabb.height==0) throw "Error: Cannot evaluate objects in degenerate AABB :/";
		)
		return pr(inner).bodiesInAABB(aabb,strict,containment,filter==null?null:filter.pr(inner));
	}

	keep public function shapesInCircle(position:Vec2,radius:Float,?containment:Bool=false,?filter:InteractionFilter=null) {
		Disposed(position,Vec2);
		DEBUG(
			if(position==null) throw "Error: Cannot evaluate shapes at null circle :)";
			if(isNaN(radius))  throw "Error: Circle radius cannot be NaN";
			if(radius<=0)      throw "Error: Circle radius must be strictly positive";
		)
		var ret = pr(inner).shapesInCircle(position,radius,containment,filter==null?null:filter.pr(inner));
		WEAK(position);
		return ret;
	}
	keep public function bodiesInCircle(position:Vec2,radius:Float,?containment:Bool=false,?filter:InteractionFilter=null) {
		Disposed(position,Vec2);
		DEBUG(
			if(position==null) throw "Error: Cannot evaluate objects at null circle :)";
			if(isNaN(radius))  throw "Error: Circle radius cannot be NaN";
			if(radius<=0)      throw "Error: Circle radius must be strictly positive";
		)
		var ret = pr(inner).bodiesInCircle(position,radius,containment,filter==null?null:filter.pr(inner));
		WEAK(position);
		return ret;
	}

	keep public function shapesInShape(shape:Shape,containment:Bool=false,?filter:InteractionFilter) {
		Destroyed(shape,Shape)
		DEBUG(
			if(shape==null) throw "Error: Cannot evaluate shapes in a null shapes :)";
			if(shape.body==null) throw "Error: Query shape needs to be inside a Body to be well defined :)";
			if(shape.isPolygon()) {
				var res = shape.pr(inner).polygon.valid();
				if(res!=ValidationResult.VALID)
					throw "Error: Polygon query shape is invalid : "+res.toString();
			}
		)
		return pr(inner).shapesInShape(shape.pr(inner),containment,filter == null ? null : filter.pr(inner));
	}
	keep public function bodiesInShape(shape:Shape,containment:Bool=false,?filter:InteractionFilter) {
		Destroyed(shape,Shape)
		DEBUG(
			if(shape==null) throw "Error: Cannot evaluate bodies in a null shapes :)";
			if(shape.body==null) throw "Error: Query shape needs to be inside a Body to be well defined :)";
			if(shape.isPolygon()) {
				var res = shape.pr(inner).polygon.valid();
				if(res!=ValidationResult.VALID)
					throw "Error: Polygon query shape is invalid : "+res.toString();
			}
		)
		return pr(inner).bodiesInShape(shape.pr(inner),containment,filter == null ? null : filter.pr(inner));
	}

	keep public function shapesInBody(body:Body,?filter:InteractionFilter) {
		DEBUG(if(body==null) throw "Error: Cannot evaluate shapes in null body";)
		var ret = null;
		for(shape in body.shapes) {
			var cur = shapesInShape(shape,false,filter);
			if(ret==null) ret = cur;
			else ret.merge(cur);
		}
		return if(ret==null) new ShapeList() else ret;
	}
	keep public function bodiesInBody(body:Body,?filter:InteractionFilter) {
		DEBUG(if(body==null) throw "Error: Cannot evaluate shapes in null body";)
		var ret = null;
		for(shape in body.shapes) {
			var cur = bodiesInShape(shape,false,filter);
			if(ret==null) ret = cur;
			else ret.merge(cur);
		}
		return if(ret==null) new BodyList() else ret;
	}
	
	//----------------------------------------------------------------------------------------------
	
	keep public function rayCast(ray:Ray, ?inner:Bool=false, ?filter:InteractionFilter=null) {
		Destroyed(ray,Ray)
		DEBUG(if(ray==null) throw "Error: Cannot cast null ray :)";)
		return pr(inner).rayCast(ray,inner,filter);
	}
	
	keep public function rayMultiCast(ray:Ray, ?inner:Bool=false, ?filter:InteractionFilter=null) {
		Destroyed(ray,Ray)
		DEBUG(if(ray==null) throw "Error: Cannot cast null ray :)";)
		return pr(inner).rayMultiCast(ray,inner,filter);
	}
}
