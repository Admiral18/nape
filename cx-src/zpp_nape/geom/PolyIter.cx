package zpp_nape.geom;
$(import);

//macro for iteration over a generic 'polygon' since this occurs in a few areas
//
// accept either:
//  a Vec2List
//  a GeomPoly
//  a flash.Vector<Vec2> //flash9+
// an Array<Vec2>

$(mixin global PolyFirst(polygon) (${DEBUG/1,Disposed/2,PR/1,pr/1->
	if(Std.is(polygon,Array)) {
		var lv:Array<Dynamic> = polygon;
		DEBUG(if(lv.length==0) throw "Error: Array<Vec2> is empty";)
		DEBUG(if(lv[0]==null) throw "Error: Array<Vec2> contains null objects";)
		DEBUG(if(!Std.is(lv[0],Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";)
		var ret:Vec2 = lv[0];
		Disposed(ret,Vec2);
		ret.copy();
	}#if flash9 else if(Std.is(polygon,flash.Vector)) {
		var lv:flash.Vector<Dynamic> = polygon;
		DEBUG(if(lv.length==0) throw "Error: flash.Vector<Vec2> is empty";)
		DEBUG(if(lv[0]==null) throw "Error: flash.Vector<Vec2> contains null objects";)
		DEBUG(if(!Std.is(lv[0],Vec2)) throw "Error: flash.Vector<Vec2> contains non Vec2 objects";)
		var ret:Vec2 = lv[0];
		Disposed(ret,Vec2);
		ret.copy();
	}#end
	else if(Std.is(polygon,Vec2List)) {
		var lv:Vec2List = polygon;
		DEBUG(if(lv.empty()) throw "Error: Vec2List is empty";)
		var v = lv.at(0);
		Disposed(v,Vec2);
		v.copy();
	}else if(Std.is(polygon,GeomPoly)) {
		var lv:GeomPoly = polygon;
		DEBUG(if(lv.empty()) throw "Error: GeomPoly is empty";)
		var v = lv.pr(inner).vertices;
		Vec2.get(v.x,v.y);
	}DEBUG(else
		throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash9+ flash.Vector<Vec2>";
	)
}));

//assume polygon is well formed.
$(mixin global PolyWeak(polygon) ${DEBUG/1,isWEAK/1,WEAK/1,PR/1,pr/1->
	if(Std.is(polygon,Array)) {
		var lv:Array<Vec2> = polygon;
		var i = 0;
		while(i<lv.length) {
			var cur = lv[i];
			if(WEAK(cur)) {
				lv.splice(i,1);
				continue;
			}
			i++;
		}
	}#if flash9 else if(Std.is(polygon,flash.Vector)) {
		var lv:flash.Vector<Vec2> = polygon;
		if(!lv.fixed) {
		var i:UInt = 0;
		while(i<lv.length) {
			var cur = lv[i];
			if(WEAK(cur)) {
				lv.splice(i,1);
				continue;
			}
			i++;
		}
		}
	}#end
	else if(Std.is(polygon,Vec2List)) {
		var lv:Vec2List = polygon;
		var ins = lv.pr(inner).inner;
		var pre = null;
		var cur = ins.begin();
		while(cur!=null) {
			var x = cur.elem();
			if(isWEAK(x.outer)) {
				cur = ins.erase(pre);
				WEAK(x.outer);
			}else {
				pre = cur;
				cur = cur.next;
			}
		}
	}
});

$(mixin global PolyIter(val, polygon, block) ${DEBUG/1,Disposed/2,PR/1,pr/1->
	if(Std.is(polygon,Array)) {
		var lv:Array<Dynamic> = polygon;
		for(vite in lv) {
			DEBUG(if(vite==null) throw "Error: Array<Vec2> contains null objects";)
			DEBUG(if(!Std.is(vite,Vec2)) throw "Error: Array<Vec2> contains non Vec2 objects";)
			var val:Vec2 = vite;
			Disposed(val,Vec2);
			block;
		}
	}#if flash9 else if(Std.is(polygon,flash.Vector)) {
		var lv:flash.Vector<Dynamic> = polygon;
		for(vite in lv) {
			DEBUG(if(vite==null) throw "Error: flash.Vector<Vec2> contains null objects";)
			DEBUG(if(!Std.is(vite,Vec2)) throw "Error: flash.Vector<Vec2> contains non Vec2 objects";)
			var val:Vec2 = vite;
			Disposed(val,Vec2);

			block;
		}
	}#end
	else if(Std.is(polygon,Vec2List)) {
		var lv:Vec2List = polygon;
		for(val in lv) {
			DEBUG(if(val==null) throw "Error: Vec2List contains null objects";)
			Disposed(val,Vec2);
			
			block;
		}	
	}else if(Std.is(polygon,GeomPoly)) {
		var lv:GeomPoly = polygon;
		var verts:PR(GeomVert) = lv.pr(inner).vertices;
		if(verts!=null) {
			var vite = verts;
			do {
				var val = Vec2.get(vite.x,vite.y);
				vite = vite.next;
				block;	
				val.dispose();
			}while(vite!=verts);
		}
	}DEBUG(else
		throw "Error: Invalid type for polygon object, should be Array<Vec2>, Vec2List, GeomPoly or for flash9+ flash.Vector<Vec2>";
	)
});
