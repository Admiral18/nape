package zpp_nape.geom;
$(import);

$(mixin Vertex() PR(GeomVert));

class Vertex {
	vec_new(public,$(->));
	
	MixPoolNoNext(Vertex)
	public var prev:Vertex;
	public var next:Vertex;

	public var wrap:Vec2;

	flibmdel public inline function free () {
		if(wrap!=null) {
			wrap.pr(inner).inuse = false;
			wrap.dispose();
			wrap = null;
		}
	}
	flibmdel public inline function alloc() {}

	public inline function wrapper() {
		if(wrap==null) {
			wrap = Vec2.get(x,y);
			wrap.pr(inner).inuse = true;
			wrap.pr(inner)._invalidate = modwrap;
			wrap.pr(inner)._validate = getwrap;
		}
		return wrap;
	}

	public function modwrap(n:PR(Vec2)) {
		vec_set(this.,n.);
	}
	public function getwrap() {
		vec_set(wrap.pr(inner).,this.);
	}

	public static inline function get(x:Float,y:Float) {
		var ret = Get(Vertex);
		vec_set(ret.,$(->));
		return ret;
	}
	public function new() {}
}

class PR(GeomPoly) {
	public var outer:GeomPoly;
	public var vertices:Vertex;

	public function new(outer:GeomPoly) {
		this.outer = outer;
	}
}

$(mixin global geom(block)
	block

	$(mixin contains(poly, Xx,Yy) ({
		var x = Xx;
		var y = Yy;
		var ret = false;

		mix_circular(Vertex,
			for_iter(p,poly,{
				var q = p.prev;
				if ((p.y < y && q.y>=y
				 ||  q.y < y && p.y>=y)
				 && (p.x<=x || q.x<=x)) {
					if(p.x+(y-p.y)/(q.y-p.y)*(q.x-p.x) < x)
						ret = !ret;
				}
			});
		)

		ret;
	}));

	$(mixin clone(poly) {
		var ret:Vertex = null;
		mix_circular(Vertex,
			for_iter(p,poly,ret = push_after(ret,Vertex.get(p.x,p.y)));
		)
		ret;
	});

	$(mixin assert_size_3(poly) {
		mix_circular(Vertex,
			#if NAPE_ASSERT if(size(poly)<3) throw "Error: Size of polygon less than 3 makes no sense: geom::area"; #end
		)
	});

	$(mixin signed_area(poly) ({
		assert_size_3(poly);

		var area = 0.0;
		mix_circular(Vertex,
			for_iter(v,poly,area += v.x*(v.next.y-v.prev.y));
		)
		area;
	}));
	$(mixin area(poly) ({
		var ret = signed_area(poly);
		if(ret<0) (-ret) else ret;
	}));

	$(mixin clockwise(poly) (signed_area(poly)>0.0));

	$(mixin degenerate(poly) ({
		if(poly==null || poly.next==null || poly.next==poly.prev) true;
		else { var a = signed_area(poly); a*a < PR(Const).EPSILON*PR(Const).EPSILON; }
	}));

	$(mixin convex(poly) ({
		assert_size_3(poly);
		mix_circular(Vertex,
			var neg = false;
			var pos = false;
			var ret = true;
			for_iter(v,poly,{
				var u = v.prev;
				var w = v.next;
	
				vec_new(a); vec_sub(w.,v.,a);
				vec_new(b); vec_sub(v.,u.,b);
				var dot = vec_cross(a,b);
				if  (dot>0.0) pos = true;
				elif(dot<0.0) neg = true;
	
				if(pos&&neg) { ret = false; break; }
			});
		)
		ret;
	}));
);
