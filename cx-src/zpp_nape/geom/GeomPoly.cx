package zpp_nape.geom;
$(import);

$(mixin Vertex() PR(GeomVert));

class Vertex {
	vec_new(public,$(->));
	
	MixPoolNoNext(Vertex)
	public var prev:Vertex;
	public var next:Vertex;

	public var wrap:Vec2;

	//when true this vertex will not be removed
	//by simplification
	public var forced:Bool;

	public function free () {
		if(wrap!=null) {
			wrap.pr(inner).inuse = false;
			wrap.destroy();
			wrap = null;
		}
		#if NAPE_ASSERT
			vec_set(this.,-10,-20);
		#end
		forced = false;
		assert(prev==null && next==null, "prev/next non-null PR(GeomVert) destroy");
	}
	public function alloc() {}

	public function wrapper() {
		if(wrap==null) {
			wrap = Vec2.get(x,y);
			wrap.pr(inner).inuse = true;
			wrap.pr(inner)._invalidate = modwrap;
			wrap.pr(inner)._validate = getwrap;
		}
		return wrap;
	}

	public function modwrap(n:PR(Vec2)) {
		vec_set(this.,n.);
	}
	public function getwrap() {
		vec_set(wrap.pr(inner).,this.);
	}

	public static function get(x:Float,y:Float) {
		var ret = Get(Vertex);
		vec_set(ret.,$(->));
		return ret;
	}
	public function new() {}
}

class PR(GeomPoly) {
	public var outer:GeomPoly;
	public var vertices:Vertex;
	public var iterators:List(PR(GeomVertexIterator));

	public function new(outer:GeomPoly) {
		this.outer = outer;
		iterators = new List(PR(GeomVertexIterator))();
	}

	public function destroy() {
		outer = null;
		assert(vertices==null,"non-null vertices on pr geompoly destroy");
		ClearWith(i, iterators, Free(PR(GeomVertexIterator),i));
		iterators = null;
	}
}

class PR(GeomVertexIterator) {
	public var ptr:Vertex;
	public var start:Vertex;
	public var first:Bool;
	public var forward:Bool;
	public var gpoly:PR(GeomPoly);

	public var outer:GeomVertexIterator;
	MixPool(PR(GeomVertexIterator))
	public function free() {
		outer.pr(inner) = null;
		ptr = start = null;
		gpoly.iterators.remove(this);
		gpoly = null;
	}
	public function alloc() {}

	public static var internal = false;
	function new() {
		internal = true;
		outer = new GeomVertexIterator();
		internal = false;
	}

	public static function get(gpoly:PR(GeomPoly),poly:PR(GeomVert),forward:Bool) {
		var ret = Get(PR(GeomVertexIterator));
		ret.outer.pr(inner) = ret;
		ret.ptr = poly;
		ret.forward = forward;
		ret.start = poly;
		ret.first = poly!=null;
		gpoly.iterators.add(ret);
		ret.gpoly = gpoly;
		return ret.outer;
	}
}

$(mixin global geom(block)
	block

	$(mixin contains(poly, Xx,Yy) ({
		var x = Xx;
		var y = Yy;
		var ret = false;

		mix_circular(Vertex,
			for_iter(p,poly,{
				var q = p.prev;
				if ((p.y < y && q.y>=y
				 ||  q.y < y && p.y>=y)
				 && (p.x<=x || q.x<=x)) {
					if(p.x+(y-p.y)/(q.y-p.y)*(q.x-p.x) < x)
						ret = !ret;
				}
			});
		)

		ret;
	}));

	$(mixin clone(poly) {
		var ret:Vertex = null;
		mix_circular(Vertex,
			for_iter(p,poly,ret = push_after(ret,Vertex.get(p.x,p.y)));
		)
		ret;
	});

	$(mixin assert_size_3(poly) {
		mix_circular(Vertex,
			#if NAPE_ASSERT if(size(poly)<3) throw "Error: Size of polygon less than 3 makes no sense: geom::area"; #end
		)
	});

	$(mixin signed_area(poly) ({
		assert_size_3(poly);

		var area = 0.0;
		mix_circular(Vertex,
			for_iter(v,poly,area += v.x*(v.next.y-v.prev.y));
		)
		area;
	}));
	$(mixin area(poly) ({
		var ret = signed_area(poly);
		if(ret<0) (-ret) else ret;
	}));

	$(mixin clockwise(poly) (signed_area(poly)>0.0));

	$(mixin degenerate(poly) ({
		if(poly==null || poly.next==null || poly.next==poly.prev) true;
		else { var a = signed_area(poly); a*a < PR(Const).EPSILON*PR(Const).EPSILON; }
	}));

	$(mixin convex(poly) ({
		assert_size_3(poly);
		mix_circular(Vertex,
			var neg = false;
			var pos = false;
			var ret = true;
			for_iter(v,poly,{
				var u = v.prev;
				var w = v.next;
	
				vec_new(a); vec_sub(w.,v.,a);
				vec_new(b); vec_sub(v.,u.,b);
				var dot = vec_cross(a,b);
				if  (dot>0.0) pos = true;
				elif(dot<0.0) neg = true;
	
				if(pos&&neg) { ret = false; break; }
			});
		)
		ret;
	}));
);
