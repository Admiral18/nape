package zpp_nape.geom;
$(import);

/**

	Somewhat based on CGAL y_monotone_partition_2 (www.cgal.org)

	and it's cited reference:
		Mark de Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf. Computational Geometry: Algorithms and Applications. Springer-Verlag, Berlin, 1997.
		(http://books.google.com/books?id=C8zaAWuOIOcC&pg=PA49&source=gbs_toc_r&cad=3#v=onepage&q&f=false)

	INSERT LICENCE DUMP D: .... at some point

	Various modifications/improvements made.

**/

$(mixin Vertex() PR(PartitionVertex));
$(mixin Edge() Vertex);

//vertex types
$(mixin START     0);
$(mixin SPLIT     1);
$(mixin END       2);
$(mixin MERGE     3);
$(mixin REGULAR   4);

class PR(Monotone) {
	public static inline function bisector(b:Vertex) {
		var a = b.prev;
		var c = b.next;
		vec_new(u); vec_sub(b.,a.,u);
		vec_new(v); vec_sub(c.,b.,v);
//		vec_normalise(u);
//		vec_normalise(v);
		var ret = PR(Vec2).get(-uy-vy,ux+vx);
		vec_normalise(ret.);
		if(vec_cross(u,v) < 0) vec_negate(ret.);
		return ret;
	}

	public static inline function below(p:Vertex,q:Vertex) {
		if  (p.y<q.y) return true;
		elif(p.y>q.y) return false;
		else {
			if  (p.x<q.x) return true;
			elif(p.x>q.x) return false;
			else { 
				var po = bisector(p); var qo = bisector(q);
				vec_addeq(po.,p.); vec_addeq(qo.,q.);
				var ret = po.x < qo.x || (po.x==qo.x && po.y<qo.y);
				Free(PR(Vec2),po); Free(PR(Vec2),qo);
				return ret;
			}
		}
	}
	public static inline function above(p:Vertex,q:Vertex) return below(q,p)

	//left_vertex(p) if polygon exists to the right of p.
	public static inline function left_vertex(v:Vertex) {
		var pre = v.prev;
		var nxt = v.next;
		return pre.y > v.y || (pre.y==v.y && nxt.y < v.y);
	}

	public static function isMonotone(P:PR(GeomVert)) {
	mix_circular(Vertex,
		//find min-max
		var min = P; var max = P;
		for_iter(v, P.next,P, {
			if(v.y < min.y) min = v;
			if(v.y > max.y) max = v;
		});

		var ret = true;
		//check monotonicity
		var pre = min;
		if(max!=min.next) {
			for_iter(v, min.next, max, {
				if(v.y < pre.y) { ret = false; break; }
				pre = v;
			});
		}

		if(!ret) return false;

		pre = min;
		if(max!=min.prev) {
			rev_iter(v, min.prev, max, {
				if(v.y < pre.y) { ret = false; break; }
				pre = v;
			});
		}

		return ret;
	)}

	public static function decompose(P:PR(GeomVert)) {
	mix_circular(Vertex,
		var poly = new PR(PartitionPoly)(P);

		//generate a queue to sort vertices in yx order
		//also calculate vertex types.
		var queue = new List(Vertex)();
		for_iter(p, poly.vertices, {
			queue.add(p);
			//calculate type
			vec_new(u); vec_sub(p.next.,p., u);
			vec_new(v); vec_sub(p.prev.,p., v);
			var cx = vec_cross(u,v) > 0;

			p.type = 
				if(below(p.prev,p)) {
					if(below(p.next,p)) cx ? START : SPLIT
					else REGULAR;
				}else {
					if(below(p,p.next)) cx ? END : MERGE;
					else REGULAR;
				}
		});

		//sorted set to hold interesting edges
		var edges = Get(Set(Vertex));
		edges.lt = Edge.edge_lt;
		edges.swapped = Edge.edge_swap;
		//process away!
		Sort(queue,Node(Vertex),above);
		while(!queue.empty()) {
			var v = queue.pop_unsafe();
			switch(v.type) {
				case START:
					v.helper = v;
					v.node = edges.insert(v);

				case END:
					var e = v.prev;
					DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone 1) : Polygon is not simple + CW, but was not caught sooner!";)
					if(e.helper.type == MERGE)
						poly.insert_diagonal(v,e.helper);
					edges.remove_node(e.node);
					DEBUG(e.helper=null;)

				case SPLIT:
					var e = SetLowerBound(v,edges,Vertex.vert_lt);
					if(e!=null) {
						DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone 2) : Polygon is not simple + CW, but was not caught sooner!";)
						poly.insert_diagonal(v,e.helper);
						e.helper = v;
					}

					v.node = edges.insert(v);
					v.helper = v;

				case MERGE:
					var e = v.prev;
					DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone 3) : Polygon is not simple + CW, but was not caught sooner!";)
					if(e.helper.type == MERGE)
						poly.insert_diagonal(v,e.helper);
					edges.remove_node(e.node);
					DEBUG(e.helper = null;)

					var e = SetLowerBound(v,edges,Vertex.vert_lt);
					if(e!=null) {
						DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone 4) : Polygon is not simple + CW, but was not caught sooner!";)
						if(e.helper.type == MERGE)
							poly.insert_diagonal(v,e.helper);
						e.helper = v;
					}

				case REGULAR:
					var pre = v.prev;
					if(left_vertex(v)) {
						DEBUG(if(pre.helper==null) throw "FATAL ERROR (Monotone 5) : Polygon is not simple + CW, but was not caught sooner!";)
						if(pre.helper.type == MERGE)
							poly.insert_diagonal(v,pre.helper);
						edges.remove_node(pre.node);
						DEBUG(pre.helper=null;)
						
						v.node = edges.insert(v);
						v.helper = v;

					}else {
						var e = SetLowerBound(v,edges,Vertex.vert_lt);
						DEBUG(if(e==null || e.helper==null) throw "FATAL ERROR (Monotone 6) : Polygon is not simple + CW, but was not caught sooner!";)
						if(e.helper.type == MERGE)
							poly.insert_diagonal(v,e.helper);
						e.helper = v;
					}
			}
		}

		#if NAPE_ASSERT
			var gp = new GeomPoly();
			mix_circular(PR(PartitionVertex), for_iter(v,poly.vertices,{
				gp.push(Vec2.get(v.x,v.y));
			}));

			var ret = poly.partition();
			//don't use signed area since P may have been reversed if it was not clockwise at entry
			var area = geom(area(P));

			var retarea = 0.0;
			Iter(p,ret,{
				var elm = geom(signed_area(p));
				retarea += elm;
				assert(elm>0,"Monotone output degenerate area or non-clockwise");
			});

			var darea = area-retarea;
			assert(darea*darea < PR(Const).EPSILON, "Monotone output set has different area!?");

			return ret;
		#else
			return poly.partition();
		#end
	)}

}

