package zpp_nape.geom;
$(import);

/**

	Somewhat based on CGAL y_monotone_partition_2 (www.cgal.org)

	and it's cited reference:
		Mark de Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf. Computational Geometry: Algorithms and Applications. Springer-Verlag, Berlin, 1997.
		(http://books.google.com/books?id=C8zaAWuOIOcC&pg=PA49&source=gbs_toc_r&cad=3#v=onepage&q&f=false)

	INSERT LICENCE DUMP D: .... at some point

	Various modifications/improvements made.

**/

//got sick of typing this out too many times!
$(mixin Vertex() PR(PartitionVertex));
$(mixin Edge() Vertex);

mix_circular(Vertex,
class PR(PartitionPoly) {
	public var vertices:Vertex;

	public function new(P:PR(GeomVert)) {
		var p = P;
		var cw = geom(clockwise(P));
		do {
			vec_new(u); vec_sub(p.,p.prev.,u);
			vec_new(v); vec_sub(p.next.,p.,v);
			if(vec_cross(u,v)!=0.0 || vec_dot(u,v)<0) {
				vertices = if(cw)
					push_after(vertices,Vertex.get(p));
				else
					push_before(vertices,Vertex.get(p));
			}
			p = p.next;
		}while(p!=P);
	}
	
	flibmdel public inline function insert_diagonal(p:Vertex,q:Vertex) {
		p.insert_diagonal(q);
		q.insert_diagonal(p);
	}

	public function partition() {
		for_iter(c, vertices, c.sort_diagonals());

		var rets = new List(PR(GeomVert))();
		make_polygon(vertices, rets);

		return rets;
	}

	//can we make this iterative rather than recursive?
	//yes, but probably not worth it.
	public function make_polygon(start:Vertex, rets:List(PR(GeomVert))) {
		var poly:PR(GeomVert) = null;
		var next = start;
		do {
			mix_circular(PR(GeomVert),
				poly = push_after(poly, PR(GeomVert).get(next.x,next.y));
			)
			if(!next.diagonals.empty()) {
				var diag = next.diagonals.pop_unsafe();
				if(diag==start)
					break;
				else
					next = make_polygon(next,rets);
			}else {
				var n = next.next;
				Free(Vertex,next);
				next = n;
			}
		}while(next!=start);

		assert(PR(Monotone).isMonotone(poly), "output poly is not monotone :(");
		assert(geom(clockwise(poly)),"out poly is not convex-monotone :(");
		rets.add(poly);

		return next;
	}
})

//vertex types
$(mixin START     0);
$(mixin SPLIT     1);
$(mixin END       2);
$(mixin MERGE     3);
$(mixin REGULAR   4);

class Vertex {
	MixPool(Vertex)
	flibmdel public inline function free () {
		assert(diagonals.empty(),"diagonals non empty, free PartVertex");
		helper = null;
		prev = null;
		DEBUG(vec_set(this.,0,0);)
	}
	flibmdel public inline function alloc() {}

	public static inline function get(x:PR(GeomVert)) {
		var ret = Get(Vertex);
		vec_set(ret.,x.);
		return ret;
	}

	vec_new(public, $(->));

	//used so we can use this in the Circulator mixins
	public var prev:Vertex;

	//used for PartitionPoly
	public var diagonals:List(Vertex);

	//used by Monotone
	public var helper:Vertex;
	public var type:Int;

	//is q to the left of v?
	public static function vert_lt(q:Edge,v:Vertex) {
		if(v==q || v==q.next) return true;

		var min:Vertex; var max:Vertex;
		if(q.x < q.next.x) { min = q; max = q.next; }
		else               { min = q.next; max = q; }

		if(min.y==max.y) return min.x <= v.x;
		else {
			//assume edge not horizontal
			var flip = q.next.y > q.y;
			vec_new(u); vec_sub(q.next.,q., u);
			vec_new(v); vec_sub(v.,q.,v);
			return (flip ? vec_cross(v,u) : vec_cross(u,v)) <= 0;
		}
	}

	//used by RBTree Set
	//Note: this = Edge
	//
	//returns true if 'this' edge should be placed to the right graphically of 'q'
	public static function edge_lt(p:Edge,q:Edge) {
		vec_new(u); vec_new(v);
		var flip:Bool;
		$(mixin comp_x_at_y(vertex,edge) ({
			//assume edge not horizontal
			flip = edge.next.y > edge.y;
			vec_sub(edge.next.,edge., u);
			vec_sub(vertex.,edge.,v);
			flip ? vec_cross(v,u) : vec_cross(u,v);
		}));
		$(mixin lrg_x_vertex_y(edge,vertex) ({
			if(edge.y==edge.next.y) {
				if(edge.x < edge.next.x)
					 edge.x > vertex.x;
				else edge.next.x > vertex.x;
			}else
				comp_x_at_y(vertex,edge) < 0;
		}));

		if  (p==q && p.next==q.next) { assert(false,"Same edge inserted to tree??"); return false; }
		elif(p==q.next) return  lrg_x_vertex_y(p,q);
		elif(p.next==q) return !lrg_x_vertex_y(q,p);
		elif(p==q)      return  { assert(false,"This should never happen in a polygon(1)"); lrg_x_vertex_y(p,q.next); }
		elif(p.next==q.next) return  { assert(false,"this should never happen in a polygon(2)"); lrg_x_vertex_y(p,q); }
		//neither endpoint shared
		elif(p.y==p.next.y) {
			if(q.y==q.next.y) {
				var pmax = if(p.x < p.next.x) p.next else p;
				var qmax = if(q.x < q.next.x) q.next else q;
				return pmax.x > qmax.x;
			}else
				return comp_x_at_y(p,q) > 0;
		}else {
			var qlrgv = comp_x_at_y(q,p);
			var  qlrg = qlrgv < 0;
			var aqlrg = comp_x_at_y(q.next,p) < 0;
			if  (qlrg==aqlrg) return qlrg;
			elif(q.y==q.next.y)
				 return qlrgv > 0;
			else return comp_x_at_y(p,q) >= 0;
		}
	}

	public function new() {
		diagonals = new List(Vertex)();
	}

	flibmdel public inline function insert_diagonal(x:Vertex) {
		diagonals.add(x);
	}
	flibmdel public inline function sort_diagonals() {
		vec_new(u); vec_new(v);
		$(mixin orient(a,b,c) ({
			vec_sub(a.,b.,u);
			vec_sub(c.,b.,v);
			var ret = vec_cross(u,v);
			ret < 0 ? -1 : 1;
		}));

		var vorient = orient(prev,this,next);
		Sort(diagonals,Node(Vertex),$(mixin lt(p,q) ({
			var d1 = orient(prev,this,p);
			var d2 = orient(prev,this,q);
			if  (d1==d2) orient(p,this,q) == -1;
			elif(d1==0)  d2 == vorient;
			else         d1 != vorient;
		})) lt);
	}
}

class PR(Monotone) {

	public static inline function bisector(b:Vertex) {
		var a = b.prev;
		var c = b.next;
		vec_new(u); vec_sub(b.,a.,u);
		vec_new(v); vec_sub(c.,b.,v);
//		vec_normalise(u);
//		vec_normalise(v);
		var ret = PR(Vec2).get(-uy-vy,ux+vx);
		vec_normalise(ret.);
		if(vec_cross(u,v) < 0) vec_negate(ret.);
		return ret;
	}

	public static inline function below(p:Vertex,q:Vertex) {
		if  (p.y<q.y) return true;
		elif(p.y>q.y) return false;
		else {
			if  (p.x<q.x) return true;
			elif(p.x>q.x) return false;
			else { 
				var po = bisector(p); var qo = bisector(q);
				vec_addeq(po.,p.); vec_addeq(qo.,q.);
				var ret = po.x < qo.x || (po.x==qo.x && po.y<qo.y);
				Free(PR(Vec2),po); Free(PR(Vec2),qo);
				return ret;
			}
		}
	}
	public static inline function above(p:Vertex,q:Vertex) return below(q,p)

	//left_vertex(p) if polygon exists to the right of p.
	public static inline function left_vertex(v:Vertex) {
		var pre = v.prev;
		var nxt = v.next;
		return pre.y > v.y || (pre.y==v.y && nxt.y < v.y);
	}

	public static function isMonotone(P:PR(GeomVert)) {
	mix_circular(Vertex,
		//find min-max
		var min = P; var max = P;
		for_iter(v, P.next,P, {
			if(v.y < min.y) min = v;
			if(v.y > max.y) max = v;
		});

		var ret = true;
		//check monotonicity
		var pre = min;
		if(max!=min.next) {
			for_iter(v, min.next, max, {
				if(v.y < pre.y) { ret = false; break; }
				pre = v;
			});
		}

		if(!ret) return false;

		pre = min;
		if(max!=min.prev) {
			rev_iter(v, min.prev, max, {
				if(v.y < pre.y) { ret = false; break; }
				pre = v;
			});
		}

		return ret;
	)}

	public static function decompose(P:PR(GeomVert)) {
	mix_circular(Vertex,
		var poly = new PR(PartitionPoly)(P);

		//generate a queue to sort vertices in yx order
		//also calculate vertex types.
		var queue = new List(Vertex)();
		for_iter(p, poly.vertices, {
			queue.add(p);
			//calculate type
			vec_new(u); vec_sub(p.next.,p., u);
			vec_new(v); vec_sub(p.prev.,p., v);
			var cx = vec_cross(u,v) > 0;

			p.type = 
				if(below(p.prev,p)) {
					if(below(p.next,p)) cx ? START : SPLIT
					else REGULAR;
				}else {
					if(below(p,p.next)) cx ? END : MERGE;
					else REGULAR;
				}
		});

		//sorted set to hold interesting edges
		var edges = Get(Set(Vertex));
		edges.lt = Edge.edge_lt;
		//process away!
		Sort(queue,Node(Vertex),above);
		while(!queue.empty()) {
			var v = queue.pop_unsafe();
			switch(v.type) {
				case START:
					v.helper = v;
					edges.insert(v);

				case END:
					var e = v.prev;
					DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone 1) : Polygon is not simple + CW, but was not caught sooner!";)
					if(e.helper.type == MERGE)
						poly.insert_diagonal(v,e.helper);
					edges.remove(e);
					DEBUG(e.helper=null;)

				case SPLIT:
					var e = SetLowerBound(v,edges,Vertex.vert_lt);
					if(e!=null) {
						DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone 2) : Polygon is not simple + CW, but was not caught sooner!";)
						poly.insert_diagonal(v,e.helper);
						e.helper = v;
					}

					edges.insert(v);
					v.helper = v;

				case MERGE:
					var e = v.prev;
					DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone 3) : Polygon is not simple + CW, but was not caught sooner!";)
					if(e.helper.type == MERGE)
						poly.insert_diagonal(v,e.helper);
					edges.remove(e);
					DEBUG(e.helper = null;)

					var e = SetLowerBound(v,edges,Vertex.vert_lt);
					if(e!=null) {
						DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone 4) : Polygon is not simple + CW, but was not caught sooner!";)
						if(e.helper.type == MERGE)
							poly.insert_diagonal(v,e.helper);
						e.helper = v;
					}

				case REGULAR:
					var pre = v.prev;
					if(left_vertex(v)) {
						DEBUG(if(pre.helper==null) throw "FATAL ERROR (Monotone 5) : Polygon is not simple + CW, but was not caught sooner!";)
						if(pre.helper.type == MERGE)
							poly.insert_diagonal(v,pre.helper);
						edges.remove(pre);
						DEBUG(pre.helper=null;)
						
						edges.insert(v);
						v.helper = v;

					}else {
						var e = SetLowerBound(v,edges,Vertex.vert_lt);
						DEBUG(if(e==null || e.helper==null) throw "FATAL ERROR (Monotone 6) : Polygon is not simple + CW, but was not caught sooner!";)
						if(e.helper.type == MERGE)
							poly.insert_diagonal(v,e.helper);
						e.helper = v;
					}
			}
		}

		#if NAPE_ASSERT
			var ret = poly.partition();
			//don't use signed area since P may have been reversed if it was not clockwise at entry
			var area = geom(area(P));

			var retarea = 0.0;
			Iter(p,ret,{
				var elm = geom(signed_area(p));
				retarea += elm;
				assert(elm>0,"Monotone output degenerate area or non-clockwise");
			});

			var darea = area-retarea;
			assert(darea*darea < PR(Const).EPSILON, "Monotone output set has different area!?");

			return ret;
		#else
			return poly.partition();
		#end
	)}

}

