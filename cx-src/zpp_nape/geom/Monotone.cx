package zpp_nape.geom;
$(import);

$(define class Queue(T,lt) {
	public var first:Node(T);
	public function new() {}

	public function insert(obj:T) {
		if(first==null) {
			first = new Node(T)();
			first.elt = obj;
			return;
		}

		var pre = null;
		var cur = first;
		while(cur!=null && lt(cur.elt,obj)) { pre = cur; cur = cur.next; }
		var node = new Node(T)();
		node.elt = obj;
		if(pre!=null) {
			node.next = pre.next;
			pre.next = node;
		}else {
			node.next = first;
			first = node;
		}
	}

	public function pop():T {
		var ret = first.elt;
		first = first.next;
		return ret;
	}

	public function empty() return first==null
});

$(define class Node(T) {
	public var next:Node(T);

	public var elt:T;

	public var child1:Node(T);
	public var child2:Node(T);

	public function new() {}
});

$(define class Tree(T,lt) {
	public var root:Node(T);
	public function new() {}

	public function insert(obj:T) {
		if(root==null) {
			root = new Node(T)();
			root.elt = obj;
			return;
		}

		var cur = root;
		while(true) {
			if(lt(obj,cur.elt)) {
				if(cur.child1==null) {
					cur.child1 = new Node(T)();
					cur.child1.elt = obj;
					break;
				}else cur = cur.child1;
			}else {
				if(cur.child2==null) {
					cur.child2 = new Node(T)();
					cur.child2.elt = obj;
					break;
				}else cur = cur.child2;
			}
		}
	}

	public function remove(obj:T) {
		var par = null;
		var cur = root;
		while(cur.elt!=obj) {
			par = cur;
			if(lt(obj,cur.elt)) cur = cur.child1;
			else                cur = cur.child2;
		}

		if(cur.child1==null && cur.child2==null) {
			if(par!=null) {
				if(par.child1==cur) par.child1 = null;
				else par.child2 = null;
			}else
				root = null;
		}else if(cur.child1!=null && cur.child2!=null) {
			var pn = cur;
			var nn = cur.child2;
			while(nn.child1!=null) { pn=nn; nn = nn.child1; }
			
			cur.elt = nn.elt;
			if(pn!=cur) pn.child1 = null;
			else cur.child2 = null;
		}else {
			if(cur.child1!=null) {
				if(par!=null) {
					if(par.child1==cur) par.child1 = cur.child1;
					else par.child2 = cur.child1;
				}else root = cur.child1;
			}else {
				if(par!=null) {
					if(par.child1==cur) par.child1 = cur.child2;
					else par.child2 = cur.child2;
				}else root = cur.child2;
			}
		}
	}

	public function first() {
		var ret = root;
		while(ret.child1!=null) ret = ret.child1;
		return ret.elt;
	}

	public function lower_bound(obj:T) {
		var ret = null;
		traverse(function(elt:T) {
			if(ret==null) {
				if(!lt(elt,obj)) {
					ret = elt;
				}
			}
		});
		return ret;
	}

	public function traverse(cb:T->Void) {
		var trav:Node(T)->Void = null;
		trav = function(node:Node(T)) {
			if(node.child1!=null) { trav(node.child1); }
			if(node.elt!=null) cb(node.elt);
			if(node.child2!=null) { trav(node.child2); }
		}
		if(root!=null) trav(root);
	}
});

enum TypeV {
	tStart;
	tSplit;
	tRegular;
	tMerge;
	tEnd;
}

typedef Edge = {fst:PR(PartitionVertex), snd:PR(PartitionVertex), helper:Int};

class PR(PartitionPoly) {
	public var vertices:Array<PR(PartitionVertex)>;
	public function new(p:Array<Vec2>) {
		vertices = new Array<PR(PartitionVertex)>();
		for(v in p) vertices.push(new PR(PartitionVertex)(v));
	}

	public function insert_diagonal(a:PR(PartitionVertex),b:PR(PartitionVertex)) {
		a.insert_diag(b);
		b.insert_diag(a);
	}

	public function partition() {
		var cur = 0;
		var prev = vertices.length-1;
		do {
			var next = (cur+1)%vertices.length;
			vertices[cur].sort_diagonals(vertices[prev],vertices[next]);
			prev = cur;
		}while(++cur != vertices.length);

		var rets = [];
		make_polygon(0,rets);
		return rets;
	}

	public static var cols = [0xff00,0xff,0xffff,0xff00ff,0xff8000,0xffff00];
	public static var icol =0;

	public function make_polygon(start:Int,rets:Array<Array<Vec2>>) {
		var poly:Array<Vec2> = [];
		var next = start;
		do {
			poly.push(vertices[next]);
			if(vertices[next].has_unused_diagonals()) {
				var diag = vertices[next].current_diagonal();
				vertices[next].advance_diagonal();	
				if(diag == vertices[start]) {
					break;
				}else
					next = make_polygon(next,rets);
			}else next = (next+1)%vertices.length;
		}while(next!=start);
		rets.push(poly);
		return next;
	}
}

class PR(PartitionVertex) extends Vec2 {
	public var diagonals:Array<PR(PartitionVertex)>;
	public var curdiag:Int;

	public function new(v:Vec2) {
		super(v.x,v.y);
		diagonals = new Array<PR(PartitionVertex)>();
		curdiag = 0;
	}

	public function insert_diag(x:PR(PartitionVertex)) {
		diagonals.push(x);
	}

	public static function orient(a:PR(PartitionVertex),b:PR(PartitionVertex),c:PR(PartitionVertex)) {
		var ret = a.sub(b).cross(c.sub(b));
		if(ret<0) ret = -1;
		if(ret>0) ret = 1;
		return Std.int(ret);
	}

	public static function cw_diag(prev:PR(PartitionVertex),vertex:PR(PartitionVertex), vorient:Int, x:PR(PartitionVertex),y:PR(PartitionVertex)) {
		var d1 = orient(prev,vertex,x);
		var d2 = orient(prev,vertex,y);
		var d1_d2 = orient(x,vertex,y);

		if(d1==d2) return d1_d2 == -1;

		if(d1==0) return d2 == vorient;

		return d1 != vorient;
	}

	public inline function has_unused_diagonals() return curdiag < diagonals.length
	public inline function current_diagonal() return diagonals[curdiag]
	public inline function advance_diagonal() curdiag++

	public function sort_diagonals(prev:PR(PartitionVertex), next:PR(PartitionVertex)) {
		var vorient = orient(prev,this,next);
		var me = this;
		diagonals.sort(function (x,y) return cw_diag(prev,me,vorient,x,y) ? -1 : 1);

		//std::unique
		var i = 0;
		var j = 0;
		while(++j<diagonals.length) {
			if(diagonals[i]!=diagonals[j]) {
				diagonals[++i] = diagonals[j];
			}
		}
		while(diagonals.length>i+1) diagonals.pop();
		//end std::unique

		curdiag = 0;
	}
}

class PR(Monotone) {

	public static var debug:Debug = null;

	public static function below(p:Vec2,q:Vec2) {
		return p.y < q.y || (p.y==q.y && p.x>q.x);
	}


	public static function comp_x_at_y_2(vertex:Vec2,edge:Edge) {
		//assume edge not horizontal
		var flip = edge.snd.y > edge.fst.y;
		var ret = edge.snd.sub(edge.fst).cross(vertex.sub(edge.fst));
		if(flip) ret = -ret;
		return ret;
	}
	public static function lrg_x_vertex_y(edge:Edge,vertex:Vec2) {
		if(edge.fst.y==edge.snd.y) {
			if(edge.fst.x < edge.snd.x) return edge.fst.x > vertex.x;
			else                        return edge.snd.x > vertex.x;
		}else {
			return comp_x_at_y_2(vertex,edge) < 0;
		}
	}
	public static function left(p:Edge,q:Edge) {
		if(p.fst==q.fst && p.snd==q.snd) return false;

		if(p.fst==q.snd) return  lrg_x_vertex_y(p,q.fst);
		if(p.snd==q.fst) return !lrg_x_vertex_y(q,p.fst);
		if(p.fst==q.fst) return  lrg_x_vertex_y(p,q.snd);
		if(p.snd==q.snd) return  lrg_x_vertex_y(p,q.fst);

		//neither endpoint shared
		if(p.fst.y==p.snd.y) {
			if(q.fst.y==q.snd.y) {
				var pmax:Vec2;
				var qmax:Vec2;
				pmax = if(p.fst.x < p.snd.x) p.snd else p.fst;
				qmax = if(q.fst.x < q.snd.x) q.snd else q.fst;
				return pmax.x > qmax.x;
			}else
				return comp_x_at_y_2(p.fst,q) > 0;
		}

		var qlrg = comp_x_at_y_2(q.fst,p) < 0;
		var aqlrg= comp_x_at_y_2(q.snd,p) < 0;
		if(qlrg==aqlrg) return qlrg;

		if(q.fst.y==q.snd.y) {
			return comp_x_at_y_2(q.fst, p) > 0;
		}
		return comp_x_at_y_2(p.fst,q) >= 0;
	}

	public static function type(P:Array<PR(PartitionVertex)>,pl:Int,i:Int) {
		var v0 = P[(i+pl-1)%pl];
		var v = P[i];
		var v1 = P[(i+1)%pl];

		var b0 = below(v0,v);
		var b1 = below(v1,v);
		if(b0 && b1) {
			if(v1.sub(v).cross(v0.sub(v)) > 0)
				 return tStart;
			else return tSplit;
		}else if(!b0 && !b1) {
			if(v1.sub(v).cross(v0.sub(v)) > 0)
				 return tEnd;
			else return tMerge;
		}else
			return tRegular;
	}
	
	public static function lss(a:Int,b:Int) return a<b
	public static function partition(P:Array<Vec2>) {
		if(debug==null) {
			debug = new BitmapDebug(600,600,0);
			flash.Lib.current.addChild(debug.display);
		}else debug.clear();

		var poly = new PR(PartitionPoly)(P);
		render(poly.vertices,0xffffff);

		var D:Array<Edge> = [];
		for(i in 0...P.length) {
			var j = (i+1)%P.length;
			D.push({fst:poly.vertices[i],snd:poly.vertices[j],helper:-1});
		}

		var Q = new Queue(PR(PartitionVertex),!PR(Monotone).below)();
		for(p in poly.vertices) Q.insert(p);		
		
		var T = new Tree(Edge,PR(Monotone).left)();	
		while(!Q.empty()) {
			var v = Q.pop();
			var i = 0;
			for(j in 0...P.length) { if(poly.vertices[j]==v) { i = j; break; } }

			debug.drawCircle(v,2.5,0xffffff);
			debug.flush();
			switch(type(poly.vertices,P.length,i)) {
				case tStart:
					D[i].helper = i;
					T.insert(D[i]);
				case tEnd:
					var e = D[(i-1+D.length)%D.length];
					if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge)) {
						debug.drawLine(v,poly.vertices[e.helper],0xff0000);
						debug.flush();

						poly.insert_diagonal(v,poly.vertices[e.helper]);
					}
					T.remove(e);
				case tSplit:
					var e = T.lower_bound(D[i]);
					{
						debug.drawLine(v,poly.vertices[e.helper],0xff0000);
						debug.flush();

						poly.insert_diagonal(v,poly.vertices[e.helper]);
					}
					e.helper = i;
					T.insert(D[i]);
					D[i].helper = i;
				case tMerge:
					var e = D[(i-1+D.length)%D.length];
					if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge)) {
						debug.drawLine(v,poly.vertices[e.helper],0xff0000);
						debug.flush();

						poly.insert_diagonal(v,poly.vertices[e.helper]);
					}
					T.remove(e);
					var e = T.lower_bound(D[i]);
					if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge)) {
						debug.drawLine(v,poly.vertices[e.helper],0xff0000);
						debug.flush();

						poly.insert_diagonal(v,poly.vertices[e.helper]);
					}
					e.helper = i;
				case tRegular:
					var pre = poly.vertices[(i-1+P.length)%P.length];
					var nxt = poly.vertices[(i+1)%P.length];
					if(pre.y > v.y || (pre.y==v.y && nxt.y < v.y)) {
						var e = D[(i-1+D.length)%D.length];
						if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge)) {
							debug.drawLine(v,poly.vertices[e.helper],0xff0000);
							debug.flush();

							poly.insert_diagonal(v,poly.vertices[e.helper]);
						}
						T.remove(e);
						T.insert(D[i]);
						D[i].helper = i;
					}else {
						var e = T.lower_bound(D[i]);
						if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge)) {
							debug.drawLine(v,poly.vertices[e.helper],0xff0000);
							debug.flush();

							poly.insert_diagonal(v,poly.vertices[e.helper]);
						}
						e.helper = i;
					}
			}
		}

		debug.flush();

		return poly.partition();
	}

	public static function render(poly:Array<PR(PartitionVertex)>, col:Int) {
		for(i in 0...poly.length) {
			var j = (i+1)%poly.length;

			var u = poly[i].add(new Vec2(Math.random()*5-2.5,Math.random()*5-2.5));
			var v = poly[j].add(new Vec2(Math.random()*5-2.5,Math.random()*5-2.5));

			debug.drawLine(u,v,col);
		}
	}

}
