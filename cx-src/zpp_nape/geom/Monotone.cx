package zpp_nape.geom;
$(import);

//got sick of typing this out too many times!
$(mixin Vertex() PR(PartitionVertex));
$(mixin Edge() Vertex);

mix_circular(Vertex,
class PR(PartitionPoly) {
	public var vertices:Vertex;

	public function new(P:Array<Vec2>) {
		for(p in P) vertices = push_after(vertices,Vertex.get(p));
	}
	
	flibmdel public inline function insert_diagonal(p:Vertex,q:Vertex) {
		p.insert_diagonal(q);
		q.insert_diagonal(p);
	}

	public function partition() {
		for_iter(c, vertices, c.sort_diagonals());

		var rets:Array<Array<Vec2>> = [];
		make_polygon(vertices, rets);

		return rets;
	}

	//can we make this iterative rather than recursive?
	public function make_polygon(start:Vertex, rets:Array<Array<Vec2>>) {
		var poly:Array<Vec2> = [];
		var next = start;
		do {
			poly.push(Vec2.get(next.x,next.y));
			if(!next.diagonals.empty()) {
				var diag = next.diagonals.pop_unsafe();
				if(diag==start)
					break;
				else
					next = make_polygon(next,rets);
			}else next = next.next;
		}while(next!=start);
		rets.push(poly);
		return next;
	}
})

//vertex types
$(mixin START   0);
$(mixin SPLIT   1);
$(mixin END     2);
$(mixin MERGE   3);
$(mixin REGULAR 4);

class Vertex {
	MixPool(Vertex)
	flibmdel public inline function free () {
		assert(diagonals.empty(),"diagonals non empty, free PartVertex");
		helper = null;
	}
	flibmdel public inline function alloc() {}

	public static inline function get(x:Vec2) {
		var ret = Get(Vertex);
		vec_set(ret.,x.);
		return ret;
	}

	vec_new(public, $(->));

	//used so we can use this in the Circulator mixins
	public var prev:Vertex;

	//used for PartitionPoly
	public var diagonals:List(Vertex);

	//used by Monotone
	public var helper:Vertex;
	public var type:Int;
	public var rb_set:Set(Vertex);

	//used by RBTree Set
	//Note: this = Edge
	public function rb_lt(q:Edge) {
		vec_new(u); vec_new(v);
		var flip:Bool;
		$(mixin comp_x_at_y(vertex,edge) ({
			//assume edge not horizontal
			flip = edge.next.y > edge.y;
			vec_sub(edge.next.,edge., u);
			vec_sub(vertex.,edge.,v);
			/*return*/ flip ? vec_cross(v,u) : vec_cross(u,v);
		}));
		$(mixin lrg_x_vertex_y(edge,vertex) ({
			if(edge.y==edge.next.y) {
				if(edge.x < edge.next.x)
					 edge.x > vertex.x;
				else edge.next.x > vertex.x;
			}else
				comp_x_at_y(vertex,edge) < 0;
		}));

		if  (this==q && next==q.next) return false;
		elif(this==q.next) return  lrg_x_vertex_y(this,q);
		elif(next==q)      return !lrg_x_vertex_y(q,this);
		elif(this==q)      return  lrg_x_vertex_y(this,q.next);
		elif(next==q.next) return  lrg_x_vertex_y(this,q);
		//neither endpoint shared
		elif(this.y==next.y) {
			if(q.y==q.next.y) {
				var pmax = if(x   <   next.x)   next else this;
				var qmax = if(q.x < q.next.x) q.next else q;
				return pmax.x > qmax.x;
			}else
				return comp_x_at_y(this,q) > 0;
		}else {
			var qlrgv = comp_x_at_y(q,this);
			var  qlrg = qlrgv < 0;
			var aqlrg = comp_x_at_y(q.next,this) < 0;
			if  (qlrg==aqlrg) return qlrg;
			elif(q.y==q.next.y)
				 return qlrgv > 0;
			else return comp_x_at_y(this,q) >= 0;
		}
	}

	public function new() {
		diagonals = new List(Vertex)();
	}

	flibmdel public inline function insert_diagonal(x:Vertex) {
		diagonals.add(x);
	}
	flibmdel public inline function sort_diagonals() {
		vec_new(u); vec_new(v);
		$(mixin orient(a,b,c) ({
			vec_sub(a.,b.,u);
			vec_sub(c.,b.,v);
			var ret = vec_cross(u,v);
			ret < 0 ? -1 : 1;
		}));

		var vorient = orient(prev,this,next);
		Sort(diagonals,Node(Vertex),$(mixin lt(p,q) ({
			var d1 = orient(prev,this,p);
			var d2 = orient(prev,this,q);
			if  (d1==d2) orient(p,this,q) == -1;
			elif(d1==0)  d2 == vorient;
			else         d1 != vorient;
		})) lt);
	}
}

class PR(Monotone) {

	public static inline function below(p:Vertex,q:Vertex) {
		return p.y<q.y || (p.y==q.y && p.x>q.x);
	}

	public static function decompose(P:Array<Vec2>) {
	mix_circular(Vertex,
		var poly = new PR(PartitionPoly)(P);

		//generate a queue to sort vertices in yx order
		//also calculate vertex types.
		var queue = new List(Vertex)();
		for_iter(p, poly.vertices, {
			queue.add(p);

			//calculate type
			var b0 = below(p.prev,p);
			var b1 = below(p.next,p);
			vec_new(u); vec_sub(p.next.,p., u);
			vec_new(v); vec_sub(p.prev.,p., v);
			var cx = vec_cross(u,v) > 0;

			p.type =
				if  ( b0 &&  b1) cx ? START : SPLIT
				elif(!b0 && !b1) cx ? END   : MERGE
				else REGULAR;
		});

		//sorted set to hold interesting edges
		var edges = new Set(Vertex)();
		//process away!
		Sort(queue,Node(Vertex),!below);
		while(!queue.empty()) {
			var v = queue.pop_unsafe();
			switch(v.type) {
				case START:
					v.helper = v;
					edges.insert(v);

				case END:
					var e = v.prev;
					DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone) : Polygon is not simple + CW, but was not caught sooner!";)
					if(e.helper.type == MERGE)
						poly.insert_diagonal(v,e.helper);
					edges.remove(e);
					DEBUG(e.helper=null;)

				case SPLIT:
					var e = edges.lower_bound(v);
					DEBUG(if(e==null || e.helper==null) throw "FATAL ERROR (Monotone) : Polygon is not simple + CW, but was not caught sooner!";)
					poly.insert_diagonal(v,e.helper);
					e.helper = v;

					edges.insert(v);
					v.helper = v;

				case MERGE:
					var e = v.prev;
					DEBUG(if(e.helper==null) throw "FATAL ERROR (Monotone) : Polygon is not simple + CW, but was not caught sooner!";)
					if(e.helper.type == MERGE)
						poly.insert_diagonal(v,e.helper);
					edges.remove(e);
					DEBUG(e.helper = null;)

					var e = edges.lower_bound(v);
					DEBUG(if(e==null || e.helper==null) throw "FATAL ERROR (Monotone) : Polygon is not simple + CW, but was not caught sooner!";)
					if(e.helper.type == MERGE)
						poly.insert_diagonal(v,e.helper);
					e.helper = v;

				case REGULAR:
					var pre = v.prev;
					var nxt = v.next;
					if(pre.y > v.y || (pre.y==v.y && nxt.y < v.y)) {
						DEBUG(if(pre.helper==null) throw "FATAL ERROR (Monotone) : Polygon is not simple + CW, but was not caught sooner!";)
						if(pre.helper.type == MERGE)
							poly.insert_diagonal(v,pre.helper);
						edges.remove(pre);
						DEBUG(pre.helper=null);
						
						edges.insert(v);
						v.helper = v;

					}else {
						var e = edges.lower_bound(v);
						DEBUG(if(e==null || e.helper==null) throw "FATAL ERROR (Monotone) : Polygon is not simple + CW, but was not caught sooner!";)
						if(e.helper.type == MERGE)
							poly.insert_diagonal(v,e.helper);
						e.helper = v;
					}
			}
		}
		return poly.partition();
	)}

}


#if false

$(define class Queue(T,lt) {
	public var first:Node(T);
	public function new() {}

	public function insert(obj:T) {
		if(first==null) {
			first = new Node(T)();
			first.elt = obj;
			return;
		}

		var pre = null;
		var cur = first;
		while(cur!=null && lt(cur.elt,obj)) { pre = cur; cur = cur.next; }
		var node = new Node(T)();
		node.elt = obj;
		if(pre!=null) {
			node.next = pre.next;
			pre.next = node;
		}else {
			node.next = first;
			first = node;
		}
	}

	public function pop():T {
		var ret = first.elt;
		first = first.next;
		return ret;
	}

	public function empty() return first==null
});

$(define class Nxode(T) {

	public var next:Node(T);

	public var elt:T;

	public var child1:Node(T);
	public var child2:Node(T);

	public function new() {}
});

$(define class Tree(T,lt) {
	public var root:Node(T);
	public function new() {}

	public function insert(obj:T) {
		if(root==null) {
			root = new Node(T)();
			root.elt = obj;
			return;
		}

		var cur = root;
		while(true) {
			if(lt(obj,cur.elt)) {
				if(cur.child1==null) {
					cur.child1 = new Node(T)();
					cur.child1.elt = obj;
					break;
				}else cur = cur.child1;
			}else {
				if(cur.child2==null) {
					cur.child2 = new Node(T)();
					cur.child2.elt = obj;
					break;
				}else cur = cur.child2;
			}
		}
	}

	public function remove(obj:T) {
		var par = null;
		var cur = root;
		while(cur.elt!=obj) {
			par = cur;
			if(lt(obj,cur.elt)) cur = cur.child1;
			else                cur = cur.child2;
		}

		if(cur.child1==null && cur.child2==null) {
			if(par!=null) {
				if(par.child1==cur) par.child1 = null;
				else par.child2 = null;
			}else
				root = null;
		}else if(cur.child1!=null && cur.child2!=null) {
			var pn = cur;
			var nn = cur.child2;
			while(nn.child1!=null) { pn=nn; nn = nn.child1; }
			
			cur.elt = nn.elt;
			if(pn!=cur) pn.child1 = null;
			else cur.child2 = null;
		}else {
			if(cur.child1!=null) {
				if(par!=null) {
					if(par.child1==cur) par.child1 = cur.child1;
					else par.child2 = cur.child1;
				}else root = cur.child1;
			}else {
				if(par!=null) {
					if(par.child1==cur) par.child1 = cur.child2;
					else par.child2 = cur.child2;
				}else root = cur.child2;
			}
		}
	}

	public function first() {
		var ret = root;
		while(ret.child1!=null) ret = ret.child1;
		return ret.elt;
	}

	public function lower_bound(obj:T) {
		var ret = null;
		traverse(function(elt:T) {
			if(ret==null) {
				if(!lt(elt,obj)) {
					ret = elt;
				}
			}
		});
		return ret;
	}

	public function traverse(cb:T->Void) {
		var trav:Node(T)->Void = null;
		trav = function(node:Node(T)) {
			if(node.child1!=null) { trav(node.child1); }
			if(node.elt!=null) cb(node.elt);
			if(node.child2!=null) { trav(node.child2); }
		}
		if(root!=null) trav(root);
	}
});

enum TypeV {
	tStart;
	tSplit;
	tRegular;
	tMerge;
	tEnd;
}

typedef Edge = {fst:PR(PartitionVertex), snd:PR(PartitionVertex), helper:Int};

class PR(PartitionPoly) {
	public var vertices:Array<PR(PartitionVertex)>;
	public function new(p:Array<Vec2>) {
		vertices = new Array<PR(PartitionVertex)>();
		for(v in p) vertices.push(new PR(PartitionVertex)(v));
	}

	public function insert_diagonal(a:PR(PartitionVertex),b:PR(PartitionVertex)) {
		a.insert_diag(b);
		b.insert_diag(a);
	}

	public function partition() {
		var cur = 0;
		var prev = vertices.length-1;
		do {
			var next = (cur+1)%vertices.length;
			vertices[cur].sort_diagonals(vertices[prev],vertices[next]);
			prev = cur;
		}while(++cur != vertices.length);

		var rets = [];
		make_polygon(0,rets);
		return rets;
	}

	public static var cols = [0xff00,0xff,0xffff,0xff00ff,0xff8000,0xffff00];
	public static var icol =0;

	public function make_polygon(start:Int,rets:Array<Array<Vec2>>) {
		var poly:Array<Vec2> = [];
		var next = start;
		do {
			poly.push(vertices[next]);
			if(vertices[next].has_unused_diagonals()) {
				var diag = vertices[next].current_diagonal();
				vertices[next].advance_diagonal();	
				if(diag == vertices[start]) {
					break;
				}else
					next = make_polygon(next,rets);
			}else next = (next+1)%vertices.length;
		}while(next!=start);
		rets.push(poly);
		return next;
	}
}

class PR(PartitionVertex) extends Vec2 {
	public var diagonals:Array<PR(PartitionVertex)>;
	public var curdiag:Int;

	public function new(v:Vec2) {
		super(v.x,v.y);
		diagonals = new Array<PR(PartitionVertex)>();
		curdiag = 0;
	}

	public function insert_diag(x:PR(PartitionVertex)) {
		diagonals.push(x);
	}

	public static function orient(a:PR(PartitionVertex),b:PR(PartitionVertex),c:PR(PartitionVertex)) {
		var ret = a.sub(b).cross(c.sub(b));
		if(ret<0) ret = -1;
		if(ret>0) ret = 1;
		return Std.int(ret);
	}

	public static function cw_diag(prev:PR(PartitionVertex),vertex:PR(PartitionVertex), vorient:Int, x:PR(PartitionVertex),y:PR(PartitionVertex)) {
		var d1 = orient(prev,vertex,x);
		var d2 = orient(prev,vertex,y);
		var d1_d2 = orient(x,vertex,y);

		if(d1==d2) return d1_d2 == -1;

		if(d1==0) return d2 == vorient;

		return d1 != vorient;
	}

	public inline function has_unused_diagonals() return curdiag < diagonals.length
	public inline function current_diagonal() return diagonals[curdiag]
	public inline function advance_diagonal() curdiag++

	public function sort_diagonals(prev:PR(PartitionVertex), next:PR(PartitionVertex)) {
		var vorient = orient(prev,this,next);
		var me = this;
		diagonals.sort(function (x,y) return cw_diag(prev,me,vorient,x,y) ? -1 : 1);

		//std::unique
		var i = 0;
		var j = 0;
		while(++j<diagonals.length) {
			if(diagonals[i]!=diagonals[j]) {
				diagonals[++i] = diagonals[j];
			}
		}
		while(diagonals.length>i+1) diagonals.pop();
		//end std::unique

		curdiag = 0;
	}
}

class PR(Monotone) {

	public static function below(p:Vec2,q:Vec2) {
		return p.y < q.y || (p.y==q.y && p.x>q.x);
	}


	public static function comp_x_at_y_2(vertex:Vec2,edge:Edge) {
		//assume edge not horizontal
		var flip = edge.snd.y > edge.fst.y;
		var ret = edge.snd.sub(edge.fst).cross(vertex.sub(edge.fst));
		if(flip) ret = -ret;
		return ret;
	}
	public static function lrg_x_vertex_y(edge:Edge,vertex:Vec2) {
		if(edge.fst.y==edge.snd.y) {
			if(edge.fst.x < edge.snd.x) return edge.fst.x > vertex.x;
			else                        return edge.snd.x > vertex.x;
		}else {
			return comp_x_at_y_2(vertex,edge) < 0;
		}
	}
	public static function left(p:Edge,q:Edge) {
		if(p.fst==q.fst && p.snd==q.snd) return false;

		if(p.fst==q.snd) return  lrg_x_vertex_y(p,q.fst);
		if(p.snd==q.fst) return !lrg_x_vertex_y(q,p.fst);
		if(p.fst==q.fst) return  lrg_x_vertex_y(p,q.snd);
		if(p.snd==q.snd) return  lrg_x_vertex_y(p,q.fst);

		//neither endpoint shared
		if(p.fst.y==p.snd.y) {
			if(q.fst.y==q.snd.y) {
				var pmax:Vec2;
				var qmax:Vec2;
				pmax = if(p.fst.x < p.snd.x) p.snd else p.fst;
				qmax = if(q.fst.x < q.snd.x) q.snd else q.fst;
				return pmax.x > qmax.x;
			}else
				return comp_x_at_y_2(p.fst,q) > 0;
		}

		var qlrg = comp_x_at_y_2(q.fst,p) < 0;
		var aqlrg= comp_x_at_y_2(q.snd,p) < 0;
		if(qlrg==aqlrg) return qlrg;

		if(q.fst.y==q.snd.y) {
			return comp_x_at_y_2(q.fst, p) > 0;
		}
		return comp_x_at_y_2(p.fst,q) >= 0;
	}

	public static function type(P:Array<PR(PartitionVertex)>,pl:Int,i:Int) {
		var v0 = P[(i+pl-1)%pl];
		var v = P[i];
		var v1 = P[(i+1)%pl];

		var b0 = below(v0,v);
		var b1 = below(v1,v);
		if(b0 && b1) {
			if(v1.sub(v).cross(v0.sub(v)) > 0)
				 return tStart;
			else return tSplit;
		}else if(!b0 && !b1) {
			if(v1.sub(v).cross(v0.sub(v)) > 0)
				 return tEnd;
			else return tMerge;
		}else
			return tRegular;
	}
	
	public static function lss(a:Int,b:Int) return a<b
	public static function decompose(P:Array<Vec2>) {
		var poly = new PR(PartitionPoly)(P);

		var D:Array<Edge> = [];
		for(i in 0...P.length) {
			var j = (i+1)%P.length;
			D.push({fst:poly.vertices[i],snd:poly.vertices[j],helper:-1});
		}

		var Q = new Queue(PR(PartitionVertex),!PR(Monotone).below)();
		for(p in poly.vertices) Q.insert(p);		
		
		var T = new Tree(Edge,PR(Monotone).left)();	
		while(!Q.empty()) {
			var v = Q.pop();
			var i = 0;
			for(j in 0...P.length) { if(poly.vertices[j]==v) { i = j; break; } }

			switch(type(poly.vertices,P.length,i)) {
				case tStart:
					D[i].helper = i;
					T.insert(D[i]);
				case tEnd:
					var e = D[(i-1+D.length)%D.length];
					if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge))
						poly.insert_diagonal(v,poly.vertices[e.helper]);
					T.remove(e);
				case tSplit:
					var e = T.lower_bound(D[i]);
					poly.insert_diagonal(v,poly.vertices[e.helper]);
					e.helper = i;
					T.insert(D[i]);
					D[i].helper = i;
				case tMerge:
					var e = D[(i-1+D.length)%D.length];
					if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge))
						poly.insert_diagonal(v,poly.vertices[e.helper]);
					T.remove(e);
					var e = T.lower_bound(D[i]);
					if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge))
						poly.insert_diagonal(v,poly.vertices[e.helper]);
					e.helper = i;
				case tRegular:
					var pre = poly.vertices[(i-1+P.length)%P.length];
					var nxt = poly.vertices[(i+1)%P.length];
					if(pre.y > v.y || (pre.y==v.y && nxt.y < v.y)) {
						var e = D[(i-1+D.length)%D.length];
						if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge)) 
							poly.insert_diagonal(v,poly.vertices[e.helper]);
						T.remove(e);
						T.insert(D[i]);
						D[i].helper = i;
					}else {
						var e = T.lower_bound(D[i]);
						if(Type.enumEq(type(poly.vertices,P.length,e.helper),tMerge))
							poly.insert_diagonal(v,poly.vertices[e.helper]);
						e.helper = i;
					}
			}
		}

		return poly.partition();
	}
}
#end
