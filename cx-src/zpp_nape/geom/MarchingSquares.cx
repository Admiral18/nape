package zpp_nape.geom;
$(import);

$(mixin Vertex() PR(GeomVert));

class PR(MarchingSquares) {

	public static function run(iso:Float->Float->Float,bx0:Float,by0:Float,bx1:Float,by1:Float,cell:Vec2,quality:Int) {
		var xp = (bx1-bx0)/cell.x; var xn:Int = fastint(xp);
		var yp = (by1-by0)/cell.y; var yn:Int = fastint(yp);
		if(xp!=xn) xn++;
		if(yp!=yn) yn++;

		for(y in 0...yn) {
			var y0 = by0 + cell.y*y;
			var y1 = if(y==yn-1) by1 else y0+cell.y;
			for(x in 0...xn) {
				var x0 = bx0 + cell.x*x;
				var x1 = if(x==xn-1) bx1 else x0+cell.x;

				var p1:Vertex = null; var p2:Vertex = null;
				marchSquare(iso,x0,y0,x1,y1,quality, p1,p2);
				if(p1==null) continue;

				var poly = new GeomPoly();
				poly.pr(inner).vertices = p1;
				DummyNapeMain.debug.drawFilledPolygon(poly,0x606060);
				DummyNapeMain.debug.drawPolygon(poly,0x999999);

				if(p2!=null) {
					poly.pr(inner).vertices = p2;
					DummyNapeMain.debug.drawFilledPolygon(poly,0x606060);
					DummyNapeMain.debug.drawPolygon(poly,0x999999);
				}
			}
		}
	}

	public static var look_march = [0x00,0xE0,0x38,0xD8,0x0E,-1,0x36,0xD6,0x83,0x63,-1,0x5B,0x8D,0x6D,0xB5,0x55];
	$(mixin marchSquare(iso,x0,y0,x1,y1,quality, p1,p2) {
		var key = 0;
		var v0 = iso(x0,y0); if(v0<0) key |= 8;
		var v1 = iso(x1,y0); if(v1<0) key |= 4;
		var v2 = iso(x1,y1); if(v2<0) key |= 2;
		var v3 = iso(x0,y1); if(v3<0) key |= 1;

		if(key!=10 && key!=5) {
			var val = look_march[key];
			if(val!=0) poly(val,p1);
		}else {
			var mid = iso(0.5*(x0+x1),0.5*(y0+y1)) < 0;
			if(key==10) {
				if(mid)
					poly(0xBB,p1);
				else {
					poly(0x83,p1);
					poly(0x38,p2);
				}
			}else {
				if(mid)
					poly(0xEE,p1);
				else {
					poly(0xE0,p1);
					poly(0x0E,p2);
				}
			}
		}

		$(mixin poly(val,out) {
			mix_circular(Vertex,
				for(i in 0...8) {
					if((val&(1<<i))!=0) {
						var p = 
							if  (i==0) Vertex.get(x0,y0)
							elif(i==2) Vertex.get(x1,y0)
							elif(i==4) Vertex.get(x1,y1)
							elif(i==6) Vertex.get(x0,y1)
	
							elif(i==1) Vertex.get(xlerp(x0,x1,y0,v0,v1,iso,quality),y0)
							elif(i==5) Vertex.get(xlerp(x0,x1,y1,v3,v2,iso,quality),y1)
	
							elif(i==3) Vertex.get(x1,ylerp(y0,y1,x1,v1,v2,iso,quality))
							else       Vertex.get(x0,ylerp(y0,y1,x0,v0,v3,iso,quality));
						out = push_after(out,p);
					}
				}
			)
		});
	});

	public static inline function lerp(x0:Float,x1:Float,v0:Float,v1:Float) {
		var dv = v0-v1;
		var t = if(dv*dv<PR(Const).EPSILON) 0.5 else v0/dv;
		return x0 + t*(x1-x0);
	}
	public static inline function xlerp(x0:Float,x1:Float,y:Float,v0:Float,v1:Float,iso:Float->Float->Float,quality:Int) {
		var xm = lerp(x0,x1,v0,v1);
		while(quality--!=0) {
			var vm = iso(xm,y);
			if(v0*vm<0) { x1 = xm; v1 = vm; }
			else        { x0 = xm; v0 = vm; }
			xm = lerp(x0,x1,v0,v1);
		}
		return xm;
	}
	public static function ylerp(y0:Float,y1:Float,x:Float,v0:Float,v1:Float,iso:Float->Float->Float,quality:Int) {
		var ym = lerp(y0,y1,v0,v1);
		while(quality--!=0) {
			var vm = iso(x,ym);
			if(v0*vm<0) { y1 = ym; v1 = vm; }
			else        { y0 = ym; v0 = vm; }
			ym = lerp(y0,y1,v0,v1);
		}
		return ym;
	}
}
