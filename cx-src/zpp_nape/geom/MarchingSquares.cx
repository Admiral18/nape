package zpp_nape.geom;
$(import);

$(mixin Vertex() PR(GeomVert));
$(mixin Polygon() Vertex);

$(mixin VPair() PR(MarchPair));

$(mixin ID() PR(MarchID));

class ID {
	static var nextId = 0;
	public var id:Int;

	//easier to determine along a scan line like this.
	public var freed:Bool;

	MixPool(ID)
	flibmdel public inline function free() { freed = true; }
	flibmdel public inline function alloc() { freed = false; }

	public function new() id = nextId++
}

class VPair {
	//saddle points may generate 2 polygons.
	// p1 will always combine left
	// p2 will always combine right
	public var p1:Polygon; public var key1:Int;
	public var p2:Polygon; public var key2:Int;

	// right polygon (might not be combRight'able)
	// pr = p2 if p2!=null else p1
	public var pr:Polygon; public var keyr:Int;

	// pointer to downlink (as connections get destroyed in LR comb)
	public var pd:Polygon;

	//to compare polygons with since Polygon is a pointer to some vertex, not the whole polygon.
	public var id1:ID;
	public var id2:ID;
	public var idr:ID;
	
	MixPool(VPair)
	flibmdel public inline function free() {
		//temporary
		p1 = p2 = pr = pd = null;
		//---------
		assert(p1==null && p2==null && pr==null, "free VPair (march) non-null polys");

		if(!id1.freed) Free(ID,id1);
		if(id2!=null && !id2.freed) Free(ID,id2);
		id1 = id2 = idr = null;
	}
	flibmdel public inline function alloc() {}

	public function new() {}
}

class PR(MarchingSquares) {

	public static function run(iso:Float->Float->Float,bx0:Float,by0:Float,bx1:Float,by1:Float,cell:Vec2,quality:Int,combine:Bool,ret:GeomPolyList) {

		var xp = (bx1-bx0)/cell.x; var xn:Int = fastint(xp);
		var yp = (by1-by0)/cell.y; var yn:Int = fastint(yp);
		if(xp!=xn) xn++;
		if(yp!=yn) yn++;

		var map:Array2<VPair> = null;
		if(combine) map = new Array2<VPair>(xn,yn);

		for(y in 0...yn) {
			var y0 = by0 + cell.y*y;
			var y1 = if(y==yn-1) by1 else y0+cell.y;

			var pre:VPair = null;
			for(x in 0...xn) {
				var x0 = bx0 + cell.x*x;
				var x1 = if(x==xn-1) bx1 else x0+cell.x;

				var pp = marchSquare(iso,x0,y0,x1,y1,quality);
				if(pp==null) { pre = null; continue; }

				if(combine) {
					//determine which poly is down
					//and store down link prematurely
					//since links are destroyed in LR comb
					var pd = if(pp.p2!=null && pp.key2!=14) pp.p2 else pp.p1;
					pp.pd = linkdown(pd,pd==pp.p2 ? pp.key2 : pp.key1);

					map.set(x,y, pp);
					assert((pre!=null)==combLeft(pp.key1), "left exists =/= can combine");
					if(pre!=null) {
						assert(combRight(pre.keyr), "left poly cannot comb right?");
						combLR(pre,pp);
					}

					if(combRight(pp.keyr)) pre = pp;
					else pre = null;
				}else {
					var p = new GeomPoly();
					p.pr(inner).vertices = pp.p1;
					ret.add(p);
					if(pp.p2!=null) {
						p = new GeomPoly();
						p.pr(inner).vertices = pp.p2;
						ret.add(p);
					}
				}
			}
		}

		if(!combine) return;

		for(y in 1...yn) {
			for(x in 0...xn) {
				var b = map.get(x,y);
				if(b==null) continue;

				var bkey = if(b.p2!=null && b.key2==0x0e) b.key2 else b.key1;
				if(!combUp(bkey)) continue;

				var a = map.get(x,y-1);
				assert(a!=null,"combine up, but no poly?");

				//determine up/down ids on a,b
				var ad = if(a.p2!=null && a.key2==0x38) a.id2 else a.id1;
				var bu = if(b.p2!=null && b.key2==0x0e) b.id2 else b.id1;

				//cannot combine up as either scan line already combined
				//or it would introduce a hole if not.
				if(ad.id==bu.id) continue;

				combUD(a,b);
			}
		}

		var keyh = new IntHash<Bool>();
		for(y in 0...yn) {
			for(x in 0...xn) {
				var p = map.get(x,y);
				if(p==null) continue;

				if(!keyh.exists(p.id1.id)) {
					keyh.set(p.id1.id,true);
					var pp = new GeomPoly();
					pp.pr(inner).vertices = p.p1;
					ret.add(pp);
				}

				if(p.p2 != null && !keyh.exists(p.id2.id)) {
					keyh.set(p.id2.id,true);
					var pp = new GeomPoly();
					pp.pr(inner).vertices = p.p2;
					ret.add(pp);
				}
			}
		}
	}

	// given a polygon from a VPair with it's key
	// return vertex for start of merge in a combLR.
	// values determined via analysis of all cases.
	//
	// possible configurations for a combRight'able VPair poly:
	// ( p = current pointer, t = target pointer)
	//
	//   p                       p                   p
	//   o---o t               . o-o t               o---o t
	//   |-#-| key = 01010101  . .`o key = 00001110  o---o key = 10001101
	//   o---o                 . . .                 . . .
	//
	//     p                                         
	//   . o-o t               . . . key = 00111000  . . . key = 10011000
	//   . | | key = 00110110  . .,o pt              o---o pt
	//   . o-o                 . o-o                 o---o
	//
	//   p                       p                     p
	//   o-o . key = 10111011  . o-o t               . o-o t
	//   o #`o t               o`#-o key = 11101110  o-#-| key = 11010110
	//   .`o-o                 o-o`.                 o---o
	//
	//   p                     p                     p
	//   o---o t               o---o t               o-o . key = 01011011
	//   o-#-| key = 10110101  |-#-o key = 01101101  |-#`o t
	//   .`o-o                 o-o`,                 o---o
	//
	// pointer either needs to be skipped forward 0,1 or 2 times.
	//
	// 1 time: 01010101  0 times: 00111000  2 times: 10111011
	//         10110101           10011000           01011011
	//         01101101                ^^^                ^^^
	//         10001101
	//         00001110
	//         11101110
	//         00110110
	//         11010110
	//              ^^^
	// first 3 bits are enough to classify the number of skips needed.
	//
	public static inline function linkright(poly:Polygon,key:Int) {
		var kind = key&7;
		if  (kind==0) return poly;
		elif(kind==3) return poly.next.next;
		else          return poly.next;
	}

	// given a polygon from a VPair with it's key
	// return vertex from start of merge in a combLR.
	// values determined via analysis of all cases.
	//
	// possible configurations for a combLeft'able VPair poly:
	// ( p = current pointer, t = target pointer)
	//
	//  pt                    pt                    pt
	//   o---o                 o-o .                 o---o
	//   |-#-| key = 01010101  o`. . key = 10000011  o---o key = 10001101
	//   o---o                 . . .                 . . .
	//
	//  pt                                         
	//   o-o .                  . . . key = 00111000  . . . key = 10011000
	//   | | . key = 01100011 t o,. .               t o---o p
	//   o-o .                  o-o .                 o---o
	//                            p
	//  pt                       p                      p
	//   o-o . key = 10111011  . o-o                  . o-o
	//   o #`o               t o`#-o key = 11101110 t o-#-| key = 11010110
	//   .`o-o                 o-o`.                  o---o
	//
	//  pt                    pt                    pt
	//   o---o                 o---o                 o-o . key = 01011011
	//   o-#-| key = 10110101  |-#-o key = 01101101  |-#`o
	//   .`o-o                 o-o`,                 o---o
	//
	// pointer either needs to be skipped backwards once or not at all.
	//
	// 0 times: 01010101  1 times: 00111000
	//          01100011           11101110
	//          10111011           11010110
	//          10111011           10011000
	//          10110101                  ^
	//          10000011
	//          01101101
	//          10001101
	//          01011011
	//                 ^
	// first bit is enough to classify number of skips needed
	//
	public static inline function linkleft(poly:Polygon,key:Int) {
		return if((key&1)==0) poly.prev else poly;
	}

	// given a polygon from a VPair with it's key
	// return vertex from start of merge in combUD.
	// values determined via analysis of all cases.
	//
	// possible configurations for a combDown'able VPair poly:
	// ( p = current point, t = target point)
	//
	//   p                    
	//   o---o                . . . key = 00111000 . . . key = 10011000 
	//   |-#-| key = 01010101 . .,o p              o---o p
	// t o---o                . o-o              t o---o
    //                          t        
	//   p                                           p
	//   o-o .                . . . key = 11100000 . o-o
	//   | | . key = 01100011 o,. .                . | | key = 00110110
	// t o-o .              t o-o .                . o-o
	//                          p                    t
	//   p                      p
	//   o-o . key = 10111011 . o-o                  p
	//   o #`o                o`#-o key = 11101110 . o-o
	//   .`o-o                o-o`.                o`#-| key = 11010110
	//     t                  t                  t o---o
	//   p                    p
	//   o---o                o---o                p
	//   o-#-| key = 10110101 |-#-o key = 01101101 o-o . key = 01011011
	//   .`o-o              t o-o`.                |-#`o
	//     t                                     t o---o
	//
	// pointer either needs to be skipped backwards once or twice.
	//
	// 1 time: 01010101  2 times: 10011000
	//         00111000           11100000
	//         01100011           10111011
	//         00110110           11101110
	//         01101101           11010110
	//         01011011           10110101
	//         ^                  ^
	// last bit is enough to classify number of skips needed
	//
	public static inline function linkdown(poly:Polygon,key:Int) {
		return if((key&0x80)==0) poly.prev else poly.prev.prev;
	}

	// given a polygon from a VPair with it's key
	// return vertex from start of merge in combUD.
	// trivially, this is simply the start vertex.
	public static inline function linkup(poly:Polygon,key:Int) return poly
	                  
	public static function combLR(a:VPair,b:VPair) {
		//set up pointers for merge
		var ap:Polygon = linkright(a.pr,a.keyr);
		var bp:Polygon = linkleft (b.p1,b.key1);

		// we now have ap==bp and ap.next == bp.prev (implicitly; not by reference)
		// we now merge, discarding bp and bp.prev (trivial duplicates)
		// as well as discarding ap if (a.keyr&0x04 != 0)
		//              and ap.next if (a.keyr&0x10 != 0)
		// so as to discard collinear horizontal vertices along scan line
		// (simplifies combUD)

		var ap2 = ap.next;
		var bp2 = bp.prev;

		// merge on top.
		if((a.keyr&0x04)!=0) {
			//in this case we must fix VPair pointer p1 (and possible pr) on b
			if(b.pr==b.p1) b.pr = ap.prev;
			b.p1 = ap.prev;
			//discard both ap and bp
			ap.prev.next = bp.next;
			bp.next.prev = ap.prev;
			Free(Vertex,ap);
		}else {
			//discard bp only
			ap.next = bp.next;
			bp.next.prev = ap;
		}
		Free(Vertex,bp);

		// merge on bottom.
		if((a.keyr&0x10)!=0) {
			//in this case we must fix VPair pointer pd on b
			b.pd = ap2.next;
			//discard both ap2 and bp2
			ap2.next.prev = bp2.prev;
			bp2.prev.next = ap2.next;
			Free(Vertex,ap2);
		}else {
			//discard only bp2
			ap2.prev = bp2.prev;
			bp2.prev.next = ap2;
		}
		Free(Vertex,bp2);

		// re-assign id
		// we assign the entire scan line the same ID object.
		// which is essential in UD merge.
		if(b.idr==b.id1) b.idr = a.idr;
		//free old b.id1!
		b.id1 = a.idr;
	}

	public static function combUD(a:VPair,b:VPair) {
		//determine up/down polys on a,b
		var ad = if(a.p2!=null && a.key2==0x38) a.p2 else a.p1;
		var bu = if(b.p2!=null && b.key2==0x0e) b.p2 else b.p1;

		//set up pointers for merge
		var ap:Polygon = a.pd; //already been calced as LR comb destroys links required
		var bp:Polygon = linkup(bu,bu==b.p2 ? b.key2 : b.key1);

		//skip back from ap to end of merge
		//skip forward from bp to end of merge
		//since we removed collinear horizontals, this is trivial
		var ap2 = ap.prev;
		var bp2 = bp.next;

		// we now have ap==bp && ap2 == bp2 (implicitly; not by reference)
		// we now merge, disacrding bp and bp2 (trivial duplicates)
		// merge on left.
		bp.next = ap.next;
		ap.next.prev = bp;
		Free(Vertex,ap);

		// merge on right.
		bp2.prev = ap2.prev;
		ap2.prev.next = bp2;
		Free(Vertex,ap2);

		// re-assign id (don't care abuot right poly ref. anymore)
		// we do this via setting the internal id.
		// as the entire scan line shares the same Id object.
		// this sets the id for the entire scan line! (essential to avoid holes!)
		var aid = if(ad==a.p1) a.id1 else a.id2;
		if(bu==b.p1) b.id1.id = aid.id;
		else         b.id2.id = aid.id;
	}

	public static function draw(p:Polygon,col:Int) {
		var gp = new GeomPoly();
		gp.pr(inner).vertices = p;
		DummyNapeMain.debug.drawFilledPolygon(gp,col);
		DummyNapeMain.debug.drawPolygon(gp,(col&0xfefefe)>>1);
		mix_circular(Vertex,
			for_iter(v,p, DummyNapeMain.debug.drawCircle(Vec2.get(v.x,v.y),1,0xff0000));
		)
		DummyNapeMain.debug.flush();
	}

	public static inline function combLeft (key:Int) return (key&0xC1)!=0
	public static inline function combRight(key:Int) return (key&0x1C)!=0
	public static inline function combUp   (key:Int) return (key&0x07)!=0
	public static inline function combDown (key:Int) return (key&0x70)!=0

	// generate polygon for a single cell.
     // we do 'NOT' remove degenerate edges for duplicated vertices
     // as we rely on the strict configurations to simplify the rest of the algorithms.
     //
	public static var look_march = [-1,0xE0,0x38,0xD8,0x0E,-1,0x36,0xD6,0x83,0x63,-1,0x5B,0x8D,0x6D,0xB5,0x55];
	public static inline function marchSquare(iso:Float->Float->Float,x0:Float,y0:Float,x1:Float,y1:Float,quality:Int) {
		var key = 0;
		var v0 = iso(x0,y0); if(v0<0) key |= 8;
		var v1 = iso(x1,y0); if(v1<0) key |= 4;
		var v2 = iso(x1,y1); if(v2<0) key |= 2;
		var v3 = iso(x0,y1); if(v3<0) key |= 1;

		if(key==0) return null;
		else {
			var ret = Get(VPair);
			if(key!=10 && key!=5) {
				var val = look_march[key];
				poly(val,1);
				setright(1);
			}else {
				var mid = iso(0.5*(x0+x1),0.5*(y0+y1)) < 0;
				if(key==10) {
					if(mid) {
						poly(0xBB,1);
						setright(1);
					} else {
						poly(0x83,1);
						poly(0x38,2);
						setright(2);
					}
				}else {
					if(mid) {
						poly(0xEE,1);
						setright(1);
					} else {
						poly(0xE0,1);
						poly(0x0E,2);
						setright(2);
					}
				}
			}
			$(mixin setright(n) {
				ret.pr = ret.p`n;
				ret.keyr = ret.key`n;
				ret.idr = ret.id`n;
			});
			return ret;
		}

		$(mixin poly(val,out) {
			mix_circular(Vertex,
				for(i in 0...8) {
					if((val&(1<<i))!=0) {
						var p = 
							if  (i==0) Vertex.get(x0,y0)
							elif(i==2) Vertex.get(x1,y0)
							elif(i==4) Vertex.get(x1,y1)
							elif(i==6) Vertex.get(x0,y1)
	
							elif(i==1) Vertex.get(xlerp(x0,x1,y0,v0,v1,iso,quality),y0)
							elif(i==5) Vertex.get(xlerp(x0,x1,y1,v3,v2,iso,quality),y1)
	
							elif(i==3) Vertex.get(x1,ylerp(y0,y1,x1,v1,v2,iso,quality))
							else       Vertex.get(x0,ylerp(y0,y1,x0,v0,v3,iso,quality));
						ret.p`out = push_after(ret.p`out,p);
					}
				}
				ret.p`out = ret.p`out.next;
			)
			ret.key`out = val;
			ret.id`out = Get(ID);
		});
	}

	public static inline function lerp(x0:Float,x1:Float,v0:Float,v1:Float) {
		var dv = v0-v1;
		var t = if(dv*dv<PR(Const).EPSILON) 0.5 else v0/dv;
		return x0 + t*(x1-x0);
	}
	public static inline function xlerp(x0:Float,x1:Float,y:Float,v0:Float,v1:Float,iso:Float->Float->Float,quality:Int) {
		var xm = lerp(x0,x1,v0,v1);
		while(quality--!=0) {
			var vm = iso(xm,y);
			if(v0*vm<0) { x1 = xm; v1 = vm; }
			else        { x0 = xm; v0 = vm; }
			xm = lerp(x0,x1,v0,v1);
		}
		return xm;
	}
	public static function ylerp(y0:Float,y1:Float,x:Float,v0:Float,v1:Float,iso:Float->Float->Float,quality:Int) {
		var ym = lerp(y0,y1,v0,v1);
		while(quality--!=0) {
			var vm = iso(x,ym);
			if(v0*vm<0) { y1 = ym; v1 = vm; }
			else        { y0 = ym; v0 = vm; }
			ym = lerp(y0,y1,v0,v1);
		}
		return ym;
	}
}
