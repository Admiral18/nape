package zpp_nape.geom;
$(import);

$(mixin Vertex() PR(SimpleVert));
class Vertex {
	vec_new(public,$(->));
	public var links:Set(Vertex);

	static var nextId:Int = 0;
	public var id:Int;

	MixPool(Vertex)
	public var prev:Vertex; //for Circular list.
	flibmdel public inline function free() {}
	flibmdel public inline function alloc() {}

	function new() {
		id = nextId++;
		links = Get(Set(Vertex));
		links.lt = less_xy;
	}
	public static inline function less_xy(p:Vertex,q:Vertex) {
		return p.y < q.y || (p.y==q.y && p.x < q.x);
	}

	public static inline function get(x:Float,y:Float) {
		var ret = Get(Vertex);
		vec_set(ret.,$(->));
		return ret;
	}
}

$(mixin Segment() PR(SimpleSeg));
class Segment {
	public var left :Vertex;
	public var right:Vertex;

	public var cleft:Vertex; //current 'real' left

	static var nextId = 0;
	public var id:Int;

	MixPool(Segment)
	flibmdel public inline function free() {
		left = right = null;
		cleft = null;
		prev = null;
		node = null;
	}
	flibmdel public inline function alloc() {}

	//prev,next refer to positions in sweep line tree.
	public var prev:Segment;

	//node in sweep line tree
	public var node:Set(Segment);

	function new() {
		id = nextId++;
	}
	public static inline function get(left:Vertex,right:Vertex) {
		var ret = Get(Segment);
		ret.left  = left;
		ret.cleft = left;
		ret.right = right;
		return ret;
	}
}

$(mixin LEFT  0);
$(mixin INT   1);
$(mixin RIGHT 2);

$(mixin Event() PR(SimpleEvent));
class Event {
	
	//type == LEFT  => vertex = segment.left
	//type == RIGHT => vertex = segment.right
	//type == INT   => other<>null and vertex is segment+other intersection
	public var type:Int;	

	public var vertex:Vertex;
	public var segment :Segment;
	public var segment2:Segment;

	//node in tree when doing a decomposition.
	public var node:Set(Event);
	public static inline function swap_nodes(a:Event, b:Event) swap(a.node,b.node)
	public static inline function less_xy(a:Event, b:Event) {
		if  (a.vertex.x < b.vertex.x) return true;
		elif(a.vertex.x > b.vertex.x) return false;
		else {
			if  (a.vertex.y < b.vertex.y) return true;
			elif(a.vertex.y > b.vertex.y) return false;
			else return a.type < b.type;
		}
	}

	MixPool(Event)
	flibmdel public inline function free() {
		vertex = null;
		segment = segment2 = null;
	}
	flibmdel public inline function alloc() {}
	function new() {}

	public static inline function get(v:Vertex) {
		var ret = Get(Event);
		ret.vertex = v;
		return ret;
	}
}


$(mixin Sweep() PR(SimpleSweep));
class Sweep {
	public var sweepx:Float; //used in sorting segments which intersect
	public var tree:Set(Segment);

	public function new() {
		tree = Get(Set(Segment));
		tree.lt = edge_lt;
		tree.swapped = swap_nodes;
	}

	public function swap_nodes(p:Segment,q:Segment) swap(p.node,q.node)
	public function edge_lt(p:Segment,q:Segment) {
		vec_new(u); vec_new(v);
		var flip:Bool;
		$(mixin comp_y_at_x(vertex,edge) ({
			//assume edge not vertical
			flip = edge.right.x < edge.left.x;
			vec_sub(edge.right.,edge.left., u);
			vec_sub(vertex.,edge.left.,v);
			flip ? vec_cross(v,u) : vec_cross(u,v);
		}));
		$(mixin lrg_y_vertex_x(edge,vertex) ({
			if(edge.left.x==edge.right.x) {
				if(edge.left.y < edge.right.y)
					 edge.left.y > vertex.y;
				else edge.right.y > vertex.y;
			}else
				comp_y_at_x(vertex,edge) < 0;
		}));

		if(p.left==q.left && p.right==q.right) return false;
		elif(p.left ==q.right) return  lrg_y_vertex_x(p,q.left);
		elif(p.right==q.left ) return !lrg_y_vertex_x(q,p.left);
		elif(p.left ==q.left ) return  lrg_y_vertex_x(p,q.right);
		elif(p.right==q.right) return  lrg_y_vertex_x(p,q.left);

		//neither end point shared.
		if(p.left.x==p.right.x) {
			if(q.left.x==q.right.x) {
				var pmax = if(p.left.y < p.right.y) p.right else p.left;
				var qmax = if(q.left.y < q.right.y) q.right else q.left;
				return pmax.y > qmax.y;
			}else {
				var  plrg = comp_y_at_x(p.left,q);
				var aplrg = comp_y_at_x(p.right,q);
				if(plrg*aplrg>=0) return plrg >= 0.0;
				else //take into accoutn sweep oisition
					return sweepx >= p.left.x;
			}
		}else if(q.left.x==q.right.x) {
			var  qlrg = comp_y_at_x(q.left,p);
			var aqlrg = comp_y_at_x(q.right,p);
			if(qlrg*aqlrg>=0) return qlrg < 0.0;
			else //take into account sweep position
				return sweepx < q.left.x;
		}else {
			var qlrg  = comp_y_at_x(q.left,p) < 0.0;
			var aqlrg = comp_y_at_x(q.right,p) < 0.0;
			if  (qlrg==aqlrg)         return qlrg;
			else {
				var  plrg = comp_y_at_x(p.left,q) >= 0.0;
				var aplrg = comp_y_at_x(p.right,q) >= 0.0;
				if(plrg==aplrg) return plrg;

				//take into account sweep position
				var py = (sweepx - p.left.x)/(p.right.x-p.left.x)*(p.right.y-p.left.y) + p.left.y;
				var qy = (sweepx - q.left.x)/(q.right.x-q.left.x)*(q.right.y-q.left.y) + q.left.y;
				return py > qy;
			}
		}
	}

	public inline function clear() {
		tree.clear();
	}

	public inline function add(e:Segment) {
		e.node = tree.insert(e);
		var nxt = tree.successor_node(e.node);
		var pre = tree.predecessor_node(e.node);
		if(nxt!=null) { e.next = nxt.data; nxt.data.prev = e; }
		if(pre!=null) { e.prev = pre.data; pre.data.next = e; }
		return e;
	}
	public inline function remove(e:Segment) {
		var nxt = tree.successor_node(e.node);
		var pre = tree.predecessor_node(e.node);
		if(nxt!=null) nxt.data.prev = e.prev;
		if(pre!=null) pre.data.next = e.next;
		tree.remove_node(e.node);
	}

	public inline function intersect(p:Segment,q:Segment) {
		if(p==null || q==null) return false;
		elif(p.left==q.left
		  || p.left==q.right
		  || p.right==q.left
		  || p.right==q.right) return false;
		else {
			$(mixin isLeft(a,b,c) ((c.x-a.x)*(b.y-a.y) - (b.x-a.x)*(c.y-a.y)));
			var lsign = isLeft(p.left,p.right,q.left);
			var rsign = isLeft(p.left,p.right,q.right);
			if(lsign*rsign > 0) return false;
			else {
				lsign = isLeft(q.left,q.right,p.left);
				rsign = isLeft(q.left,q.right,p.right);
				if(lsign*rsign > 0) return false;
				else return true;
			}
		}
	}

	public function intersection(p:Segment,q:Segment) {
		if(p==null || q==null) return null;
		elif(p.left ==q.left
		  || p.left ==q.right
		  || p.right==q.left
		  || p.right==q.right) return null;
		else {
			vec_new(u); vec_sub(p.right.,p.left.,u);
			vec_new(v); vec_sub(q.right.,q.left.,v);

			var denom = vec_cross(u,v);
			if(denom==0.0) return null;

			denom = 1/denom;
			vec_new(c); vec_sub(q.left.,p.left.,c);

			var t = vec_cross(c,v)*denom;
			if(t<0 || t>1) return null;
			
			var s = vec_cross(c,u)*denom;
			if(s<0 || s>1) return null;
			
			if(s==0||s==1||t==0||t==1) throw "corner case 1";

			var vet = Vertex.get(
				0.5*(p.left.x + ux*t + q.left.x + vx*s),
				0.5*(p.left.y + uy*t + q.left.y + vy*s)
			); 
			var ret = Event.get(vet);
			ret.type = INT;
			ret.segment  = p;
			ret.segment2 = q;

			DummyNapeMain.debug.drawCircle(Vec2.get(vet.x,vet.y),2,0xff0000);
			DummyNapeMain.debug.flush();

			return ret;
		}
	}
}

class PR(Simple) {
	static var sweep:Sweep = new Sweep();

	public static function decompose(poly:PR(GeomVert)) {
		var vertices:Vertex = null;
		var vite:PR(GeomVert) = poly;
		do { mix_circular(Vertex,
			vertices = push_after(vertices,Vertex.get(vite.x,vite.y));
			vite = vite.next;
		)}while(vite!=poly);

		var inthash = new FastHash2(Hashable2(Bool))();

		var queue = Get(Set(Event));
		queue.lt = Event.less_xy;
		queue.swapped = Event.swap_nodes;
		mix_circular(Vertex,for_iter(u,vertices,{
			var v = u.next;

			var e1 = Event.get(u);
			var e2 = Event.get(v);
			var seg:Segment; 
			if(Event.less_xy(e1,e2)) {
				e1.type = LEFT; e2.type = RIGHT;
				seg = Segment.get(u,v);
			}else {
				e1.type = RIGHT; e2.type = LEFT;
				seg = Segment.get(v,u);
			}
			e1.segment = e2.segment = seg;
			queue.insert(e1);
			queue.insert(e2);
			u.links.insert(v);
			v.links.insert(u);
		}));

		while(!queue.empty()) {
			var e = queue.pop_front();
			sweep.sweepx = e.vertex.x;

			$(mixin do_intersect(high,low) {
				var has = high!=null && low!=null && (high.id < low.id ? inthash.has(high.id,low.id) : inthash.has(low.id,high.id));
				if(!has) {
					var int = sweep.intersection(high,low);
					if(int!=null) {
						if(int.vertex.x >= sweep.sweepx) {
							var ex = SetFind(queue,int);
							if(ex==null) {
								queue.insert(int);
								if(high.id<low.id)
									 inthash.add(Hashable2(Bool).get(high.id,low.id,true));
								else inthash.add(Hashable2(Bool).get(low.id,high.id,true));
							}else {
								var x = ex.data;
								if(x.segment!=int.segment || int.segment2!=x.segment2)
									throw "corner case 2, very rare!";
								Free(Vertex,int.vertex);
								Free(Event,int);
							}
						}else {
							Free(Vertex,int.vertex);
							Free(Event,int);
						}
					}
				}
			});

			if(e.type==LEFT) {
				var s = e.segment;
				sweep.add(s);
				do_intersect(s.next,s);
				do_intersect(s,s.prev);
			}else if(e.type==RIGHT) {
				var s = e.segment;
				var nxt = s.next;
				var pre = s.prev;
				sweep.remove(s);
				do_intersect(nxt,pre);
			}else {
				var int = e.vertex;
				var a = e.segment; var b = e.segment2;
				assert((a.prev==b && b.next==a) || (b.prev==a && a.next==b),"no.!!!");
				if(b.next!=a) swap(a,b);

				//cut segments at intersection
				a.cleft.links.remove(a.right); a.cleft.links.insert(int);
				a.right.links.remove(a.cleft); a.right.links.insert(int);
				b.cleft.links.remove(b.right); b.cleft.links.insert(int);
				b.right.links.remove(b.cleft); b.right.links.insert(int);

				int.links.insert(a.cleft); int.links.insert(a.right);
				int.links.insert(b.cleft); int.links.insert(b.right);

				a.cleft = int; b.cleft = int;
				mix_circular(Vertex,
					vertices = push_after(vertices,int);
				)

				//swap position in tree, a little messy
				var an = a.node; var bn = b.node;
				an.data = b; bn.data = a;
				a.node = bn; b.node = an;

				b.next = a.next; a.next = b;
				a.prev = b.prev; b.prev = a;
				if(a.prev!=null) a.prev.next = a;
				if(b.next!=null) b.next.prev = b;

				do_intersect(b.next,b);
				do_intersect(a,a.prev);
			}
		}

		assert(queue.empty(),"clean up fail");
		Free(Set(Event),queue);	
		ClearHashWith(inthash,$(mixin cb(x) Free(Hashable2(Bool),x)));

		//construct decomposition. yaaay!
		var rets = new List(PR(GeomVert))();
		mix_circular(Vertex,
			vertices = sort(vertices, Vertex.less_xy);	
			while(!empty(vertices)) {
				vertices = clip_polygon(vertices,rets);
			}
		)

		return rets;
	}

	public static function clip_polygon(vertices:Vertex, rets:List(PR(GeomVert))) {
		var ret:PR(GeomVert) = null;
		assert(vertices.links.size()==2,"damnit!");

		var cur = vertices;
		var fst = cur;
		//previous and next vertices
		var pren = vertices.links.parent;
		var nxtn = if(pren.prev==null) pren.next else pren.prev;
		var pre = pren.data;
		var nxt = nxtn.data;

		$(mixin left_turn(a,b,c) ({
			vec_new(u); vec_sub(b.,a.,u);
			vec_new(v); vec_sub(c.,b.,v);
			vec_cross(u,v);
		}));

		//want to walk clockwise
		if(left_turn(pre,cur,nxt) < 0) nxt = pre;
	
		$(mixin popvertex(v) {
			mix_circular(Vertex,
				if(v==vertices) vertices = pop_ret_after(vertices);
				else pop(v);
			)
		});

		mix_circular(PR(GeomVert), ret = push_after(ret, PR(GeomVert).get(cur.x,cur.y)));

		while(true) {
			//walk to nxt.
			cur.links.remove(nxt);
			nxt.links.remove(cur);

			if(nxt==fst) break;

			mix_circular(PR(GeomVert), ret = push_after(ret, PR(GeomVert).get(nxt.x,nxt.y)));
			assert(!nxt.links.empty(),".. no where left to go?");
			
			if(nxt.links.singular()) {
				popvertex(nxt);
				cur = nxt;
				nxt = nxt.links.parent.data;
			}else {
				var min = null; var minl:Float = 0.0;
				SetIter(p,nxt.links,{
					if(min==null) {
						min = p;
						minl = left_turn(cur,nxt,p);
					}else {
						var nleft = left_turn(cur,nxt,p);
						if(nleft > 0 && minl <= 0) {
							min = p;
							minl = nleft;
						}else if(minl*nleft >= 0) {
							var pleft = left_turn(p,nxt,min);
							if(pleft>0) {
								min = p;
								minl = nleft;
							}
						}
					}
				});

/*				var g = cast(DummyNapeMain.debug,ShapeDebug).pr(inner_zn).graphics;
				g.lineStyle(0.1,0xff,1);
				g.drawCircle(cur.x,cur.y,4);
				g.moveTo(cur.x,cur.y);
				g.curveTo(nxt.x,nxt.y,min.x,min.y);
*/
				cur = nxt;
				nxt = min;
			}
		}

		assert(fst.links.empty(),"hmm, shouldn't have any left");
		popvertex(fst);

		rets.add(ret);
		return vertices;
	}

	public static function isSimple(poly:PR(GeomVert)) {
		var vertices = new List(Vertex)();
		mix_circular(PR(GeomVert),for_iter(v,poly,{
			vertices.add(Vertex.get(v.x,v.y));
		}));

		var queue = new List(Event)();
		Iter2_fast(u,v,vertices,{
			var e1 = queue.add(Event.get(u));
			var e2 = queue.add(Event.get(v));
			e1.segment = e2.segment = 
				if(Event.less_xy(e1,e2)) {
					e1.type = LEFT; e2.type = RIGHT;
					Segment.get(u,v);
				}else {
					e1.type = RIGHT; e2.type = LEFT;
					Segment.get(v,u);
				}
		});
		Sort(queue,Node(Event),Event.less_xy);

		var ret = true;
		while(!queue.empty()) {
			var e = queue.pop_unsafe();
			var seg = e.segment;
			if(e.type==LEFT) {
				sweep.add(seg);
				if(sweep.intersect(seg,seg.next)
				|| sweep.intersect(seg,seg.prev)) {
					ret = false;
					break;
				}
			}elif(e.type==RIGHT) {
				if(sweep.intersect(seg.prev,seg.next)) {
					ret = false;
					break;
				}
				sweep.remove(seg);
				Free(Segment,seg);
			}
			Free(Event,e);
		}

		//release any unreleased objects
		while(!queue.empty()) {
			var e = queue.pop_unsafe();
			if(e.type==RIGHT)
				Free(Segment,e.segment);
			Free(Event,e);
		}
		sweep.clear();

		//release vertices
		while(!vertices.empty()) Free(Vertex,vertices.pop_unsafe());

		return ret;
	}

}
