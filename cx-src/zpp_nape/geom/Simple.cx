package zpp_nape.geom;
$(import);

$(mixin Vertex() PR(GeomVert));
$(mixin Edge() Vertex);
$(mixin Polygon() Vertex);

$(mixin Event() PR(SimpleEvent));
$(mixin Sweep() PR(SimpleSweep));

$(mixin LEFT  0);
$(mixin RIGHT 1);
$(mixin INT   2);

class Event {
	public var vertex:Vertex;
	vec_new(public,$(->));

	public var type:Int; //as opposed to right.
	//for INT, other/fst dual for the corresponding segments for the intersection.
	public var other:Event; //corresponding Event for segment
	public var fst:Event; //always refers to first event for segment, whether left or right

	//prev,next used in Sweepline to denote below/above segments.
	MixPool(Event)
	public var prev:Event;

	public static function edge_lt(ps:Event,qs:Event) {
		var p = ps.fst;
		var q = qs.fst;

		vec_new(u); vec_new(v);
		var flip:Bool;
		$(mixin comp_y_at_x(vertex,edge) ({
			//assume edge not vertical
			flip = edge.other.x < edge.x;
			vec_sub(edge.other.,edge., u);
			vec_sub(vertex.,edge.,v);
			/*return*/ flip ? vec_cross(v,u) : vec_cross(u,v);
		}));
		$(mixin lrg_y_vertex_x(edge,vertex) ({
			if(edge.x==edge.other.x) {
				if(edge.y < edge.other.y)
					 edge.y > vertex.y;
				else edge.other.y > vertex.y;
			}else
				comp_y_at_x(vertex,edge) < 0;
		}));

		if  (p.vertex==q.vertex && p.other.vertex==q.other.vertex) return false;
		elif(p.vertex==q.other.vertex)       return  lrg_y_vertex_x(p,q);
		elif(p.other.vertex==q.vertex)       return !lrg_y_vertex_x(q,p);
		elif(p.vertex==q.vertex)             return  lrg_y_vertex_x(p,q.other);
		elif(p.other.vertex==q.other.vertex) return  lrg_y_vertex_x(p,q);
		//neither endpoint shared
		elif(p.x==p.other.x) {
			if(q.x==q.other.x) {
				var pmax = if(p.y < p.other.y) p.other else p;
				var qmax = if(q.y < q.other.y) q.other else q;
				return pmax.y > qmax.y;
			}else
				return comp_y_at_x(p,q) > 0;
		}else {
			var qlrgv = comp_y_at_x(q,p);
			var  qlrg = qlrgv < 0;
			var aqlrg = comp_y_at_x(q.other,p) < 0;
			if  (qlrg==aqlrg) return qlrg;
			elif(q.x==q.other.x)
				 return qlrgv > 0;
			else return comp_y_at_x(p,q) >= 0;
		}
	}

	flibmdel public inline function free() {
		vertex = null;
		other = null;
		fst = null;
		prev = null;
	}
	flibmdel public inline function alloc() {}

	function new() {}
	public static inline function get(v:Vertex) {
		var ret = Get(Event);
		ret.vertex = v;
		vec_set(ret.,v.);
		return ret;
	}
}

class Sweep {
	public var tree:Set(Event);
	public function new() {
		tree = Get(Set(Event));
		tree.lt = Event.edge_lt;
	}

	public inline function clear() {
		tree.clear();
	}

	public inline function add(e:Event) {
		tree.insert(e);
		var nx = tree.successor(e);
		var np = tree.predecessor(e);
		if(nx!=null) { e.next = nx; nx.prev = e; }
		if(np!=null) { e.prev = np; np.next = e; }
		return e;
	}
	public inline function remove(e:Event) {
		var nx = tree.successor(e);
		var np = tree.predecessor(e);
		if(nx!=null) nx.prev = e.prev;
		if(np!=null) np.next = e.next;
		tree.remove(e);
	}

	public inline function intersect(s1:Event,s2:Event) {
		$(mixin isLeft(a,b,c) (-((b.x-a.x)*(c.y-a.y) - (c.x-a.x)*(b.y-a.y))));

		if(s1==null || s2==null) return false;
		elif(s1.vertex==s2.vertex
 		  || s1.vertex==s2.other.vertex
		  || s1.other.vertex==s2.vertex
		  || s1.other.vertex==s2.other.vertex)
			return false;
		else {
			var lsign = isLeft(s1,s1.other,s2);
			var rsign = isLeft(s1,s1.other,s2.other);
			if(lsign*rsign > 0) return false;
			else {
				lsign = isLeft(s2,s2.other,s1);
				rsign = isLeft(s2,s2.other,s1.other);
				if(lsign*rsign > 0) return false;
				else return true;
			}
		}
	}

	public inline function intersection(s1:Event,s2:Event) {
		vec_new(u); vec_sub(s1.other.,s1.,u);
		vec_new(v); vec_sub(s2.other.,s2.,v);

		var denom = vec_cross(u,v);
		if(denom==0.0) return null;
		else {
			vec_new(c); vec_sub(s2.,s1.,c);
			denom = 1/denom;

			var t = vec_cross(c,v)*denom;
			if(t<0 || t>1) return null;

			var s = vec_cross(c,u)*denom;
			if(s<0 || s>1) return null;

			var vet = Vertex.get(0.5*(s1.x + t*ux + s2.x + s*vx),
			                     0.5*(s1.y + t*uy + s2.y + s*vy));
			var ret = Event.get(vet);
			ret.type = INT;
			ret.fst = s1;
			ret.other = s2;
			return ret;
		}
	}
}

class PR(Simple) {
mix_circular(Vertex,

	public static inline function less_xy(a:Event,b:Event) {
		return a.x<b.x || (a.x==b.x && a.y<b.y);
	}

	public static var sweep:Sweep;

	public static function decompose(poly:Polygon) {
		if(sweep==null) sweep = new Sweep();

//		var queue = new Set(Event,vertex_lt);
	}

	public static function isSimple(poly:Polygon) {
		if(sweep==null) sweep = new Sweep();

		var queue = new List(Event)();
		for_iter(v,poly,{
			var e1 = queue.add(Event.get(v));
			var e2 = queue.add(Event.get(v.next));
			e2.type = 1 - (e1.type = less_xy(e1,e2) ? LEFT : RIGHT);
			e1.other = e2; e2.other = e1;
			e1.fst = e1; e2.fst = e1;
		});
		Sort(queue,Node(Event),less_xy);

		var ret = true;

		while(!queue.empty()) {
			var e = queue.pop_unsafe();
			if(e.type==LEFT) {
				sweep.add(e);
				if(sweep.intersect(e,e.next)
				|| sweep.intersect(e,e.prev)) {
					ret = false;
					break;
				}
			}else {
				var s = e.other;
				if(sweep.intersect(s.next,s.prev)) {
					ret = false;
					break;
				}
				sweep.remove(s);
				//release to object pools
				Free(Event,s);
				Free(Event,e);
			}
		}

		//release anything remaining by early exiting to object pools
		while(!queue.empty()) {
			var e = queue.pop_unsafe();
			if(e.type==LEFT) e.other.other = null;
			else if(e.other!=null) Free(Event,e.other);
			Free(Event,e);
		}
		sweep.clear();

		return ret;
	}

)}
