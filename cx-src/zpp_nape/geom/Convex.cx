package zpp_nape.geom;
$(import);

$(mixin START   0);
$(mixin END     1);
$(mixin MERGE   2);
$(mixin SPLIT   3);
$(mixin REGULAR 4);

$(mixin Vertex PR(PartitionVeritex));
$(mixin Edge Vertex);

//vertex in a partitioned polygon
//also serves as the edge (this, this.next)
class Vertex {
	//vertex position
	vec_new(public,$(->));
	public var forced:Bool; //used to propogate 'fixed'ness of vertices for simplification

	public var diagonals:List(Vertex);

	//helper in monotone decomposition + type
	public var type:Int;
	public var helper:Vertex;

	MixPoolNoNext(Vertex)
	//for circular linked list.
	public var next:Vertex;
	public var prev:Vertex;

	public function new() {
		diagonals = new List(Vertex)();
	}
	flibmdel public inline function alloc() {
	}
	flibmdel public inline function free() {
		helper = null;
		assert(diagonals.empty(),"non-empty diagonals");
	}

	public static inline function get(x:PR(GeomVert)) {
		var ret = Get(Vertex);
		vec_set(ret.,x.);
		return ret;
	}

	//sort diagonals in order of processing when pulling polygons out of partitions
	public function sort() {
		vec_new(u); vec_new(v);
		$(mixin orient(a,b,c) ({
			vec_sub(a.,b.,u);
			vec_sub(c.,b.,v);
			var ret = vec_cross(u,v);
			ret > 0 ? -1 : ret == 0 ? 0 : 1;
		}));
		var vorient = orient(prev,this,next);
		assert(vorient!=0, "collinear edge on boundary of partitioned poly?");
		Sort(diagonals,Node(Vertex),$(mixin lt(p,q) ({
			var d1 = orient(prev,this,p);
			var d2 = orient(prev,this,q);
			if  (d1==d2) orient(p,this,q) == 1;
			elif(d1==0)  d2 == vorient;
			else         d1 != vorient;
		})) lt);
	}

	//determine right distance of vertex from edge, sign being important, magnitude not.
	static inline function rightdistance(edge:Edge,vert:Vertex) {
		//assume edge is not horizontal
		var flip = edge.next.y > edge.y;
		vec_new(u); vec_sub(edge.next.,edge., u);
		vec_new(v); vec_sub(vert.,edge., v);
		return (flip ? -1.0 : 1.0) * vec_cross(u,v);
	}

	//determine if edge is to the left of the vertex
	public static inline function vert_lt(edge:Edge,vert:Vertex) {
		return if(vert==edge || vert==edge.next) true
		       else if(edge.y==edge.next.y) min(edge.x,edge.next.x) <= vert.x;
		       else rightdistance(edge,vert) <= 0.0;
	}

	//for use in RBTree Set for sorted tree of edges
	//returns true if 'this' edge should be placed to the right geometrically of 'q'
	public var node:Set(Edge);
	public static function edge_swap(p:Edge,q:Edge) swap(p.node,q.node)

	public static function edge_lt(p:Edge,q:Edge) {
		if(p==q && p.next==q.next) { assert(false,"Attempting to sort an edge with itself"); return false; }
		//handle shared vertices (literal) between the two edges
		// noting thiat p==q and p.next==q.next can never happen without above check being true.
		// since a vertex is shared, we want to know if the other vertex of the second edge
		// is to the right/left of the first edge.
		if  (p==q.next) return !vert_lt(p,q);
		elif(q==p.next) return  vert_lt(q,p);
		//if neither vertex is shared, we still need to handle horizontal edges
		elif(p.y==p.next.y) {
			return
				if(q.y==q.next.y) max(p.x,p.next.x) > max(q.x,q.next.x)
				else rightdistance(q,p) > 0.0;
		}else {
			var qright = rightdistance(p,q);
			var qisright = qright < 0.0;
			var nextright = rightdistance(p,q.next) < 0.0;
			return
				if  (qisright==nextright) qisright
				elif(q.y==q.next.y) qright > 0.0
				else rightdistance(q,p) >= 0.0;		
		}
	}
}

mix_circular(Vertex,
class PR(PartitionedPoly) {
	public var vertices:Vertex; //circular linked list.

	flibmdel inline function eq(a:PR(GeomVert),b:PR(GeomVert)) return vec_dsq(a.,b.) < PR(Const).EPSILON
	//we remove degenerate vertices, and collinear vertices
	//as this was the easiest way to make the monotonic decomposition robust.
	public function new(P:PR(GeomVert)) {
		if(P==null) return;
		var cw = geom(clockwise(P));
		var p = P;
		do {
			if(eq(p,p.next)) {}
			else {
				var pre = p.prev;
				while(eq(pre,p) && pre!=p) pre = pre.prev;
				if(pre==p) break;

				vec_new(u); vec_sub(p.,pre.,u);
				vec_new(v); vec_sub(p.next.,p.,v);
				if(vec_cross(u,v)!=0.0) {
					vertices =
						if(cw) push_after(vertices,Vertex.get(p))
						else  push_before(vertices,Vertex.get(p))
						vertices.forced = p.forced;
				}
			}
			p = p.next;
		}while(p!=P);
		DEBUG(if(size(vertices)<3) throw "Error: Degenerate poly can't be decomposed";)
	}

	public function add_diagonal(p:Vertex,q:Vertex) {
		p.diagonals.add(q);
		q.diagonals.add(p);
		p.forced = q.forced = true;
	}
	
	//pull polygons out of the partitions
	public function extract() {
		var ret = new List(PR(GeomVert))();
		for_iter(c, vertices, c.sort());
		pull(vertices, ret);
		return ret;
	}
	private function pull(start:Vertex, ret:List(PR(GeomVert))) {
		var poly:PR(GeomVert) = null;
		var next = start;
		do {
			mix_circular(PR(GeomVert),
				poly = push_after(poly, PR(GeomVert).get(next.x,next.y));
				poly.forced = next.forced;
			)
			if(!next.diagonals.empty()) {
				var diag = next.diagonals.pop_unsafe();
				if(diag==start) break;
				else next = pull(next,ret);
			}else {
				var n = next.next;
				Free(Vertex,next);
				next = n;
			}
		}while(next!=start);

		assert(PR(Monotone).isMonotone(poly), "output poly is not monotone :(");
		assert(geom(clockwise(poly)),"out poly is not convex :(");

		if(geom(signed_area(poly))!=0)
			ret.add(poly);
		return next;
	}
}
)

//perform monotone partitionings of a polygon using a horizontal sweep line.
//handling any weakly-simple polygon.
class PR(Monotone) {
	//used in ordering points when lexicographically equal
	static inline function bisector(b:Vertex) {
		var a = b.prev;
		var c = b.next;
		vec_new(u); vec_sub(b.,a.,u);
		vec_new(v); vec_sub(c.,b.,v);
		var ret = PR(Vec2).get(-uy-vy,ux+vx);
		vec_normalise(ret.);
		if(vec_cross(u,v) < 0) vec_negate(ret.);
		return ret;
	}

	//determine if p is below q (lexicographically if required)
	static inline function below(p:Vertex,q:Vertex) {
		if  (p.y<q.y) return true;
		elif(p.y>q.y) return false;
		else {
			if  (p.x<q.x) return true;
			elif(p.x>q.x) return false;
			else {
				//in the case of equal points lexicographically
				//we use the information to find the bisector for the polygon
				//at the point, and compare how the points related slightly away from the vertex
				//into the polygon to get a natuiral ordering for equal points.
				var po = bisector(p); var qo = bisector(q);
				vec_addeq(po.,p.); vec_addeq(qo.,q.);
				var ret = po.x < qo.x || (po.x==qo.x && po.y<qo.y);
				Free(PR(Vec2),po); Free(PR(Vec2),qo);
				return ret;
			}
		}
	}
	static inline function above(p:Vertex,q:Vertex) return below(q,p)
	
	//returns true, if locally based on incident edges
	//the polygon internal exists to the right of the vertex
	static inline function left_vertex(p:Vertex) {
		var pre = p.prev;
		return pre.y > p.y || (pre.y==p.y && p.next.y < p.y);
	}

	public static function isMonotone(P:PR(GeomVert)) {
	mix_circular(Vertex,
		//find upper and lower most vertices of P
		//we don't care about being lexicographically correct here.
		var min = P; var max = P;
		for_iter(p, P.next,P, {
			if(p.y < min.y) min = p;
			if(p.y > max.y) max = p;
		});

		var ret = true;
		//check monotonicity on forward chain.
		var pre = min;
		if(max!=min.next) {
			for_iter(p, min.next, max, {
				if(p.y < pre.y) { ret = false; break; }
				pre = p;
			});
		}

		if(!ret) return false;

		pre = min;
		//check monotonicity on reverse chain
		if(max!=min.prev) {
			rev_iter(p, min.prev, max, {
				if(p.y < pre.y) { ret = false; break; }
				pre = p;
			});
		}

		return ret;
	)
	}

	public static function decompose(P:PR(GeomVert)) {
	mix_circular(Vertex,
		var poly = new PR(PartitionedPoly)(P);
		
		//populate vertices with event types
		//and produce list of sorted events
		var queue = new List(Vertex)();
		for_iter(p, poly.vertices, {
			queue.add(p);
			//compute event type
			vec_new(u); vec_sub(p.next.,p., u);
			vec_new(v); vec_sub(p.prev.,p., v);
			var cx = vec_cross(u,v) > 0.0;

			p.type =
				if(below(p.prev,p)) {
					if(below(p.next,p)) cx ? START : SPLIT
					else REGULAR;
				}else {
					if(below(p,p.next)) cx ? END : MERGE
					else REGULAR;
				};
		});
		Sort(queue,Node(Vertex),above);

		//sorted list of edges based on Edge::edge_lt
		var edges = Get(Set(Edge));
		edges.lt = Edge.edge_lt;
		edges.swapped = Edge.edge_swap;

		//yay
		while(!queue.empty()) {
			var v = queue.pop_unsafe();
			switch(v.type) {
			case START:
				v.helper = v;
				v.node = edges.insert(v);
			case END:
				var e = v.prev;
				DEBUG(if(e.helper==null) throw "Fatal error (1): Polygon is not weakly-simple and clockwise";)
				if(e.helper.type==MERGE) poly.add_diagonal(v,e.helper);
				edges.remove_node(e.node);
				DEBUG(e.helper=null;)
			case SPLIT:
				var e = SetLowerBound(v,edges,Edge.vert_lt);
				if(e!=null) {
					DEBUG(if(e.helper==null) throw "Fatal error (2): Polygon is not weakly-simple and clockwise";)
					poly.add_diagonal(v,e.helper);
					e.helper = v;
				}
				v.node = edges.insert(v);
				v.helper = v;
			case MERGE:
				var e = v.prev;
				DEBUG(if(e.helper==null) throw "Fatal error (3): Polygon is not weakly-simple and clockwise";)
				if(e.helper.type==MERGE) poly.add_diagonal(v,e.helper);
				edges.remove_node(e.node);
				DEBUG(e.helper=null;)

				var e = SetLowerBound(v,edges,Edge.vert_lt);
				if(e!=null) {
					DEBUG(if(e.helper==null) throw "Fatal error (4): Polygon is not weakly-simple and clockwise";)
					if(e.helper.type==MERGE) poly.add_diagonal(v,e.helper);
					e.helper = v;
				}
			case REGULAR:
				var pre = v.prev;
				if(left_vertex(v)) {
					DEBUG(if(pre.helper==null) throw "Fatal error (5): Polygon is not weakly-simple and clockwise";)
					if(pre.helper.type==MERGE) poly.add_diagonal(v,pre.helper);
					edges.remove_node(pre.node);
					DEBUG(pre.helper=null;)

					v.node = edges.insert(v);
					v.helper = v;
				}else {
					var e = SetLowerBound(v,edges,Edge.vert_lt);
					DEBUG(if(e==null || e.helper==null) throw "Fatal error (6): Polygon is not weakly-simple and clockwise";)
					if(e.helper.type==MERGE) poly.add_diagonal(v,e.helper);
					e.helper = v;
				}
			}
		}

		return poly.extract();
	)
	}
}
