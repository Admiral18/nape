package zpp_nape.geom;
$(import);

/**

	Partial port of CGAL greene_approx_convex_partition_2 (www.cgal.org)

	I couldn't source it's reference for this algorithm to appreciate/understand it, so a direct port
	was necessary. Modified since to use the monotone PartitionPoly so we can mark shared edges in
	output with their vertices 'forced' to be included in any successive simplification.

	INSERT LICENCE DUMP D: .... at some point

**/

$(mixin Vertex() PR(PartitionVertex));
$(mixin Polygon() PR(GeomVert));

mix_circular(Vertex,

$(mixin CCW() false);
$(mixin CW() true);

class PR(Chain) {
	public var front:Vertex;
	public var back :Vertex;
	public var cw:Bool;

	public function new(front_back:Vertex, cw:Bool) {
		initialise(front_back);
		this.cw = cw;
	}

	flibmdel public inline function initialise(front_back:Vertex) {
		front = back = front_back;
	}

	flibmdel public inline function push_back(back:Vertex) {
		this.back = back;
	}
	flibmdel public inline function push_front(front:Vertex) {
		this.front = front;
	}
	flibmdel public inline function pop_back() {
		back = before_back();
	}
	flibmdel public inline function pop_front() {
		front = before_front();
	}

	flibmdel public inline function before_back() {
		return if(cw) back.prev else back.next;
	}
	flibmdel public inline function after_back() {
		return if(cw) back.next else back.prev;
	}
	flibmdel public inline function before_front() {
		return if(cw) front.next else front.prev;
	}
	flibmdel public inline function after_front() {
		return if(cw) front.prev else front.next;
	}

	flibmdel public inline function set_direction(dir:Bool) {
		cw = dir;
	}

	flibmdel public inline function set(x:PR(Chain)) {
		front = x.front;
		back = x.back;
		cw = x.cw;
	}
} 

class PR(Greene) {
	
	public static inline function less_yx(a:Vertex,b:Vertex) {
		return a.y<b.y || (a.y==b.y && a.x<b.x);
	}

	public static inline function left_turn(a:Vertex,b:Vertex,c:Vertex) {
		vec_new(u); vec_sub(b.,a.,u);
		vec_new(v); vec_sub(c.,b.,v);
		return vec_cross(u,v) > 0;
	}
	public static inline function right_turn(a:Vertex,b:Vertex,c:Vertex) {
		vec_new(u); vec_sub(b.,a.,u);
		vec_new(v); vec_sub(c.,b.,v);
		return vec_cross(u,v) < 0;
	}

	public static inline function is_adjacent_to(new_point,old_point) {
		if  (new_point==old_point.next) return true;
		elif(new_point==old_point.prev) return true;
		else return false;
	}

	$(mixin check_polygon(poly) {
		#if NAPE_ASSERT
			if(!geom(convex(poly))) throw "Error ASSERTION: Green output not convex!";
			if(!geom(clockwise(poly))) throw "Error ASSERTION: Green output not convex-clockwise!";
		#end
	});

	public static inline function diagonal(poly:PR(PartitionPoly), a:Vertex,b:Vertex) {
		if(a!=b && !is_adjacent_to(a,b))
			poly.insert_diagonal(a.link,b.link);
	}

	public static inline function visible(polygon:PR(PartitionPoly), new_point_ref:Vertex, stack:PR(Chain), bottom:PR(Chain), top:PR(Chain)) {
		if((bottom.cw && right_turn(stack.back, stack.before_back(), new_point_ref))
		|| (!bottom.cw && left_turn(stack.back, stack.before_back(), new_point_ref))) {
			var done = false;
			var big = false;
			var isvisible = false;
			do {
				stack.pop_back();
				if(bottom.cw) {
					diagonal(polygon,bottom.front,stack.before_back().prev);
					erase(bottom.before_front(),stack.back);
					polygon.vertices = stack.back;
				}else {
					diagonal(polygon,stack.back,bottom.after_front().prev);
					erase(bottom.back,bottom.front);
					polygon.vertices = bottom.front;
				}

				bottom.push_back(stack.back);
				if(stack.back==stack.front) {
					done = true;
					if(less_yx(stack.front,bottom.front)) {
						stack.push_front(bottom.front);
						stack.cw = !stack.cw;
						bottom.set(top);
						top.initialise(stack.front);
						top.cw = !top.cw;
					}else {
						stack.push_back(bottom.front);
						bottom.push_back(bottom.front);
					}
				}else {//stack size >= 2 here
					if(bottom.cw) big = right_turn(bottom.front,stack.back,stack.before_back());
					else          big = left_turn (bottom.front,stack.back,stack.before_back());

					if(bottom.cw) isvisible = !right_turn(stack.back,stack.before_back(),new_point_ref);
					else          isvisible = !left_turn (stack.back,stack.before_back(),new_point_ref);
				}
			}while(!done && !big && !isvisible);
			if(big) {
				stack.push_back(bottom.front);
				bottom.push_back(bottom.front);
			}
		}
	}

	public static inline function change_top_chain(polygon:PR(PartitionPoly), new_point_ref:Vertex, stack:PR(Chain),top:PR(Chain)) {
		var next_point_ref = if(top.cw) new_point_ref.prev else new_point_ref.next;

		if((!top.cw && !right_turn(top.front,new_point_ref,next_point_ref))
		|| (top.cw && !left_turn(top.front,new_point_ref,next_point_ref)))
			top.push_front(new_point_ref);
		else {
			var old_top_ref = stack.front;
			stack.pop_front();

			var done = false;
			var big = false;
			var small = false;

			do {
				if(!top.cw) {
					diagonal(polygon,stack.front,next_point_ref.prev);
					erase(old_top_ref, new_point_ref);
					polygon.vertices = new_point_ref;
				}else {
					diagonal(polygon,new_point_ref,stack.before_front().prev);
					erase(top.front,stack.front);
					top.push_front(stack.front);
					polygon.vertices = stack.front;
				}

				if(stack.front==stack.back) {
					done = true;
					stack.push_front(new_point_ref);
					top.initialise(new_point_ref);
				}else {
					if(!top.cw) big = !left_turn(stack.before_front(),stack.front,new_point_ref);
					else        big = !right_turn(stack.before_front(),stack.front,new_point_ref);

					if(!top.cw) small = left_turn(stack.front,new_point_ref,next_point_ref);
					else        small = right_turn(stack.front,new_point_ref,next_point_ref);

					if(!big && !small) {
						old_top_ref = stack.front;
						stack.pop_front();
					}
				}
			}while(!done && !big && !small);
			if(big) {
				stack.push_front(new_point_ref);
				top.initialise(new_point_ref);
			}elif(small) {
				top.push_back(stack.front);
				top.push_front(new_point_ref);
			}
		}
	}

	public static inline function change_bottom_chain(polygon:PR(PartitionPoly), new_point_ref:Vertex, stack:PR(Chain), bottom:PR(Chain), top:PR(Chain)) {
		var next_point_ref = if(bottom.cw) new_point_ref.prev else new_point_ref.next;

		if((bottom.cw && !left_turn(bottom.front,new_point_ref,next_point_ref))
		|| (!bottom.cw && !right_turn(bottom.front, new_point_ref, next_point_ref)))
			bottom.push_front(new_point_ref);
		else {
			var done = false;
			var small = false;
			do {
				stack.pop_back();
				if(bottom.cw) {
					diagonal(polygon,new_point_ref,stack.before_back().prev);
					erase(bottom.front,stack.back);
					polygon.vertices = stack.back;
				}else {
					diagonal(polygon,stack.back,next_point_ref.prev);
					erase(bottom.back,new_point_ref);
					polygon.vertices = new_point_ref;
				}

				bottom.initialise(stack.back);
				if(stack.back==stack.front) {
					done = true;
					if(less_yx(stack.front,new_point_ref)) {
						stack.push_front(new_point_ref);
						stack.cw = !stack.cw;
						bottom.set(top);
						top.initialise(stack.front);
						top.cw = !top.cw;
					}else
						stack.push_back(new_point_ref);
				}else { //stack >= 2
					if(bottom.cw) small = right_turn(stack.back,new_point_ref,next_point_ref);
					else          small = left_turn(stack.back,new_point_ref,next_point_ref);
				}
			}while(!done && !small);
			if(small) {
				bottom.push_back(stack.back);
				bottom.push_front(new_point_ref);
			}
		}
	}

	public static inline function stack_extend(polygon:PR(PartitionPoly), point_ref:Vertex, stack:PR(Chain), top:PR(Chain)) {
		if((!stack.cw && right_turn(stack.before_front(), stack.front, point_ref))
		|| ( stack.cw &&  left_turn(stack.before_front(), stack.front, point_ref))) {
			stack.push_front(point_ref);
			top.initialise(point_ref);
		}else
			change_top_chain(polygon, point_ref,stack,top);
	}

	public static inline function make_polygons_from_stack(polygon:PR(PartitionPoly), high_point_ref:Vertex, stack:PR(Chain), bottom:PR(Chain)) {
		var next_point_ref = high_point_ref;
		if(!bottom.cw) next_point_ref = next_point_ref.next;

		stack.pop_back();
		while(stack.front != stack.back) {
			if(bottom.cw) {
				diagonal(polygon,high_point_ref,stack.before_back().prev);
				erase(bottom.front,stack.back);
				bottom.initialise(stack.back);
				polygon.vertices = stack.back;
			}else {
				diagonal(polygon,stack.back,next_point_ref.prev);
				erase(bottom.back, high_point_ref);
				bottom.push_back(stack.back);
				polygon.vertices = high_point_ref;
			}

			stack.pop_back();
		}
	}

	public static inline function find_smallest_yx(polygon:PR(PartitionPoly)) {
		var current = polygon.vertices.next;
		//abuse monotonicity of polygon to shortern search.
		if(less_yx(current,polygon.vertices)) {
			do {
				polygon.vertices = current;
				current = current.next;
			}while(less_yx(current,polygon.vertices));
		}else {
			current = polygon.vertices.prev;
			if(less_yx(current,polygon.vertices)) {
				do {
					polygon.vertices = current;
					current = current.prev;
				}while(less_yx(current,polygon.vertices));
			}
		}
		return polygon.vertices;
	}

	public static inline function second_point_is_next(v:Vertex) {
		return less_yx(v.next,v.prev);
	}

	$(mixin next_vertex(ccw,cw) {
		var ccw2 = ccw.next;
		var cw2 = cw.prev;
		if(ccw2 == cw2) {
			cw = cw2;
			ccw = ccw2;
			/*return*/ cw;
		}else {
			if(less_yx(ccw2,cw2)) {
				ccw = ccw2;
				/*return*/ ccw;
			}else {
				cw = cw2;
				/*return*/ cw;
			}
		}
	});

	public static function ga_convex_decomposition(polygon:PR(PartitionPoly)) {
		var point_ref = find_smallest_yx(polygon);
		var circ = point_ref;

		var ccw_chain_ref = point_ref;
		var cw_chain_ref  = point_ref;

		var stack  = new PR(Chain)(point_ref, CCW);
		var bottom = new PR(Chain)(point_ref, CW);
		var top    = new PR(Chain)(point_ref, CCW);

		if(second_point_is_next(point_ref)) {
			ccw_chain_ref = ccw_chain_ref.next;
			stack.push_front(ccw_chain_ref);
			stack.set_direction(CCW);
			top.initialise(ccw_chain_ref);
			top.set_direction(CCW);
			bottom.set_direction(CW);
		}else {
			cw_chain_ref = cw_chain_ref.prev;
			stack.push_front(cw_chain_ref);
			stack.set_direction(CW);
			top.initialise(cw_chain_ref);
			top.set_direction(CW);
			bottom.set_direction(CCW);
		}

		while(ccw_chain_ref != cw_chain_ref) {
			point_ref = next_vertex(ccw_chain_ref,cw_chain_ref);

			if(is_adjacent_to(point_ref,bottom.front))
				visible(polygon, point_ref, stack, bottom, top);

			if(ccw_chain_ref == cw_chain_ref) {
				make_polygons_from_stack(polygon, point_ref,stack,bottom);
				break;
			}

			if(is_adjacent_to(point_ref,stack.front))
				stack_extend(polygon,point_ref,stack,top);
			elif(is_adjacent_to(point_ref,top.front))
				change_top_chain(polygon,point_ref,stack,top);
			else
				change_bottom_chain(polygon,point_ref,stack,bottom,top);
		}
	}

	public static function decompose(P:Polygon) {
		var MPs = PR(Monotone).decompose(P);
		var rets = new List(Polygon)();
		ClearWith(MP,MPs,{
			var opoly = new PR(PartitionPoly)(MP);
			var poly = opoly.linked();
			ga_convex_decomposition(poly);
//			opoly.debug();
			haxe.Log.clear();
			opoly.partition_to(rets);
		});

		#if NAPE_ASSERT
			//don't use signed_area as P may have been reversed in monotone decomposition if it were CCW
			var area = geom(area(P));
			var retarea = 0.0;
			Iter(p,rets,retarea += geom(signed_area(p)));
			
			var darea = retarea-area;
			assert(darea*darea < PR(Const).EPSILON, "Greene output has different area?! area="+area+" retarea="+retarea);
		#end

		return rets;
	}
}

)
