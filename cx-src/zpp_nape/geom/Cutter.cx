package zpp_nape.geom;
$(import);

class PR(CutVert) {
	MixPool(PR(CutVert))

	vec_new(public, pos);
	public var vert:PR(GeomVert);
	public var value:Float;
	public var positive:Bool;

	public function new() {}
	flibmdel public inline function alloc() {}
	flibmdel public inline function free() {
		vert = null;
	}
}

class PR(Cutter) {
	public static function run(P:PR(GeomVert),_start:Vec2,_end:Vec2,bstart:Bool,bend:Bool) {
		vec_new(p); vec_set(p,_start.);
		vec_new(d); vec_sub(_end.,p,d);
		var min = bstart ? 0 : PR(Const).NEGINF;
		var max = bend   ? 1 : PR(Const).POSINF;
		var crx = -vec_cross(d,p);

		//calculate left/positive for each vertex.
	mix_circular(PR(GeomVert),
		var verts = new List(PR(CutVert))();
		var clashes = false;
		for_iter(p,P,{
			var c = Get(PR(CutVert));
			c.vert = p;
			vec_set(c.pos, c.vert.);
			c.value = vec_cross(d,c.pos) + crx;
			c.positive = c.value > 0;
			if(c.value==0) clashes = true;
			verts.add(c);
		});
	)

		//resolve any ambiguity
		if(clashes) {
			var start:Node(PR(CutVert)) = null;
			Iter(p, verts, {
				if(p.value!=0.0) {
					start = cx_ite;
					break;
				}
			});
			assert(start!=null,"all vertices on line but it's simple?");

			vec_new(n); vec_set(n,d); vec_normal(n);

			var pre:Node(PR(CutVert)) = null;
			IterCycleFull(p,verts,start,{
				if(p.value!=0.0
				&& (pre==null || cx_ite==CycleNext(verts,pre))) {
					pre = cx_ite;
					cx_continue;
				}

				var prod = pre.elem().value * p.value;
				if(prod==0) cx_continue;

				var a = CycleNext(verts,pre);
				var positive =
					if(prod>0) pre.elem().positive;
					else{
						//nooo!!!!
						var b = CycleNext(verts,a);

						vec_new(mid);
						vec_add(a.elem().pos,b.elem().pos,mid);
						vec_muleq(mid,0.5);
	
						geom(contains(P, midx+nx*1e-8, midy+ny*1e-8));
					};

				var n = cx_ite;
				IterCycle(q,verts,a,{
					if(cx_ite==n) cx_break;
					q.positive = positive;
				});
				pre = cx_ite;
			});
		}

		return new GeomPolyList();
	}
}
