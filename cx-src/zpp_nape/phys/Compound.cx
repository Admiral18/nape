package zpp_nape.phys;
$(import);

class PR(Compound) extends PR(Interactor) {
	public var outer:Compound;

	//----------------------------------------------------

	public var bodies:List(PR(Body)); 
	public var constraints:List(PR(Constraint));
	public var compounds:List(PR(Compound)); 

	public var wrap_bodies:BodyList;
	public var wrap_constraints:ConstraintList;
	public var wrap_compounds:CompoundList;

	//----------------------------------------------------

	public var depth:Int;
	public var compound:PR(Compound);
	public var space:PR(Space);

	//----------------------------------------------------

	public function __setCbType(cbType:PR(CbType)) {
		if(this.cbType != cbType) {
			if(space!=null && this.cbType!=null) {
				this.cbType.remCompound(this);
				space.nullInteractorType(this);
			}

			this.cbType = cbType;
			if(space!=null && cbType!=null) {
				cbType.addCompound(this);
				space.freshInteractorType(this);
			}

			wake();
		}
	}
	flibmdel public inline function __imutable_midstep(name:String) {
		DEBUG(if(space!=null && space.midstep) throw "Error: "+name+" cannot be set during space step()";)
	}

	flibmdel public inline function wake() {
		if(space!=null) space.wakeCompound(this);
	}

	public function addedToSpace() {
		if(cbType!=null)
			cbType.addCompound(this);
	}
	public function removedFromSpace() {
		if(cbType!=null)
			cbType.remCompound(this);
	}

	//----------------------------------------------------

	public function new() {
		super();
		icompound = this;
		depth = 1; //space is taken to be depth=0

		var me = this;
		$(mixin list(b,B) list(b,B,$(mixin check(x){}) check,$(mixin onadd(x){}) onadd,$(mixin onsub(x){}) onsub));
		$(mixin list(b,B,check,onadd,onsub)
			b = new List(PR(B))();
			wrap_`b = PR(B`List).get(b);
			wrap_`b.pr(inner).adder = function(x:B) {
				check(x)
				if(x.pr(inner).compound!=me) {
					if(x.pr(inner).compound!=null) x.pr(inner).compound.wrap_`b.remove(x);
					elif(x.pr(inner).space!=null) x.pr(inner).space.wrap_`b.remove(x);

					x.pr(inner).compound = me;
					onadd(x);

					if(me.space!=null) me.space.add`B(x.pr(inner));
					return true;
				}else return false;
			}
			wrap_`b.pr(inner).subber = function(x:B) {
				x.pr(inner).compound = null;
				onsub(x);

				if(me.space!=null) me.space.rem`B(x.pr(inner));
			}
			DEBUG(wrap_`b.pr(inner)._modifiable = function() {
				me.immutable_midstep("Compound::"+$str(b));
			})
		);

		list(bodies,Body)
		list(constraints,Constraint)

		list(compounds,Compound,
		$(mixin check(x) DEBUG(
			var cur = me;
			while(cur!=null && cur!=x.pr(inner)) cur = cur.compound;
			if(cur==x.pr(inner)) {
				throw "Error: Assignment would cause a cycle in the Compound tree: assigning "+x.toString()+".compound = "+me.outer.toString();
				return false;
		})) check,
		$(mixin onadd(x) x.pr(inner).depth = me.depth+1) onadd,
		$(mixin onsub(x) x.pr(inner).depth = 1 /*space is taken to be 0*/) onsub
		)
	}
}
