package zpp_nape.phys;
$(import);

class PR(Body) {
	public var outer:Body;
	
	public var world:Bool; //used for Space::static
	
	//----------------------------------------------------------------------------------------------
	
	static var nextId = 0;
	public var id:Int;
	
	public var type:Int;
	flibmdel public inline function isStatic   () return type == Flag(BodyType,STATIC)
	flibmdel public inline function isDynamic  () return type == Flag(BodyType,DYNAMIC)
	flibmdel public inline function isKinematic() return type == Flag(BodyType,KINEMATIC)
	
	flibmdel public inline function invalidate_type() {
		invalidate_mass();
		invalidate_inertia();
	}
	
	//----------------------------------------------------------------------------------------------
	
	public var shapes:List(PR(Shape));
	public var wrap_shapes:ShapeList;
	
	flibmdel public inline function invalidate_shapes() {
		//dependancy checked
		invalidate_aabb();
		invalidate_localCOM();
		invalidate_mass();
		invalidate_inertia();
	}
	
	//----------------------------------------------------------------------------------------------
	
	public var space:PR(Space);
	
	public var arbiters   :List(PR(Arbiter));    public var wrap_arbiters   :ArbiterList;
	public var constraints:List(PR(Constraint)); public var wrap_constraints:ConstraintList;
	
	//disjoint set forest.
	public var component:PR(Component);
	
	//----------------------------------------------------------------------------------------------
	
	flibmdel public inline function atRest(dt:Float) {
		if(!isDynamic()) return component.sleeping;
		else {
			var cansleep =
				if(vec_lsq(vel) > PR(Config).SLEEP_LINEAR_SQ) false;
				else if(vec_dsq(pos,pre_pos) > 0.25*PR(Config).SLEEP_LINEAR_SQ*dt*dt) false
				else {
					//approximated 'radius' (or actual radius if only shape is a circle)
					vec_new(d); vec_sub(aabb.max,aabb.min,d);
					var idl = vec_lsq(d);
					if(4*angvel*angvel*idl > PR(Config).SLEEP_ANGULAR_SQ) false
					else {
						var dr = rot - pre_rot;
						if(dr*dr*idl > PR(Config).SLEEP_ANGULAR_SQ*dt*dt) false
						else true;
					}
				}
				
			if(!cansleep) component.waket = space.stamp;
			return component.waket + PR(Config).SLEEP_DELAY < space.stamp;
		}
	}
	
	public function wake() {
		return if(space!=null) space.wake(this) else false;
	}
	
	public function refreshArbiters() {
		Iter(arb, arbiters, arb.invalidated = true);
	}
	
	//----------------------------------------------------------------------------------------------
	
	vec_new(public,pre_pos);
	vec_new(public,pos);   public var wrap_pos:Vec2;
	vec_new(public,vel);   public var wrap_vel:Vec2;
	vec_new(public,force); public var wrap_force:Vec2;

	vec_new(public,kinvel); //kinematic velocity.
	public var wrap_kinvel:Vec2;
	
	vec_new(public,svel); //surface velocity
	public var wrap_svel:Vec2;
	
	flibmdel public inline function invalidate_pos() {
		//dependancy checked
		Iter(s,shapes,{
			if(s.type==Flag(ShapeType,POLYGON)) {
				s.polygon.invalidate_gverts();
				s.polygon.invalidate_gaxi();
			}
			s.invalidate_worldCOM();
		});
		invalidate_worldCOM();
		#if flash9 validate_graphic(); #end
		//don't wake object here, this method is called by space each step!
	}

	public function setupPosition() {
		var me = this;
		me.wrap_pos = Vec2.get(posx,posy);
		me.wrap_pos.pr(inner).inuse = true;
		if(world) me.wrap_pos.pr(inner).immutable = true;
		else {
			me.wrap_pos.pr(inner)._invalidate = function(pos:PR(Vec2)) {
				DEBUG(if(me.isStatic() && me.space!=null)
					throw "Error: Cannot move a static object once inside a Space";
				)
				if(!vec_eq(me.pos,pos.)) {
					vec_set(me.pos,pos.);
					me.invalidate_pos();
					me.wake();
				}
			};
			me.wrap_pos.pr(inner)._validate = function() vec_set(me.wrap_pos.pr(inner).,me.pos);
		}
	}
	public function setupVelocity() {
		var me = this;
		me.wrap_vel = Vec2.get(velx,vely);
		me.wrap_vel.pr(inner).inuse = true;
		if(world) me.wrap_vel.pr(inner).immutable = true;
		else {
			me.wrap_vel.pr(inner)._invalidate = function(vel:PR(Vec2)) {
                DEBUG(if(me.isStatic() && me.space!=null)
                    throw "Error: A static object within a space cannot be given a velocity";
                )
				vec_set(me.vel,vel.);
                me.invalidate_wake();
			};
			me.wrap_vel.pr(inner)._validate = function() {
				vec_set(me.wrap_vel.pr(inner).,me.vel);
			};
		}
	}
	public function setupkinvel() {
		var me = this;
		me.wrap_kinvel = Vec2.get(kinvelx,kinvely);
		me.wrap_kinvel.pr(inner).inuse = true;
		if(world) me.wrap_kinvel.pr(inner).immutable = true;
		else {
			me.wrap_kinvel.pr(inner)._invalidate = function(vel:PR(Vec2)) {
				vec_set(me.kinvel,vel.);
                me.invalidate_wake();
			};
			me.wrap_kinvel.pr(inner)._validate = function() {
				vec_set(me.wrap_kinvel.pr(inner).,me.kinvel);
			};
		}
	}
	public function setupsvel() {
		var me = this;
		me.wrap_svel = Vec2.get(svelx,svely);
		me.wrap_svel.pr(inner).inuse = true;
		if(world) me.wrap_svel.pr(inner).immutable = true;
		else {
			me.wrap_svel.pr(inner)._invalidate = function(vel:PR(Vec2)) {
				vec_set(me.svel,vel.);
                me.invalidate_wake();
			};
			me.wrap_svel.pr(inner)._validate = function() {
				vec_set(me.wrap_svel.pr(inner).,me.svel);
			};
		}
	}
	
	public function setupForce() {
		var me = this;
		me.wrap_force = Vec2.get(forcex,forcey);
		me.wrap_force.pr(inner).inuse = true;
		if(world) me.wrap_force.pr(inner).immutable = true;
		else {
			me.wrap_force.pr(inner)._invalidate = function(force:PR(Vec2)) {
				vec_set(me.force,force.);
				
				if(me.isDynamic())
					me.invalidate_wake();
			};
			me.wrap_force.pr(inner)._validate = function() vec_set(me.wrap_force.pr(inner).,me.force);
		}
	}
	
	//----------------------------------------------------------------------------------------------
	
	public var angvel:Float;
	public var torque:Float;
	//public var bias_angvel:Float;
	
	public var kinangvel:Float;
	public var pre_rot:Float;
	
	public var rot:Float;
	flibmdel public inline function invalidate_rot() {
		//dual with invalidate_axis
		//dependancy checked
		inv(axis) = true;
		Iter(s,shapes,{
			if(s.type==Flag(ShapeType,POLYGON)) {
				s.polygon.invalidate_gverts();
				s.polygon.invalidate_gaxi();
			}
			s.invalidate_worldCOM();
		});
		invalidate_worldCOM();
		#if flash9 validate_graphic(); #end
		//don't wake object here, this method is called by space.step!
	}
	vec_new(public,axis); public var inv(axis):Bool;
	flibmdel public inline function validate_axis() {
		//dependancy checked
		if(inv(axis)) {
			inv(axis) = false;
			quick_validate_axis();			
		}
	}
	flibmdel public inline function quick_validate_axis() {
		vec_set(axis,Math.sin(rot),Math.cos(rot));
	}
    flibmdel public inline function delta_rot(dr:Float) {
        rot += dr;
        //stay defensive; if dr is even remotely big; recalculate axis exactly.
        if(dr*dr>0.01) quick_validate_axis();
        else {
            //otherwise use a dirty approximation!
            var dx = axisy*dr;
            axisy = axisy - axisx*dr;
            axisx = axisx + dx;
            //don't even bother to normalise it! not needed in testing
        }
    }
	
	//----------------------------------------------------------------------------------------------
	
	public var mass:Float; public var inv(mass):Bool;
	public var massMode:Int; //DEFAULT, FIXED
	
	public var imass:Float; //0 when asleep
	public var smass:Float; //1/mass even when asleep
	public var cmass:Float; //mass even if converted to kinematic/static
	
	public var nomove:Bool; //stopMovement()/allowMovement() calls
	
	flibmdel public inline function invalidate_mass() {
		//dependancy checked
		if(massMode==Flag(MassMode,DEFAULT))
			inv(mass) = true;
		invalidate_gravMass();
	}
	flibmdel public inline function validate_mass() {
		//dependancy checked
		// # changes to Material memory use (see Shape.cx)
		var exist = Exists(s,shapes,s.refmaterial.density!=s.material.density);
		// #
		if(inv(mass)
		// #
		 || (massMode==Flag(MassMode,DEFAULT) && exist)
		// #
		) {
			inv(mass) = false;
			if(massMode==Flag(MassMode,DEFAULT)) {
				cmass = 0;
				Iter(s,shapes,{
					// #
					s.refmaterial.density = s.material.density;
					// #
					s.validate_area_inertia();
					cmass += s.area*s.material.density;
				});
			}
			if(isDynamic() && !nomove) {
				mass = cmass;
				imass = smass = 1.0/mass;
			}else {
				mass = PR(Const).POSINF;
				imass = smass = 0.0;
			}
			// #
			if(exist) invalidate_inertia();
			// #
		}
	}
	
	public var gravMass:Float; public var inv(gravMass):Bool;
	public var gravMassMode:Int; //DEFAULT,FIXED,SCALED
	public var gravMassScale:Float; public var inv(gravMassScale):Bool;
	
	flibmdel public inline function invalidate_gravMass() {
		//dependancy checked
		if(gravMassMode!=Flag(GravMassMode,FIXED))
			inv(gravMass) = true;
		if(gravMassMode!=Flag(GravMassMode,SCALED))
			inv(gravMassScale) = true; //cannot recursively inline methods

		wake();
	}
	flibmdel public inline function validate_gravMass() {
		//dependacny checked
		if(inv(gravMass)) {
			inv(gravMass) = false;
			validate_mass();
			if(gravMassMode==Flag(GravMassMode,DEFAULT)) {
				validate_mass();
				gravMass = cmass;
			}else if(gravMassMode==Flag(GravMassMode,SCALED)) {
				validate_mass();
				//gravMassScale not verified as defined here.
				gravMass = cmass*gravMassScale;
			}
		}
	}
	
	flibmdel public inline function invalidate_gravMassScale() {
		//dependancy checked
		if(gravMassMode!=Flag(GravMassMode,SCALED))
			inv(gravMassScale) = true;
		else
			invalidate_gravMass();
	}
	flibmdel public inline function validate_gravMassScale() {
		//dependancy checked
		if(inv(gravMassScale)) {
			inv(gravMassScale) = false;
			if(gravMassMode==Flag(GravMassMode,DEFAULT)) gravMassScale = 1.0;
			else if(gravMassMode==Flag(GravMassMode,FIXED)) {
				validate_mass();
				//gravMass not verified as defined here
				gravMassScale = gravMass/cmass;
			}
		}
	}
	
	//----------------------------------------------------------------------------------------------
	
	public var inertiaMode:Int;
	public var inertia:Float; public var inv(inertia):Bool;
	public var cinertia:Float;
	public var iinertia:Float;
	public var sinertia:Float;
	
	public var norotate:Bool; //stopRotation/allowRotation() calls
	
	flibmdel public inline function invalidate_inertia() {
		//dependancy checked
		if(inertiaMode!=Flag(InertiaMode,FIXED)) inv(inertia) = true;
		wake();
	}
	flibmdel public inline function validate_inertia() {
		//dependancy checked
		// # changes to Material memory use (see Shape.cx)
		var exist = Exists(s,shapes,s.refmaterial.density!=s.material.density);
		// #
		if(inv(inertia)
		// #
		 || (inertiaMode==Flag(InertiaMode,DEFAULT) && exist)
		// #
		) {
			inv(inertia) = false;
			if(inertiaMode==Flag(InertiaMode,DEFAULT)) {
				cinertia = 0;
				Iter(s,shapes,{
					// #
					s.refmaterial.density = s.material.density;
					// #
					s.validate_area_inertia();
					cinertia += s.inertia*s.area*s.material.density;
				});
			}
			if(isDynamic() && !norotate) {
				inertia = cinertia;
				sinertia = iinertia = 1.0/inertia;
			}else {
				inertia = PR(Const).POSINF;
				sinertia = iinertia = 0;
			}
			// #
			if(exist) invalidate_inertia();
			// #
		}
	}
	
	//----------------------------------------------------------------------------------------------
	
	//called when body needs waking due to a property change.
	flibmdel public inline function invalidate_wake() {
		wake();
	}
	
	//----------------------------------------------------------------------------------------------
	
	public var aabb:PR(AABB); public var inv(aabb):Bool;
	flibmdel public inline function validate_aabb() {
		//dependancy checked
		if(inv(aabb)) {
			inv(aabb) = false;
			vec_set(aabb.min,PR(Const).POSINF,PR(Const).POSINF);
			vec_set(aabb.max,PR(Const).NEGINF,PR(Const).NEGINF);
			Iter(s,shapes,{
				s.validate_aabb();
				aabb.combine(s.aabb);
			});
		}
	}
	flibmdel public inline function invalidate_aabb() {
		//dependancy checked
		inv(aabb) = true;
	}
	
	//----------------------------------------------------------------------------------------------
	
	#if flash9
		public var hasgraphic:Bool;
		public var graphic:flash.display.DisplayObject;
		vec_new(public,gdelta); public var wrap_gdelta:Vec2;
		public var grotdelta:Float;
		
		flibmdel public inline function validate_graphic() {
			if(hasgraphic) {
				graphic.rotation = (rot + grotdelta)*180/Math.PI;
				
				validate_axis();
				vec_new(d); vec_rotate(gdelta, axis, d);
				graphic.x = posx + dx;
				graphic.y = posy + dy;
			}
		}
	#end
	
	//----------------------------------------------------------------------------------------------
	
	vec_new(public,localCOM); public var inv(localCOM):Bool;
	vec_new(public,worldCOM); public var inv(worldCOM):Bool;
	public var wrap_localCOM:Vec2;
	public var wrap_worldCOM:Vec2;
	
	flibmdel public inline function invalidate_localCOM() {
		//dependancy checked
		inv(localCOM) = true;
		invalidate_worldCOM();
	}
	flibmdel public inline function invalidate_worldCOM() {
		//dependancy checked
		inv(worldCOM) = true;
	}
	
	flibmdel public inline function validate_localCOM() {
		//dependancy checked
		if(inv(localCOM)) {
			inv(localCOM) = false;
			
			vec_new(temp,0,0);
			var msum = 0.0;
			Iter(s,shapes,{
				s.validate_localCOM();
				s.validate_area_inertia();
				
				vec_addeq(temp,s.localCOM,s.area*s.material.density);
				msum += s.area*s.material.density;
			});
			vec_div(temp,msum,localCOM);
			if(wrap_localCOM!=null) vec_set(wrap_localCOM.pr(inner).,localCOM);
			
			if(inv(mass) && massMode==Flag(MassMode,DEFAULT)) {
				inv(mass) = false;
				cmass = msum;
				if(isDynamic()) {
					mass = cmass;
					imass = smass = 1.0/mass;
				}else {
					mass = PR(Const).POSINF;
					imass = smass = 0.0;
				}
			}
		}
	}
	
	flibmdel public inline function validate_worldCOM() {
		//dependancy checked
		if(inv(worldCOM)) {
			inv(worldCOM) = false;
			validate_localCOM();
			validate_axis();
			
			vec_localglobal(axis,pos, localCOM,worldCOM);
			if(wrap_worldCOM!=null)
				vec_set(wrap_worldCOM.pr(inner).,worldCOM);
		}
	}
	
	public function getlocalCOM() {
		DEBUG(if(shapes.empty()) throw "Error: localCOM only makes sense when Body has Shapes";)
		validate_localCOM();
	}
	public function getworldCOM() {
		DEBUG(if(shapes.empty()) throw "Error: worldCOM only makes sense when Body has Shapes";)
		validate_worldCOM();
	}

    //----------------------------------------------------------------------------------------------

    public var cbType:PR(CbType);

    public function setCbType(cbType:PR(CbType)) {
        if(this.cbType != cbType) {
			if(space!=null) {
	            if(this.cbType!=null) this.cbType.remBody(this);
			}
            this.cbType = cbType;
			if(space!=null)
	            cbType.addBody(this);

            wake();
        }
    }

    //----------------------------------------------------------------------------------------------

	public function clear() {
		DEBUG(if(space!=null) throw "Error: Cannot clear a Body if it is currently being used by a Space!";)
		DEBUG(if(!constraints.empty()) throw "Error: Cannot clear a Body if it is currently being used by a constraint!";)
		
		ClearWith(s,shapes, {
			s.removedFromBody();
			s.body = null;
		});
		invalidate_shapes();

		vec_set(pre_pos,0,0);
		vec_set(pos,0,0);
		vec_set(vel,0,0);
		vec_set(force,0,0);
		vec_set(kinvel,0,0);
		vec_set(svel,0,0);

		angvel = torque = kinangvel = pre_rot = rot = 0;

		invalidate_pos();
		invalidate_rot();
		vec_set(axis,0,1); inv(axis) = false;

		massMode = Flag(MassMode,DEFAULT);
		gravMassMode = Flag(GravMassMode,DEFAULT);
		gravMassScale = 1.0;
		inertiaMode = Flag(InertiaMode,DEFAULT);

		norotate = false;
		nomove = false;

		#if flash9
			hasgraphic = false;
			graphic = null;
			vec_set(gdelta,0,0);
			grotdelta = 0;
		#end

		cbType = PR(CbType).DEFAULT;
	}

    //----------------------------------------------------------------------------------------------

	//used for space.world static rogue body.
	public static function __static():Body {
		var ret = new Body(BodyType.STATIC);
		var si = ret.pr(inner);
		si.world = true;
		si.wrap_shapes.pr(inner).immutable = true;
		si.smass = si.imass = si.cmass = si.mass = si.gravMass = 0.0;
		si.sinertia = si.iinertia = si.cinertia = si.inertia = 0.0;
		return ret;
	}
	
    //----------------------------------------------------------------------------------------------

	public function new() {
		world = false;
		
		norotate = nomove = false;
		
		#if flash9
			vec_set(gdelta,0,0);
			grotdelta = 0;
			hasgraphic = false;
		#end
		
		vec_set(pos,0,0);
		rot = 0;
		vec_set(axis,0,1);
		
		vec_set(svel,0,0);
		vec_set(vel,0,0);
		vec_set(kinvel,0,0);
		vec_set(force,0,0);
		torque = angvel = kinangvel = 0;

		vec_set(pre_pos,PR(Const).POSINF,PR(Const).POSINF);
		pre_rot = PR(Const).POSINF;
		
		vec_set(localCOM,0,0);
		vec_set(worldCOM,0,0);
		
		id = nextId++;
		
		inv(aabb) = true;
		aabb = PR(AABB).get(0,0,0,0);
		aabb.immutable = true;
		var me = this;
		aabb._validate = function() {
			DEBUG(if(me.shapes.empty()) throw "Error: bounds only makes sense when Body has Shapes";)
			me.validate_aabb();
		};
		
		massMode = Flag(MassMode,DEFAULT);
		gravMassMode = Flag(GravMassMode,DEFAULT);
		gravMassScale = 1.0;
		inertiaMode = Flag(InertiaMode,DEFAULT);
		
		arbiters = new List(PR(Arbiter))();
		
		constraints = new List(PR(Constraint))();
		
		shapes = new List(PR(Shape))();
		wrap_shapes = PR(ShapeList).get(shapes);
		var me = this;
		wrap_shapes.pr(inner).adder = function(s:Shape) {
			if(s.pr(inner).body!=me) {
				if(s.pr(inner).body!=null) s.pr(inner).body.wrap_shapes.remove(s);
				s.pr(inner).body = me;
				s.pr(inner).addedToBody();

				if(me.space!=null) me.space.added_shape(s.pr(inner));
				
				return true;
			}else return false;
		};
		wrap_shapes.pr(inner).subber = function(s:Shape) {
			if(me.space!=null) me.space.removed_shape(s.pr(inner));
			
			s.pr(inner).body=null;
			s.pr(inner).removedFromBody();
		};
		wrap_shapes.pr(inner)._invalidate = function(_) {
			me.invalidate_shapes();
		};
		
		wrap_shapes.pr(inner)._modifiable = function() {
			if(me.isStatic() && me.space!=null)
				throw "Error: Cannot modifiy shapes of static object once added to Space";
		};
		
        cbType = PR(CbType).DEFAULT;
	}
	
	//----------------------------------------------------------------------------------------------
	
	public function addedToSpace() {
		assert(component==null,"already has a component?");

		component = Get(PR(Component));
		component.isBody = true;
		component.body = this;

		//cbTypes only maintain list of ACTIVE bodies
		cbType.addBody(this);
	}

	public function removedFromSpace() {
		while(!arbiters.empty()) {
			var arb = arbiters.pop_unsafe();
			arb.lazyRetire(space,this);
		}

		Free(PR(Component),component);
		component = null;

		//cbTypes only maintain list of ACTIVE bodies.
		cbType.remBody(this);
	}
	
	//----------------------------------------------------------------------------------------------
	
	public function copy() {
		var ret = new Body().pr(inner);
		
		ret.type = type;
		
		Iter(s,shapes,{
			var s2 = Shape.copy(s.outer);
			ret.outer.shapes.add(s2);
		});

		vec_set(ret.pos,pos);
		vec_set(ret.vel,vel);
		vec_set(ret.force,force);
		
		if(!inv(axis))
			vec_set(ret.axis,axis);
		else ret.invalidate_rot();
		ret.rot = rot;
		
		ret.massMode = massMode;
		ret.gravMassMode = gravMassMode;
		ret.inertiaMode = inertiaMode;
		
		if(!inv(mass))
			ret.mass = mass;
		else ret.invalidate_mass();
		
		if(!inv(gravMass))
			ret.gravMass = gravMass;
		else ret.invalidate_gravMass();
		
		if(!inv(gravMassScale))
			ret.gravMassScale = gravMassScale;
		else ret.invalidate_gravMassScale();
		
		if(!inv(inertia))
			ret.inertia = inertia;
		else ret.invalidate_inertia();
		
		if(!inv(aabb)) {
			vec_set(ret.aabb.min,aabb.min);
			vec_set(ret.aabb.max,aabb.max);
		}else ret.invalidate_aabb();
		
		if(!inv(localCOM))
			vec_set(ret.localCOM,localCOM);
		else ret.invalidate_localCOM();
		
		if(!inv(worldCOM))
			vec_set(ret.worldCOM,worldCOM);
		else ret.invalidate_worldCOM();

        ret.cbType = cbType;
		
		return ret.outer;
	}
}
