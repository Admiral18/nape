package zpp_nape.callbacks;
$(import);

class PR(Listener) {
    public var outer:Listener;
    public static var internal:Bool = false;

    public var type:Int; //Flag(ListenerType)
    public var event:Int; //Flag(CbEvent)

    public var body:PR(BodyListener);
    public var constraint:PR(ConstraintListener);
    public var interaction:PR(InteractionListener);
    public var imm:PR(PreListener);

    public var space:PR(Space);
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(BodyListener) extends PR(Listener) {
    public var outer_zn:BodyListener;

    public var cbType:PR(CbType);
    public var handler:Body->Void;

    public function new(event:Int, handler:Body->Void) {
        this.event = event;
        this.handler = handler;
        body = this;
        type = Flag(ListenerType,BODY);
    }

    flibmdel public inline function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");

		cbType.listeners.add(this);

        if(event==Flag(CbEvent,WAKE))
             cbType._bodywake = this;
        else cbType._bodysleep = this;
    }

    flibmdel public inline function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");

		cbType.listeners.remove(this);

        if(event==Flag(CbEvent,WAKE))
             cbType._bodywake = null;
        else cbType._bodysleep = null;
    }

    flibmdel public inline function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    flibmdel public inline function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP))
                throw "Error: BodyListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(ConstraintListener) extends PR(Listener) {
    public var outer_zn:ConstraintListener;

    public var cbType:PR(CbType);
    public var handler:Constraint->Void;

    public function new(event:Int, handler:Constraint->Void) {
        this.event = event;
        this.handler = handler;
        constraint = this;
        type = Flag(ListenerType,CONSTRAINT);
    }

    flibmdel public inline function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");

		cbType.listeners.add(this);

        if     (event==Flag(CbEvent,WAKE))  cbType._conwake = this;
        else if(event==Flag(CbEvent,SLEEP)) cbType._consleep = this;
        else cbType._break = this;
    }

    flibmdel public inline function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");

		cbType.listeners.remove(this);

        if     (event==Flag(CbEvent,WAKE))  cbType._conwake = this;
        else if(event==Flag(CbEvent,SLEEP)) cbType._consleep = this;
        else cbType._break = this;
    }

    flibmdel public inline function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    flibmdel public inline function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP) && newev != Flag(CbEvent,BREAK))
                throw "Error: ConstraintListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

$(mixin cbnhas(cb1,cb2,type) (cb1._`type==0 || cb2._`type==0 || space._`type.ordered_get(cb1.id,cb2.id)==null));

class PR(InteractionListener) extends PR(Listener) {
	public var outer_zn:InteractionListener;

    public var cb1:PR(CbType);
    public var cb2:PR(CbType);
    public var handler:Interactor->Interactor->Void;

	//used in hash lookups
	public var hnext:PR(InteractionListener);
	//ordered id's of cb1/cb2
	public var id:Int; public var di:Int;

	public function new(event:Int, handler:Interactor->Interactor->Void) {
		this.event = event;
		this.handler = handler;
		interaction = this;
		type = Flag(ListenerType,INTERACTION);
	}

	public function assign() {
		//see if this is a new compound callback listener for the two types
		//aka if begin, check for an end existing already etc
		if((event==Flag(CbEvent,BEGIN) && cbnhas(cb1,cb2,end) && cbnhas(cb1,cb2,pre))
		|| (event==Flag(CbEvent,END)   && cbnhas(cb1,cb2,begin) && cbnhas(cb1,cb2,pre))) {
			Iter(shape, cb1.shapes, space.freshShapeType(shape,cb1,cb2));
			Iter(body,  cb1.bodies, space.freshBodyType (body,cb1,cb2));
			if(cb2!=cb1) {
				Iter(shape, cb2.shapes, space.freshShapeType(shape,cb1,cb2));
				Iter(body,  cb2.bodies, space.freshBodyType (body,cb1,cb2));
			}
		}
	}
	public function unassign() {
		//see if this was the only compound callback listener
		//aka if begin, check end doesn't exist
		if((event==Flag(CbEvent,BEGIN) && cbnhas(cb1,cb2,end) && cbnhas(cb1,cb2,pre))
		|| (event==Flag(CbEvent,END)   && cbnhas(cb1,cb2,begin) && cbnhas(cb1,cb2,pre))) {
			Iter(shape, cb1.shapes, space.nullShapeType(shape,cb1,cb2));
			Iter(body,  cb1.bodies, space.nullBodyType (body,cb1,cb2));
			if(cb2!=cb1) {
				Iter(shape, cb2.shapes, space.nullShapeType(shape,cb1,cb2));
				Iter(body,  cb2.bodies, space.nullBodyType (body,cb1,cb2));
			}
		}
	}

	flibmdel public inline function addedToSpace(?skip=false) {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		cb1.listeners.add(this);
		if(cb2!=cb1) cb2.listeners.add(this);

		if  (event==Flag(CbEvent,BEGIN))   { cb1._begin++;   if(cb2!=cb1) cb2._begin++;   }
		else                               { cb1._end++;     if(cb2!=cb1) cb2._end++;     }
		
		if(!skip) assign();
	}
	flibmdel public inline function removedFromSpace(?skip=false) {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		cb1.listeners.remove(this);
		if(cb2!=cb1) cb2.listeners.remove(this);

		if  (event==Flag(CbEvent,BEGIN))   { cb1._begin--;   if(cb2!=cb1) cb2._begin--;   }
		else                               { cb1._end--;     if(cb2!=cb1) cb2._end--;     }

		if(!skip) unassign();
	}

    flibmdel public inline function swapCbType(which:Int, newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

		if(cb1!=null && cb2!=null && space!=null) {	
			space.revoke_listener(this);
			unassign();
		}

		$(mixin dope(dip,dat) {
			if(space!=null) {
				if(dip!=null && dip!=dat) {
					dip.listeners.remove(this);
					if  (event==Flag(CbEvent,BEGIN))   dip._begin--;
					else                               dip._end--;
				}

				dip = newcb;

				if(dip!=dat) {
					dip.listeners.add(this);
					if  (event==Flag(CbEvent,BEGIN))   dip._begin++;
					else                               dip._end++;
				}
			}else dip = newcb;
		});

		if(which==1) dope(cb1,cb2);
		else         dope(cb2,cb1);

		if(cb1!=null && cb2!=null) {
			//set hash id's
			if(cb1.id <= cb2.id)
				 { id = cb1.id; di = cb2.id; }
			else { id = cb2.id; di = cb1.id; }

			if(space!=null) {
				space.unrevoke_listener(this);
				assign();
			}
		}
    }

	flibmdel public inline function swapEvent(newev:Int) {
		DEBUG(
			if(newev != Flag(CbEvent,BEGIN) && newev != Flag(CbEvent,END))
				throw "Error: InteractionListener event must be either BEGIN, END";
		)
		removedFromSpace(true);
		event = newev;
		addedToSpace(true);
	}
}

class PR(PreListener) extends PR(Listener) {
	public var outer_zn:PreListener;

    public var cb1:PR(CbType);
    public var cb2:PR(CbType);
    public var handler:Arbiter->PreFlag;
	public var pure:Bool;

	//used in hash lookups
	public var hnext:PR(PreListener);
	//ordered id's of cb1/cb2
	public var id:Int; public var di:Int;

	public function new(handler:Arbiter->PreFlag, ?pure=false) {
		event = Flag(CbEvent,PRE);
		this.handler = handler;
		this.pure = pure;
		imm = this;
		type = Flag(ListenerType,PRE);
	}

	public function wake() {
		//PreListener only needs ito wake the bodies.
		//but we iterate the cb SHAPES, not the bodies
		//as the bodies refer to Body callbacks, not Interaction/Imm callbacks
		Iter(s, cb1.shapes, s.body.wake());
		if(cb2!=cb1)
			Iter(s, cb2.shapes, s.body.wake());
	}

	public function assign() {
		//see if this is a new compound callback listener for the two types
		//aka if begin, check for an end existing already etc
		if(cbnhas(cb1,cb2,begin) && cbnhas(cb1,cb2,end)) {
			Iter(shape, cb1.shapes, space.freshShapeType(shape,cb1,cb2));
			Iter(body,  cb1.bodies, space.freshBodyType (body,cb1,cb2));
			if(cb2!=cb1) {
				Iter(shape, cb2.shapes, space.freshShapeType(shape,cb1,cb2));
				Iter(body,  cb2.bodies, space.freshBodyType (body,cb1,cb2));
			}
		}
	}
	public function unassign() {
		//see if this was the only compound callback listener
		//aka if begin, check end doesn't exist
		if(cbnhas(cb1,cb2,begin) && cbnhas(cb1,cb2,end)) {
			Iter(shape, cb1.shapes, space.nullShapeType(shape,cb1,cb2));
			Iter(body,  cb1.bodies, space.nullBodyType (body,cb1,cb2));
			if(cb2!=cb1) {
				Iter(shape, cb2.shapes, space.nullShapeType(shape,cb1,cb2));
				Iter(body,  cb2.bodies, space.nullBodyType (body,cb1,cb2));
			}
		}
	}

	flibmdel public inline function addedToSpace() {
		assert(cb1!=null && cb2!=null, "listener added to space with no cbtypes associated");

		cb1.listeners.add(this);
		if(cb2!=cb1) cb2.listeners.add(this);

		cb1._pre++; if(cb2!=cb1) cb2._pre++;
		assign();
	}
	flibmdel public inline function removedFromSpace() {
		assert(cb1!=null && cb2!=null, "listener added to space with no cbtypes associated?");

		cb1.listeners.remove(this);
		if(cb2!=cb1) cb2.listeners.remove(this);

		cb1._pre--; if(cb2!=cb1) cb2._pre--;
		unassign();
	}

	flibmdel public inline function swapCbType(which:Int, newcb:PR(CbType)) {
		assert(newcb!=null,"swap to null cbtype?");

		if(cb1!=null && cb2!=null && space!=null) {
			space.revoke_listener(this);
			unassign();
		}

		$(mixin dope(dip,dat) {
			if(space!=null) {
				if(dip!=null && dip!=dat) {
					dip.listeners.remove(this);
					dip._pre--;
				}

				dip = newcb;

				if(dip!=dat) {
					dip.listeners.add(this);
					dip._pre++;
				}
			}else dip = newcb;
		});

		if(which==1) dope(cb1,cb2);
		else         dope(cb2,cb1);

		if(cb1!=null && cb2!=null) {
			//set hash id's
			if(cb1.id <= cb2.id)
			 	 { id = cb1.id; di = cb2.id; }
			else { id = cb2.id; di = cb1.id; }

			if(space!=null) {
				space.unrevoke_listener(this);
				assign();
			}
		}
	}
}
