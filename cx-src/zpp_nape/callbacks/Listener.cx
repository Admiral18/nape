package zpp_nape.callbacks;
$(import);

class PR(Listener) {
    public var outer:Listener;
    public static var internal:Bool = false;

    public var type:Int; //Flag(ListenerType)
    public var event:Int; //Flag(CbEvent)

    public var body:PR(BodyListener);
    public var constraint:PR(ConstraintListener);
    public var interaction:PR(InteractionListener);
    public var imm:PR(ImmListener);

    public var space:PR(Space);
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(BodyListener) extends PR(Listener) {
    public var outer_zn:BodyListener;

    public var cbType:PR(CbType);
    public var handler:Body->Void;

    public function new(event:Int, handler:Body->Void) {
        this.event = event;
        this.handler = handler;
        body = this;
        type = Flag(ListenerType,BODY);
    }

    flibmdel public inline function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");

		cbType.listeners.add(this);

        if(event==Flag(CbEvent,WAKE))
             cbType._bodywake = this;
        else cbType._bodysleep = this;
    }

    flibmdel public inline function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");

		cbType.listeners.remove(this);

        if(event==Flag(CbEvent,WAKE))
             cbType._bodywake = null;
        else cbType._bodysleep = null;
    }

    flibmdel public inline function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    flibmdel public inline function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP))
                throw "Error: BodyListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(ConstraintListener) extends PR(Listener) {
    public var outer_zn:ConstraintListener;

    public var cbType:PR(CbType);
    public var handler:Constraint->Void;

    public function new(event:Int, handler:Constraint->Void) {
        this.event = event;
        this.handler = handler;
        constraint = this;
        type = Flag(ListenerType,CONSTRAINT);
    }

    flibmdel public inline function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");

		cbType.listeners.add(this);

        if     (event==Flag(CbEvent,WAKE))  cbType._conwake = this;
        else if(event==Flag(CbEvent,SLEEP)) cbType._consleep = this;
        else cbType._break = this;
    }

    flibmdel public inline function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");

		cbType.listeners.remove(this);

        if     (event==Flag(CbEvent,WAKE))  cbType._conwake = this;
        else if(event==Flag(CbEvent,SLEEP)) cbType._consleep = this;
        else cbType._break = this;
    }

    flibmdel public inline function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    flibmdel public inline function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP) && newev != Flag(CbEvent,BREAK))
                throw "Error: ConstraintListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

class PR(InteractionListener) extends PR(Listener) {
	public var outer_zn:InteractionListener;

    public var cb1:PR(CbType);
    public var cb2:PR(CbType);
    public var handler:Arbiter->Void;

	public function new(event:Int, handler:Arbiter->Void) {
		this.event = event;
		this.handler = handler;
		interaction = this;
		type = Flag(ListenerType,INTERACTION);
	}

	flibmdel public inline function addedToSpace() {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		cb1.listeners.add(this);
		if(cb2!=cb1) cb2.listeners.add(this);

		if  (event==Flag(CbEvent,BEGIN))   { cb1._begin++;   if(cb2!=cb1) cb2._begin++;   }
		elif(event==Flag(CbEvent,ONGOING)) { cb1._ongoing++; if(cb2!=cb1) cb2._ongoing++; }
		else                               { cb1._end++;     if(cb2!=cb1) cb2._end++;     }
	}
	flibmdel public inline function removedFromSpace() {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		cb1.listeners.remove(this);
		if(cb2!=cb1) cb2.listeners.remove(this);

		if  (event==Flag(CbEvent,BEGIN))   { cb1._begin--;   if(cb2!=cb1) cb2._begin--;   }
		elif(event==Flag(CbEvent,ONGOING)) { cb1._ongoing--; if(cb2!=cb1) cb2._ongoing--; }
		else                               { cb1._end--;     if(cb2!=cb1) cb2._end--;     }
	}

    flibmdel public inline function swapCbType(which:Int, newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

		$(mixin dope(dip,dat) {
			if(space!=null) {
				if(dip!=null && dip!=dat) {
					dip.listeners.remove(this);

					if  (event==Flag(CbEvent,BEGIN))   dip._begin--;
					elif(event==Flag(CbEvent,ONGOING)) dip._ongoing--;
					else                               dip._end--;
				}

				dip = newcb;

				if(dip!=dat) {
					dip.listeners.add(this);

					if  (event==Flag(CbEvent,BEGIN))   dip._begin++;
					elif(event==Flag(CbEvent,ONGOING)) dip._ongoing++;
					else                               dip._end++;
				}
			}else dip = newcb;
		});

		if(which==1) dope(cb1,cb2);
		else         dope(cb2,cb1);
    }

	flibmdel public inline function swapEvent(newev:Int) {
		DEBUG(
			if(newev != Flag(CbEvent,BEGIN) && newev != Flag(CbEvent,ONGOING) && newev != Flag(CbEvent,END))
				throw "Error: InteractionListener event must be either BEGIN, ONGOING or END";
		)
		removedFromSpace();
		event = newev;
		addedToSpace();
	}
}

class PR(ImmListener) extends PR(Listener) {
    public var cb1:PR(CbType);
    public var cb2:PR(CbType);
    public var handler:Arbiter->ImmFlag;
}
