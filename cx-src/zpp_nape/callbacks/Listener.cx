package zpp_nape.callbacks;
$(import);

GENID(Listener)
class PR(Listener) {
    public var outer:Listener;
    public static var internal:Bool = false;

	public var id:Int; //for total ordering of listeners.

    public var type:Int; //Flag(ListenerType)
    public var event:Int; //Flag(CbEvent)
	public var precedence:Int; //for ordering in the case of more than one listener existing

    public var body:PR(BodyListener);
    public var constraint:PR(ConstraintListener);
    public var interaction:PR(InteractionListener);

    public var space:PR(Space);

	function new() {
		id = ID(Listener);
	}

	//ordering of listeners for CbSet/CbType etc.
	//want highest precedence at front.
	public inline static function set_lt(a:PR(Listener),b:PR(Listener)) {
		return a.precedence>b.precedence || (a.precedence==b.precedence && a.id>b.id);
	}
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

//used for Body/Constraint Listener that require mostly the same attributes
$(mixin SingleListener(t,T,FLAG)
	public var outer_zn:T`Listener;

	public var options:PR(OptionType);
	public var handler:T`Callback->Void;
	DEBUG(function immutable_options() {
		if(space!=null && space.midstep)
			throw "Error: Cannot change listener type options during space.step()";
	})

	public function new(options:OptionType, event:Int, handler:T`Callback->Void) {
		super();
		this.event = event;
		this.handler = handler;
		t = this;
		type = FLAG;
		this.options = options.pr(inner);
	}

	public function addedToSpace() {
		options.handler = cbtype_change;
		Iter(cb, options.includes, cb.add`t(this));
	}
	public function removedFromSpace() {
		Iter(cb, options.includes, cb.remove`t(this));
		options.handler = null;
	}
	function cbtype_change(cb:PR(CbType),added:Bool) {
		if(added) cb.add`t(this);
		else cb.remove`t(this);
	}

	public function changed_precedence() {
		if(space!=null) {
			removedFromSpace();
			addedToSpace();
		}
	}
);

class PR(BodyListener) extends PR(Listener) {
	SingleListener(body,Body,Flag(ListenerType,BODY))

    public function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP))
                throw "Error: BodyListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

class PR(ConstraintListener) extends PR(Listener) {
	SingleListener(constraint,Constraint,Flag(ListenerType,CONSTRAINT))

    public function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP) && newev != Flag(CbEvent,BREAK))
                throw "Error: ConstraintListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

//shared between public InteractionListener
//and public PreListener
class PR(InteractionListener) extends PR(Listener) {
	public var outer_zni:InteractionListener;
	public var outer_znp:PreListener;

	public var itype:Int; //InteractionType Flag
/*    public var cb1:PR(CbType);
    public var cb2:PR(CbType);*/

	public var options1:PR(OptionType);
	public var options2:PR(OptionType);

	//for InteractionListener
    public var handleri:InteractionCallback->Void;
	//for PreListener
	public var pure:Bool;
	public var handlerp:PreCallback->PreFlag;

	//used in lookups based on cbTypes
	public var cid:Int; public var cdi:Int;

	public function settype(xtype:Int) {
		itype = xtype;
	}

	public function new(options1:OptionType, options2:OptionType, event:Int,type:Int) {
		super();
		this.type = type;
		interaction = this;
		this.event = event;
		this.options1 = options1.pr(inner);
		this.options2 = options2.pr(inner);
	}

	function with_union(lambda:PR(CbType)->Void) {
		var ite1 = options1.includes.begin();
		var ite2 = options2.includes.begin();
		while(ite1!=null && ite2!=null) {
			var cb1 = ite1.elem();
			var cb2 = ite2.elem();
			if(cb1==cb2) { 
				lambda(cb1);
				ite1 = ite1.next; ite2 = ite2.next;
			}elif(PR(CbType).set_lt(cb1,cb2)) {
				lambda(cb1);
				ite1 = ite1.next;
			}else {
				lambda(cb2);
				ite2 = ite2.next;
			}
		}
		while(ite1!=null) {
			lambda(ite1.elem());
			ite1 = ite1.next;
		}
		while(ite2!=null) {
			lambda(ite2.elem());
			ite2 = ite2.next;
		}
	}

	//for PreListener
	public function wake() {
		assert(type==Flag(ListenerType,PRE),"waking non-pre?");
		//PreListener only needs ito wake the bodies.
		//but we iterate the cb SHAPES, not the bodies
		//as the bodies refer to Body callbacks, not Interaction/Imm callbacks
		/*Iter(i, cb1.interactors, i.wake());
		if(cb2!=cb1)
			Iter(i, cb2.interactors, i.wake());*/

		with_union(function (cb:PR(CbType)) Iter(i,cb.interactors,i.wake()));
	}

	//given two sorted lists, find all unique pairings of elements.
	$(expand genmethod(T)
	static var U`T = new List(PR(T))();
	static var V`T = new List(PR(T))();
	static var W`T = new List(PR(T))();
	flibmdel inline function T`set(A:List(PR(T)), B:List(PR(T)), lambda:PR(T)->PR(T)->Void) {
		// let A = options1.includes, B = options2.includes (sorted lists)
		// let U = A-B, V = B-A, W = A intersect B
		// then we require to find (UxB) ++ (VxW) ++ a_triangle_of(WxW)
		// all duplicates are found in below/above the diagonal of WxW as a table. so easy to discard.
		//
		// total time O(|A||B|).
	
		//first find U,V,W in single O(|A|+|B|) time pass abusing sorted nature of A,B
		var U = U`T; var V = V`T; var W = W`T;
		var aite = A.begin(); var bite = B.begin();
		while(aite!=null && bite!=null) {
			var a = aite.elem(); var b = bite.elem();
			if(a==b) {
				W.inlined_add(a);
				aite = aite.next;
				bite = bite.next;
			}else if(PR(T).set_lt(a,b)) {
				U.inlined_add(a);
				aite = aite.next;
			}else {
				V.inlined_add(b);
				bite = bite.next;
			}
		}
		while(aite!=null) { U.inlined_add(aite.elem()); aite = aite.next; }
		while(bite!=null) { V.inlined_add(bite.elem()); bite = bite.next; }

		//now product away cleaning up as we go!
		ClearWith(x, U, Iter(y, B, lambda(x,y)));
		ClearWith(x, V, Iter(y, W, lambda(x,y)));
		//triangle product, works due to ClearWith
		ClearWith(x, W, {
			lambda(x,x); Iter(y, W, lambda(x,y));
		});
	});
	genmethod(CbSet) genmethod(CbType)

	//operate on all unique CbSet pairs generatable from options.
	//had to move this to a non-inlined method specialising based on argument
	//instead of inlined with a closure due to haxe errors.
	function with_uniquesets(fresh:Bool) {
		CbTypeset(options1.includes, options2.includes, function (a:PR(CbType), b:PR(CbType)) {
			CbSetset(a.cbsets, b.cbsets, function (a:PR(CbSet), b:PR(CbSet)) {
				if(PR(CbSet).empty_intersection(a,b)) {
					if(fresh) space.freshListenerType(a,b);
					else      space.nullListenerType(a,b);
				}
			});
		});
	}
/*
	//generate set of all unique pairs of CbSet's generatable via the optionals includes list.
	function genset() {
		var set = Get(Set(PR(CbSetPair)));
		set.lt = PR(CbSetPair).set_lt;
		Iter(cb1, options1.includes, {
		Iter(cb2, options2.includes, {
			//avoid duplicate pairs, can we do better?
			if(options1.includes.has(cb2) && options2.includes.has(cb1) && PR(CbType).set_lt(cb2,cb1)) cx_continue;
			
			Iter(cs1, cb1.cbsets, {
			Iter(cs2, cb2.cbsets, {
				//avoid dupliscate pairs, can we do better?
				if(cb1.cbsets.has(cs2) && cb2.cbsets.has(cs1) && PR(CbSet).set_lt(cs2,cs1)) cx_continue;

				if(PR(CbSet).empty_intersection(cs1,cs2))
					set.try_insert(PR(CbSetPair).get(cs1,cs2));	
			});
			});
		});
		});
		return set;
	}
*/
	public function assign() {
		/*Iter(cs1,cb1.cbsets,{
		Iter(cs2,cb2.cbsets,{
			//avoid duplicate pairs, can we do better?
			if(cb1.cbsets.has(cs2) && cb2.cbsets.has(cs1) && PR(CbSet).set_lt(cs2,cs1)) cx_continue;

			if(PR(CbSet).empty_intersection(cs1,cs2))
				space.freshListenerType(cs1,cs2);
		});
		});
*/

		with_uniquesets(true);
/*		genset().clear_with(function (pair:PR(CbSetPair)) {
			space.freshListenerType(pair.a,pair.b);
			pair.free();
		});
/*
		if(PR(CbType).empty_intersection(cb1,cb2))
			space.freshListenerType(cb1,cb2);
*/
		with_union(function (cb:PR(CbType)) cb.addint(this));

/*		cb1.addint(this);
		if(cb1!=cb2) cb2.addint(this);*/
	}
	public function unassign() {
	/*	cb1.removeint(this);
		if(cb1!=cb2) cb2.removeint(this);
*/
		with_union(function (cb:PR(CbType)) cb.removeint(this));

/*		Iter(cs1,cb1.cbsets,{
		Iter(cs2,cb2.cbsets,{
			//avoid duplicate pairs, can we do better?
			if(cb1.cbsets.has(cs2) && cb2.cbsets.has(cs1) && PR(CbSet).set_lt(cs2,cs1)) cx_continue;

			if(PR(CbSet).empty_intersection(cs1,cs2))
				space.nullListenerType(cs1,cs2);
		});
		});*/

		with_uniquesets(false);
		/*genset().clear_with(function (pair:PR(CbSetPair)) {
			space.nullListenerType(pair.a,pair.b);
			pair.free();
		});*/
/*
		if(PR(CbType).empty_intersection(cb1,cb2))
			space.nullListenerType(cb1,cb2);*/
	}

	public function changed_precedence() {
		if(space!=null) {
/*			cb1.removeint(this);
			cb1.addint(this);
			if(cb1!=cb2) {
				cb2.removeint(this);
				cb2.addint(this);
			}
*/
			var pre = type==Flag(ListenerType,PRE);
			with_union(function (cb:PR(CbType)) {
				cb.removeint(this); cb.addint(this);
				//need to wake in the case of PRE listeners
				//since the result of the pre-listener compositions
				//may change
				Iter(i, cb.interactors, i.wake());
			});
			
	/*		if(type==Flag(ListenerType,PRE)) {
				Iter(i, cb1.interactors, i.wake());
				if(cb1!=cb2) Iter(i, cb2.interactors, i.wake());
			}*/
		}
	}

	public function addedToSpace(?skip=false) {
	//	assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		if(!skip) assign();
	}
	public function removedFromSpace(?skip=false) {
	//	assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		if(!skip) unassign();
	}

   /* public function swapCbType(which:Int, newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

		if(cb1!=null && cb2!=null && space!=null) {	
			space.revoke_listener(this);
			unassign();
		}

		if(which==1) cb1 = newcb;
		else         cb2 = newcb;

		if(cb1!=null && cb2!=null) {
			//set hash id's
			if(cb1.id <= cb2.id)
				 { cid = cb1.id; cdi = cb2.id; }
			else { cid = cb2.id; cdi = cb1.id; }
			assert(cid<cdi || (cb1==cb2 && cid==cdi),"cbTypes in swapCbType of listener not well ordered");

			if(space!=null) {
				assign();
				space.unrevoke_listener(this);
			}
		}
    }*/

	public function swapEvent(newev:Int) {
		DEBUG(
			if(type == Flag(ListenerType,PRE))
				throw "Error: PreListener event can only be PRE";
			elif(newev != Flag(CbEvent,BEGIN) && newev != Flag(CbEvent,END) && newev != Flag(CbEvent,ONGOING))
				throw "Error: InteractionListener event must be either BEGIN, END, ONGOING";
		)
		removedFromSpace(true);
		event = newev;
		addedToSpace(true);
	}
}
