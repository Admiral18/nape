package zpp_nape.callbacks;
$(import);

class PR(Listener) {
    public var outer:Listener;
    public static var internal:Bool = false;

    public var type:Int; //Flag(ListenerType)
    public var event:Int; //Flag(CbEvent)

    public var body:PR(BodyListener);
    public var constraint:PR(ConstraintListener);
    public var interaction:PR(InteractionListener);

    public var space:PR(Space);
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(BodyListener) extends PR(Listener) {
    public var outer_zn:BodyListener;

    public var cbType:PR(CbType);
    public var handler:BodyCallback->Void;

    public function new(event:Int, handler:BodyCallback->Void) {
        this.event = event;
        this.handler = handler;
        body = this;
        type = Flag(ListenerType,BODY);
    }

    public function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");

        if(event==Flag(CbEvent,WAKE))
             cbType._bodywake = this;
        else cbType._bodysleep = this;
    }

    public function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");

        if(event==Flag(CbEvent,WAKE))
             cbType._bodywake = null;
        else cbType._bodysleep = null;
    }

    flibmdel public inline function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    flibmdel public inline function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP))
                throw "Error: BodyListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(ConstraintListener) extends PR(Listener) {
    public var outer_zn:ConstraintListener;

    public var cbType:PR(CbType);
    public var handler:ConstraintCallback->Void;

    public function new(event:Int, handler:ConstraintCallback->Void) {
        this.event = event;
        this.handler = handler;
        constraint = this;
        type = Flag(ListenerType,CONSTRAINT);
    }

    public function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");

        if     (event==Flag(CbEvent,WAKE))  cbType._conwake = this;
        else if(event==Flag(CbEvent,SLEEP)) cbType._consleep = this;
        else cbType._break = this;
    }

    public function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");

        if     (event==Flag(CbEvent,WAKE))  cbType._conwake = this;
        else if(event==Flag(CbEvent,SLEEP)) cbType._consleep = this;
        else cbType._break = this;
    }

    flibmdel public inline function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    flibmdel public inline function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP) && newev != Flag(CbEvent,BREAK))
                throw "Error: ConstraintListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

//holds all listeners assigned between two cbTypes
//that have been added to a space.
//
//whilst less performant than the original _begin,_end,_pre hashes
//this genearlises the listeners to any new callback that might
//be introduced, as well as allowing the original begin/end/pre
//to be applied over an interaction type discriminatly.
class PR(ListenerSet) {
	MixPool(PR(ListenerSet))

	public var cb1:PR(CbType);
	public var cb2:PR(CbType);

	//used for FastHash2
	public var hnext:PR(ListenerSet);
	public var id:Int; public var di:Int;

	public var listeners:List(PR(InteractionListener));

	//---------------------------------------------------------

	public function new() {
		listeners = new List(PR(InteractionListener))();
	}

	flibmdel public inline function alloc() {}
	flibmdel public inline function free () {
		assert(listeners.empty(),"non empty listener list on free");
	}

	//---------------------------------------------------------

	public static inline function get(x:PR(InteractionListener)) {
		var ret = Get(PR(ListenerSet));
		ret.cb1 = x.cb1; ret.cb2 = x.cb2;
		ret.id  = x.id;  ret.di  = x.di;
		return ret;
	}

	flibmdel public inline function find(event:Int,type:Int) {
		var ret:PR(InteractionListener) = null;
		Iter(x, listeners, {
			if((x.itype&type)!=0 && x.event==event) {
				DEBUG(if(ret!=null) throw "Error: Multiple valid Pre/InteractionListener defined between the cbTypes";)
				ret = x;
				RELEASE(break;)
			}
		});
		return ret;
	}

	flibmdel public inline function find_all(event:Int, cb:PR(InteractionListener)->Void) {
		Iter(x, listeners, {
			if(x.event==event)
				cb(x);
		});
	}
}

//shared between public InteractionListener
//and public PreListener
class PR(InteractionListener) extends PR(Listener) {
	public var outer_zni:InteractionListener;
	public var outer_znp:PreListener;

	public var itype:Int; //InteractionType Flag
    public var cb1:PR(CbType);
    public var cb2:PR(CbType);

	//for InteractionListener
    public var handleri:InteractionCallback->Void;
	//for PreListener
	public var pure:Bool;
	public var handlerp:PreCallback->PreFlag;

	//used in hash lookups based on cbTypes
	public var hnext:PR(InteractionListener);
	public var id:Int; public var di:Int;

	public function settype(xtype:Int) {
		itype = xtype;
	}

	public function new(event:Int,type:Int) {
		this.type = type;
		interaction = this;
		this.event = event;
	}

	//for PreListener
	public function wake() {
		assert(type==Flag(ListenerType,PRE),"waking non-pre?");
		//PreListener only needs ito wake the bodies.
		//but we iterate the cb SHAPES, not the bodies
		//as the bodies refer to Body callbacks, not Interaction/Imm callbacks
		Iter(i, cb1.interactors, i.wake());
		if(cb2!=cb1)
			Iter(i, cb2.interactors, i.wake());
	}

	public function assign() {
		//if(space.listenersets.get(id,di)==null)
		if(PR(CbType).empty_intersection(cb1,cb2))
			space.freshListenerType(cb1,cb2);

		cb1.insert(this);
		cb2.insert(this);
	}
	public function unassign() {
		cb1.remove(this);
		cb2.remove(this);

		//if(space.listenersets.get(id,di)==null)
		if(PR(CbType).empty_intersection(cb1,cb2))
			space.nullListenerType(cb1,cb2);
	}

	public function addedToSpace(?skip=false) {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		if(!skip) assign();
	}
	public function removedFromSpace(?skip=false) {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		if(!skip) unassign();
	}

    flibmdel public inline function swapCbType(which:Int, newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

		if(cb1!=null && cb2!=null && space!=null) {	
			space.revoke_listener(this);
			unassign();
		}

		if(which==1) cb1 = newcb;
		else         cb2 = newcb;

		if(cb1!=null && cb2!=null) {
			//set hash id's
			if(cb1.id <= cb2.id)
				 { id = cb1.id; di = cb2.id; }
			else { id = cb2.id; di = cb1.id; }

			if(space!=null) {
				assign();
				space.unrevoke_listener(this);
			}
		}
    }

	flibmdel public inline function swapEvent(newev:Int) {
		DEBUG(
			if(type == Flag(ListenerType,PRE))
				throw "Error: PreListener event can only be PRE";
			elif(newev != Flag(CbEvent,BEGIN) && newev != Flag(CbEvent,END) && newev != Flag(CbEvent,ONGOING))
				throw "Error: InteractionListener event must be either BEGIN, END, ONGOING";
		)
		removedFromSpace(true);
		event = newev;
		addedToSpace(true);
	}
}
