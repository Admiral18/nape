package zpp_nape.callbacks;
$(import);

GENID(Listener)
class PR(Listener) {
    public var outer:Listener;
    public static var internal:Bool = false;

	public var id:Int; //for total ordering of listeners.

    public var type:Int; //Flag(ListenerType)
    public var event:Int; //Flag(CbEvent)
	public var precedence:Int; //for ordering in the case of more than one listener existing

    public var body:PR(BodyListener);
    public var constraint:PR(ConstraintListener);
    public var interaction:PR(InteractionListener);

    public var space:PR(Space);

	function new() {
		id = ID(Listener);
	}

	//ordering of listeners for CbSet/CbType etc.
	//want highest precedence at front.
	public inline static function set_lt(a:PR(Listener),b:PR(Listener)) {
		return a.precedence>b.precedence || (a.precedence==b.precedence && a.id>b.id);
	}
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(BodyListener) extends PR(Listener) {
    public var outer_zn:BodyListener;

    public var cbType:PR(CbType);
    public var handler:BodyCallback->Void;

    public function new(event:Int, handler:BodyCallback->Void) {
		super();
        this.event = event;
        this.handler = handler;
        body = this;
        type = Flag(ListenerType,BODY);
    }

    public function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");
		cbType.addbody(this);
    }

    public function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");
		cbType.removebody(this);
    }

	public function changed_precedence() {
		if(space!=null) {
			cbType.removebody(this);
			cbType.addbody(this);
		}
	}

    public function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    public function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP))
                throw "Error: BodyListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(ConstraintListener) extends PR(Listener) {
    public var outer_zn:ConstraintListener;

    public var cbType:PR(CbType);
    public var handler:ConstraintCallback->Void;

    public function new(event:Int, handler:ConstraintCallback->Void) {
		super();
        this.event = event;
        this.handler = handler;
        constraint = this;
        type = Flag(ListenerType,CONSTRAINT);
    }

    public function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");
		cbType.addcon(this);
    }

    public function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");
		cbType.removecon(this);
    }

	public function changed_precedence() {
		if(space!=null) {
			cbType.removecon(this);
			cbType.addcon(this);
		}
	}

    public function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    public function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP) && newev != Flag(CbEvent,BREAK))
                throw "Error: ConstraintListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

//shared between public InteractionListener
//and public PreListener
class PR(InteractionListener) extends PR(Listener) {
	public var outer_zni:InteractionListener;
	public var outer_znp:PreListener;

	public var itype:Int; //InteractionType Flag
    public var cb1:PR(CbType);
    public var cb2:PR(CbType);

	//for InteractionListener
    public var handleri:InteractionCallback->Void;
	//for PreListener
	public var pure:Bool;
	public var handlerp:PreCallback->PreFlag;

	//used in lookups based on cbTypes
	public var cid:Int; public var cdi:Int;

	public function settype(xtype:Int) {
		itype = xtype;
	}

	public function new(event:Int,type:Int) {
		super();
		this.type = type;
		interaction = this;
		this.event = event;
	}

	//for PreListener
	public function wake() {
		assert(type==Flag(ListenerType,PRE),"waking non-pre?");
		//PreListener only needs ito wake the bodies.
		//but we iterate the cb SHAPES, not the bodies
		//as the bodies refer to Body callbacks, not Interaction/Imm callbacks
		Iter(i, cb1.interactors, i.wake());
		if(cb2!=cb1)
			Iter(i, cb2.interactors, i.wake());
	}

	public function assign() {
		Iter(cs1,cb1.cbsets,{
		Iter(cs2,cb2.cbsets,{
			//avoid duplicate pairs, can we do better?
			if(cb1.cbsets.has(cs2) && cb2.cbsets.has(cs1) && PR(CbSet).set_lt(cs2,cs1)) cx_continue;

			if(PR(CbSet).empty_intersection(cs1,cs2))
				space.freshListenerType2(cs1,cs2);
		});
		});

		if(PR(CbType).empty_intersection(cb1,cb2))
			space.freshListenerType(cb1,cb2);

		cb1.addint(this);
		if(cb1!=cb2) cb2.addint(this);
	}
	public function unassign() {
		cb1.removeint(this);
		if(cb1!=cb2) cb2.removeint(this);

		Iter(cs1,cb1.cbsets,{
		Iter(cs2,cb2.cbsets,{
			//avoid duplicate pairs, can we do better?
			if(cb1.cbsets.has(cs2) && cb2.cbsets.has(cs1) && PR(CbSet).set_lt(cs2,cs1)) cx_continue;

			if(PR(CbSet).empty_intersection(cs1,cs2))
				space.nullListenerType2(cs1,cs2);
		});
		});

		if(PR(CbType).empty_intersection(cb1,cb2))
			space.nullListenerType(cb1,cb2);
	}

	public function changed_precedence() {
		if(space!=null) {
			cb1.removeint(this);
			cb1.addint(this);
			if(cb1!=cb2) {
				cb2.removeint(this);
				cb2.addint(this);
			}
			
			//need to wake in the case of PRE listeners
			//since the result of the pre-listener compositions
			//may change
			if(type==Flag(ListenerType,PRE)) {
				Iter(i, cb1.interactors, i.wake());
				if(cb1!=cb2) Iter(i, cb2.interactors, i.wake());
			}
		}
	}

	public function addedToSpace(?skip=false) {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		if(!skip) assign();
	}
	public function removedFromSpace(?skip=false) {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		if(!skip) unassign();
	}

    public function swapCbType(which:Int, newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

		if(cb1!=null && cb2!=null && space!=null) {	
			space.revoke_listener(this);
			unassign();
		}

		if(which==1) cb1 = newcb;
		else         cb2 = newcb;

		if(cb1!=null && cb2!=null) {
			//set hash id's
			if(cb1.id <= cb2.id)
				 { cid = cb1.id; cdi = cb2.id; }
			else { cid = cb2.id; cdi = cb1.id; }
			assert(cid<cdi || (cb1==cb2 && cid==cdi),"cbTypes in swapCbType of listener not well ordered");

			if(space!=null) {
				assign();
				space.unrevoke_listener(this);
			}
		}
    }

	public function swapEvent(newev:Int) {
		DEBUG(
			if(type == Flag(ListenerType,PRE))
				throw "Error: PreListener event can only be PRE";
			elif(newev != Flag(CbEvent,BEGIN) && newev != Flag(CbEvent,END) && newev != Flag(CbEvent,ONGOING))
				throw "Error: InteractionListener event must be either BEGIN, END, ONGOING";
		)
		removedFromSpace(true);
		event = newev;
		addedToSpace(true);
	}
}
