package zpp_nape.callbacks;
$(import);

class PR(Listener) {
    public var outer:Listener;
    public static var internal:Bool = false;

    public var type:Int; //Flag(ListenerType)
    public var event:Int; //Flag(CbEvent)

    public var body:PR(BodyListener);
    public var constraint:PR(ConstraintListener);
    public var interaction:PR(InteractionListener);
    public var imm:PR(ImmListener);

    public var space:PR(Space);
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(BodyListener) extends PR(Listener) {
    public var outer_zn:BodyListener;

    public var cbType:PR(CbType);
    public var handler:Body->Void;

    public function new(event:Int, handler:Body->Void) {
        this.event = event;
        this.handler = handler;
        body = this;
        type = Flag(ListenerType,BODY);
    }

    flibmdel public inline function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");

		cbType.listeners.add(this);

        if(event==Flag(CbEvent,WAKE))
             cbType._bodywake = this;
        else cbType._bodysleep = this;
    }

    flibmdel public inline function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");

		cbType.listeners.remove(this);

        if(event==Flag(CbEvent,WAKE))
             cbType._bodywake = null;
        else cbType._bodysleep = null;
    }

    flibmdel public inline function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    flibmdel public inline function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP))
                throw "Error: BodyListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

///_________________________________________________________________________________________________
///¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯

class PR(ConstraintListener) extends PR(Listener) {
    public var outer_zn:ConstraintListener;

    public var cbType:PR(CbType);
    public var handler:Constraint->Void;

    public function new(event:Int, handler:Constraint->Void) {
        this.event = event;
        this.handler = handler;
        constraint = this;
        type = Flag(ListenerType,CONSTRAINT);
    }

    flibmdel public inline function addedToSpace() {
        assert(cbType!=null,"listener added to space with no cbtype associated?");

		cbType.listeners.add(this);

        if     (event==Flag(CbEvent,WAKE))  cbType._conwake = this;
        else if(event==Flag(CbEvent,SLEEP)) cbType._consleep = this;
        else cbType._break = this;
    }

    flibmdel public inline function removedFromSpace() {
        assert(cbType!=null,"listener removed from space with no cbtype associated?");

		cbType.listeners.remove(this);

        if     (event==Flag(CbEvent,WAKE))  cbType._conwake = this;
        else if(event==Flag(CbEvent,SLEEP)) cbType._consleep = this;
        else cbType._break = this;
    }

    flibmdel public inline function swapCbType(newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

        //handle live data.
        if(space!=null) {
            if(cbType!=null) removedFromSpace();
            cbType = newcb;
            addedToSpace();
        }else cbType = newcb;
    }

    flibmdel public inline function swapEvent(newev:Int) {
        DEBUG(
            if(newev != Flag(CbEvent,WAKE) && newev != Flag(CbEvent,SLEEP) && newev != Flag(CbEvent,BREAK))
                throw "Error: ConstraintListener event must be either WAKE or SLEEP only";
        )
        removedFromSpace();
        event = newev;
        addedToSpace();
    }
}

class PR(InteractionListener) extends PR(Listener) {
	public var outer_zn:InteractionListener;

    public var cb1:PR(CbType);
    public var cb2:PR(CbType);
    public var handler:Arbiter->Void;

	//used in hash lookups
	public var hnext:PR(InteractionListener);
	//ordered id's of cb1/cb2
	public var id:Int; public var di:Int;

	public function new(event:Int, handler:Arbiter->Void) {
		this.event = event;
		this.handler = handler;
		interaction = this;
		type = Flag(ListenerType,INTERACTION);
	}

	flibmdel public inline function addedToSpace() {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		cb1.listeners.add(this);
		if(cb2!=cb1) cb2.listeners.add(this);

		if  (event==Flag(CbEvent,BEGIN))   { cb1._begin++;   if(cb2!=cb1) cb2._begin++;   }
		else                               { cb1._end++;     if(cb2!=cb1) cb2._end++;     }
	}
	flibmdel public inline function removedFromSpace() {
		assert(cb1!=null && cb2!=null,"listener added to space with no cbtypes associated?");

		cb1.listeners.remove(this);
		if(cb2!=cb1) cb2.listeners.remove(this);

		if  (event==Flag(CbEvent,BEGIN))   { cb1._begin--;   if(cb2!=cb1) cb2._begin--;   }
		else                               { cb1._end--;     if(cb2!=cb1) cb2._end--;     }
	}

    flibmdel public inline function swapCbType(which:Int, newcb:PR(CbType)) {
        assert(newcb!=null,"swap to null cbtype?");

		$(mixin dope(dip,dat) {
			if(space!=null) {
				if(dip!=null && dip!=dat) {
					dip.listeners.remove(this);

					if  (event==Flag(CbEvent,BEGIN))   dip._begin--;
					else                               dip._end--;
				}

				dip = newcb;

				if(dip!=dat) {
					dip.listeners.add(this);

					if  (event==Flag(CbEvent,BEGIN))   dip._begin++;
					else                               dip._end++;
				}
			}else dip = newcb;
		});

		if(which==1) dope(cb1,cb2);
		else         dope(cb2,cb1);

		if(cb1!=null && cb2!=null) {
			if(space!=null) space.revoke_listener(this);

			//set hash id's
			if(cb1.id <= cb2.id)
				 { id = cb1.id; di = cb2.id; }
			else { id = cb2.id; di = cb1.id; }

			if(space!=null) space.unrevoke_listener(this);
		}
    }

	flibmdel public inline function swapEvent(newev:Int) {
		DEBUG(
			if(newev != Flag(CbEvent,BEGIN) && newev != Flag(CbEvent,END))
				throw "Error: InteractionListener event must be either BEGIN, END";
		)
		removedFromSpace();
		event = newev;
		addedToSpace();
	}
}

class PR(ImmListener) extends PR(Listener) {
	public var outer_zn:ImmListener;

    public var cb1:PR(CbType);
    public var cb2:PR(CbType);
    public var handler:Arbiter->ImmFlag;
	public var pure:Bool;

	//used in hash lookups
	public var hnext:PR(ImmListener);
	//ordered id's of cb1/cb2
	public var id:Int; public var di:Int;

	public function new(handler:Arbiter->ImmFlag, ?pure=false) {
		event = Flag(CbEvent,PRE);
		this.handler = handler;
		this.pure = pure;
		imm = this;
		type = Flag(ListenerType,IMM);
	}

	flibmdel public inline function addedToSpace() {
		assert(cb1!=null && cb2!=null, "listener added to space with no cbtypes associated");

		cb1.listeners.add(this);
		if(cb2!=cb1) cb2.listeners.add(this);

		cb1._pre++; if(cb2!=cb1) cb2._pre++;
	}
	flibmdel public inline function removedFromSpace() {
		assert(cb1!=null && cb2!=null, "listener added to space with no cbtypes associated?");

		cb1.listeners.remove(this);
		if(cb2!=cb1) cb2.listeners.remove(this);

		cb1._pre--; if(cb2!=cb1) cb2._pre--;
	}

	flibmdel public inline function swapCbType(which:Int, newcb:PR(CbType)) {
		assert(newcb!=null,"swap to null cbtype?");

		$(mixin dope(dip,dat) {
			if(space!=null) {
				if(dip!=null && dip!=dat) {
					dip.listeners.remove(this);
					dip._pre--;
				}

				dip = newcb;

				if(dip!=dat) {
					dip.listeners.add(this);
					dip._pre++;
				}
			}else dip = newcb;
		});

		if(which==1) dope(cb1,cb2);
		else         dope(cb2,cb1);

		if(cb1!=null && cb2!=null) {
			if(space!=null) space.revoke_listener(this);

			//set hash id's
			if(cb1.id <= cb2.id)
			 	 { id = cb1.id; di = cb2.id; }
			else { id = cb2.id; di = cb1.id; }

			if(space!=null) space.unrevoke_listener(this);
		}
	}
}
