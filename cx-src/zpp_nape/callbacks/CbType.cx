package zpp_nape.callbacks;
$(import);

GENID(CbType)
class PR(CbType) {
    public var outer:CbType;

    static public var internal:Bool = false;
    public function wrapper() {
        if(outer==null) {
            internal = true;
            outer = new CbType();
            internal = false;
            outer.pr(inner) = this;
        }
        return outer;
    }

    ///---------------------------------------------------------------------------------------------

    public var id:Int;

    ///---------------------------------------------------------------------------------------------

	//only ACTIVE shape/constriants/bodies are referenced to avoid memory leaks
	public var interactors:List(PR(Interactor)); public var wrap_interactors:InteractorList;
    public var constraints:List(PR(Constraint)); public var wrap_constraints:ConstraintList;

    flibmdel public inline function addConstraint(con:PR(Constraint)) constraints.add(con)
	flibmdel public inline function addInteractor(intx:PR(Interactor)) interactors.add(intx)
	
	flibmdel public inline function remConstraint(con:PR(Constraint)) constraints.remove(con)
	flibmdel public inline function remInteractor(intx:PR(Interactor)) interactors.remove(intx)

    ///---------------------------------------------------------------------------------------------

	$(mixin listlist(T,n,r)
		public var n:List(PR(T));
		flibmdel public inline function add`r(x:PR(T)) {
			assert(!n.has(x),"listener already in list");
			//want highest precedence at start of list
			Insert(x,n,$(mixin less(i,j) (i.precedence>=j.precedence)) less);
		}
		flibmdel public inline function remove`r(x:PR(T)) {
			n.remove(x);
		}
		initlist(T,n)
	);

	//all lists are only updated when listener is added to a space!
	//set of interaction/pre listeners using the cbType
	listlist(InteractionListener,listeners,int)

	//set of body listeners using the cbType
	listlist(BodyListener,bodylisteners,body)
	//set of constraint listeners using the cbType
	listlist(ConstraintListener,conlisteners,con)

    ///---------------------------------------------------------------------------------------------

    public function new() {
        id = ID(CbType);

		$(expand object initlist(T,n)
			n = new List(PR(T))();
		)
        constraints = new List(PR(Constraint))();
		interactors = new List(PR(Interactor))();
    }

	//----------------------------------------------------------------------------------------------

	//determines if cbTypes share an interaction listener
	#if swc
		public static var log:Bool = false; /// ADOBE BUG IN iOS EXPORTER WORK AROUND
	#end
	public static function empty_intersection(a:PR(CbType),b:PR(CbType)) {
		var id = if(a.id<b.id) a.id else b.id;
		var di = if(a.id<b.id) b.id else a.id;
		assert(id<di || (a==b && id==di), "id/di in empty_intersectino not well ordered");

		var ret = false;
		var lx = (a.listeners.length<b.listeners.length) ? a.listeners : b.listeners;
	
		Iter(x,lx,{
			assert(!(x.id==di && x.di==id) || id==di,"listener id order didn't match cbtype id order??");
			if(x.id==id && x.di==di) { 
				ret = true;
				break;
			}
		});
		#if swc
			log = ret;
		#end
		return !ret;
	}

	//no longer used as multiple listeners are now allowed.
	public static function find(a:PR(CbType),b:PR(CbType), event:Int, type:Int) {
		var id = if(a.id<b.id) a.id else b.id;
		var di = if(a.id<b.id) b.id else a.id;
		assert(id<di || (a==b && id==di), "id/di in empty_intersectino not well ordered");

		var ret:PR(InteractionListener) = null;
		var lx = (a.listeners.length<b.listeners.length) ? a.listeners : b.listeners;
		Iter(x,lx,{
			assert(!(x.id==di && x.di==id) || id==di,"listener id order didn't match cbtype id order??");
			if(x.id==id && x.di==di && x.event==event && (x.itype&type)!=0) {
				DEBUG(if(ret!=null) throw "Error: multiple valid listeneres";)
				ret = x;
				RELEASE(break;)
			}
		});
		return ret;
	}

	//inlined for inline function call when used anonymously
	inline public static function find_all(a:PR(CbType),b:PR(CbType), event:Int, cb:PR(InteractionListener)->Void) {
		var id = if(a.id<b.id) a.id else b.id;
		var di = if(a.id<b.id) b.id else a.id;
		assert(id<di || (a==b && id==di), "id/di in empty_intersectino not well ordered");

		var lx = (a.listeners.length<b.listeners.length) ? a.listeners : b.listeners;
		Iter(x,lx,{
			assert(!(x.id==di && x.di==id) || id==di,"listener id order didn't match cbtype id order??");
			if(x.id==id && x.di==di && x.event==event)
				cb(x);
		});
	}
}
