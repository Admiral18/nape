package zpp_nape.callbacks;
$(import);

class PR(Callback) {
	public var outer_body:BodyCallback;
	public var outer_con:ConstraintCallback;
	public var outer_int:InteractionCallback;

	public static var internal = false;
	public function wrapper_body() {
		if(outer_body==null) {
			internal = true;
			outer_body = new BodyCallback();
			internal = false;
			outer_body.pr(inner) = this;
		}
		return outer_body;
	}
	public function wrapper_con() {
		if(outer_con==null) {
			internal = true;
			outer_con = new ConstraintCallback();
			internal = false;
			outer_con.pr(inner) = this;
		}
		return outer_con;
	}
	public function wrapper_int() {
		if(outer_int==null) {
			internal = true;
			outer_int = new InteractionCallback();
			internal = false;
			outer_int.pr(inner) = this;
		}
		genarbs();
		return outer_int;
	}
	
	//----------------

	public var event:Int;

    //to check for validity in API.
    public var space:PR(Space);
    public var index:Int;

    //queue
    QueueMix(PR(Callback))

    //pool
    MixPoolNoNext(PR(Callback))
    public function free() {
		int1 = int2 = null;
		body = null;
		constraint = null;
		listener = null;
		if(wrap_arbiters!=null)
			wrap_arbiters.pr(inner).inner = null;
		set = null;
	}
	public function alloc() {}
	
	//----------------
	
	//BEGIN/END/ONGOING/PRE
	public var int1:PR(Interactor);
	public var int2:PR(Interactor);
	//for nteractinos
	public var set:PR(CallbackSet);
	//for public.. could possibly improve this
	public var wrap_arbiters:ArbiterList;

	//pre:
	public var pre_arbiter:PR(Arbiter);
	public var pre_swapped:Bool;

	public function genarbs() {
		assert(set!=null,"after ongoing event was added, this should never be the case");
		if(wrap_arbiters==null)
			wrap_arbiters = PR(ArbiterList).get(set.arbiters,true);
		else
			wrap_arbiters.pr(inner).inner = set.arbiters;
		//we 'could' have arbiters track their sets and only do this if necessary
		//but.... the fact is these lists are either ignored, or iterated from the beginning
		//so it is really not necessary.
		wrap_arbiters.pr(inner).inv(length) = true;
		wrap_arbiters.pr(inner).at_ite = null;
	}

	//SLEEP/WAKE
	public var body:PR(Body);
	//SLEEP/WAKE/BREAK
	public var constraint:PR(Constraint);

    //all
    public var listener:PR(Listener);
	
	//----------------
	
	public function new() {
        length = 0;
    }
}
