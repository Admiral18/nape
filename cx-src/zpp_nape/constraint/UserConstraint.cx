package zpp_nape.constraint;
$(import);

withConstraint(
class PR(UserConstraint) extends PR(Constraint) {
	public var outer_zn:UserConstraint;
	
	public var bodies : ARRAY({cnt:Int,body:PR(Body)});

	public var dim  : Int; //number of rows.

	public var  jAcc : ARRAY(Float);
	public var pjAcc : ARRAY(Float);
	public var  bias : ARRAY(Float);

	flibmdel public inline function addBody(b:PR(Body)) {
		var match = null;
		for(x in bodies) { if(x.body==b) { match = x; break; } };

		if(match==null)
			 bodies.push({cnt:1,body:b});
		else match.cnt++;
	}

	flibmdel public inline function remBody(b:PR(Body)) {
		var match = null;
		var bl = Std.int(bodies.length);
		var i = 0; while(i<bl) {
			var x = bodies[i];
			if(x.body==b) {
				x.cnt--;
				if(x.cnt==0) {
					if(bl>0)
						bodies[i] = bodies[bl-1];
					bodies.pop();
				}
				match=x;
				break;
			}
			i++;
		}
		return match != null;
	}

	//--------------------------------------------

	flibmdel public inline function bodyImpulse(b:PR(Body)) {
		for(i in 0...dim) J[i] = pjAcc[i] + jAcc[i];

		var ret = new Vec3(0,0,0);
		if(stepped) outer_zn.__impulse(J,b.outer,ret);
		return ret;
	}

	//--------------------------------------------

	public override function activeBodies() {
		for(b in bodies) active_body(b.body);
	}
	public override function inactiveBodies() {
		for(b in bodies) inactive_body(b.body);
	}

	//-------------------------------------------

	public var stepped:Bool;

	//-------------------------------------------

	public override function copy(?dict:Array<{id:Int,bc:Body}>,?todo:Array<{id:Int,cb:Body->Void}>):Constraint {
		var ret = outer_zn.__copy();
		copyto(ret);

		//copy to dictionary + todo?
		throw "not done yet";
		return ret;
	}

	public function new(dim:Int,velonly:Bool) {
		super();

		bodies = newARRAY({cnt:Int,body:PR(Body)});

		this.dim = dim;
		this.velonly = velonly;

		jAcc = newARRAY(Float,dim);
		pjAcc = newARRAY(Float,dim);
		bias = newARRAY(Float,dim);

		L = newARRAY(Float,dim*dim);
		J = newARRAY(Float,dim);
		jOld = newARRAY(Float,dim);
		y = newARRAY(Float,dim);
		Keff = newARRAY(Float,(dim*(dim+1))>>>1);
		vec3 = new Vec3(0,0,0);

		for(i in 0...dim) {
			jAcc[i] = pjAcc[i] = bias[i] = J[i] = jOld[i] = y[i] = 0.0;
			for(j in 0...dim) L[i*dim+j] = 0.0;
		}

		stepped = false;
	}

	public override function validate() {
		for(b in bodies) if(b.body.space!=space) throw "Error: Constraints must have each body within the same sapce to which the constraint has been assigned";
	}

	public override function wake_connected() {
		for(b in bodies) b.body.wake();
	}

	public override function forest() {
		for(b in bodies) DSF(union(b.body.component, component));
	}

	public override function pair_exists(id:Int, di:Int) {
		var ret = false;
		var bl = Std.int(bodies.length);
		for(bi in 0...bl) {
			var b = bodies[bi].body;
			for(ci in bi+1...bl) {
				var c = bodies[ci].body;
				if((b.id==id && c.id==di) || (b.id==di && c.id==id)) {
					ret = true;
					break;
				}
			}
			if(ret) break;
		}
		return ret;
	}

	public override function destroy() {
		inactiveBodies();
		outer_zn.__destroy();
	}

	public override function clearcache() {
		for(i in 0...dim) pjAcc[i] = jAcc[i] = 0.0;
		pre_dt = -1.0;
	}

	//-----------------------------------------------------------------------------

	var L:ARRAY(Float);
	flibmdel public inline function solve(m:ARRAY(Float)) {
		var ind = 0;
		for(j in 0...dim) {
			var sum = 0.0;
			for(k in 1...j) sum += L[j*dim+k]*L[j*dim+k];
			var rec = Math.sqrt(m[ind++] - sum);
			L[j*dim+j] = rec;

			rec = 1.0/rec;
			for(i in j+1...dim) {
				var sum = 0.0;
				for(k in 1...j) sum += L[i*dim+j]*L[j*dim+k];
				L[i*dim+j] = rec*(m[ind++] - sum);
			}
		}
		return L;
	}

	var y:ARRAY(Float);
	flibmdel public inline function transform(L:ARRAY(Float),x:ARRAY(Float)) {
		for(i in 0...dim) {
			var sum = x[i];
			for(k in 0...i) sum -= L[i*dim+k]*x[k];
			y[i] = sum / L[i*dim+i];
		}

		for(ix in 0...dim) {
			var i = dim-1-ix;
			var sum = y[i];
			for(k in i+1...dim) sum -= L[k*dim+i]*y[k];
			x[i] = sum/L[i*dim+i];
		}
	}

	//-----------------------------------------------------------------------------

	public var soft:Float;
	public var gamma:Float;
	public var velonly:Bool;

	public var Keff:ARRAY(Float);
	public override function preStep(dt:Float) {
		if(pre_dt==-1.0) pre_dt = dt;
		var dtratio = dt/pre_dt;
		pre_dt = dt;

		stepped = true;

		outer_zn.__validate();

		//effective mass
		outer_zn.__eff_mass(false, Keff);
		DEBUG(
			if(Keff==null) throw "Error: ???(Keff) returned null value";
			if(Std.int(Keff.length) != (dim*(dim+1))>>>1) throw "Error: Dimensions of ???(keff) do not match constraint dimensions!";
		)
		L = solve(Keff);

		if(!stiff && !velonly) {
			var biasCoef;
			soft = soft_gamma(frequency,damping,dt,gamma,biasCoef);

			//breaking?

			outer_zn.__position(bias);
			for(i in 0...dim) bias[i] *= -dt*biasCoef;

			//clamping?
		}else {
			for(i in 0...dim) bias[i] = 0.0;
			gamma = 0.0;
			soft = 1.0;
		}

		for(i in 0...dim) jAcc[i] *= dtratio;

		return false;
	}

	var vec3:Vec3;
	public override function warmStart() {
		for(bs in bodies) {
			var b = bs.body;
			outer_zn.__impulse(jAcc, b.outer, vec3);
			vec_addeq(b.vel, vec3., b.imass);
			b.angvel += vec3.z*b.iinertia;
		}

		for(i in 0...dim) pjAcc[i] = jAcc[i];
	}

	var J:ARRAY(Float);
	var jOld:ARRAY(Float);
	public override function applyImpulseVel() {
		//velocity corrections
		outer_zn.__velocity(J);
		for(i in 0...dim) J[i] = bias[i] - J[i];

		transform(L,J);

		//combine these steps
		for(i in 0...dim) {
			jOld[i] = jAcc[i];
			jAcc[i] += (J[i] = (J[i]*soft - jAcc[i]*gamma));
		}

		//clamping
		outer_zn.__clamp(jAcc);

		for(i in 0...dim) J[i] = jAcc[i] - jOld[i];

		for(bs in bodies) {
			var b = bs.body;
			outer_zn.__impulse(J, b.outer, vec3);
			vec_addeq(b.vel, vec3., b.imass);
			b.angvel += vec3.z*b.iinertia;
		}

		return false;
	}

	public override function applyImpulsePos() {
		if(velonly) return false;

		outer_zn.__position(J);
		outer_zn.__eff_mass(true, Keff);

		for(i in 0...dim) J[i] *= -1;
		//clamping?

		transform(solve(Keff),J);

		for(bs in bodies) {
			var b = bs.body;
			outer_zn.__impulse(J, b.outer, vec3);
			vec_addeq(b.pos, vec3., b.imass);
			b.delta_rot(vec3.z*b.iinertia);
		}

		return false;
	}
}
)
