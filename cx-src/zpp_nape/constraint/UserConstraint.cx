$(import);

class PR(UserConstraint) {
	public var outer_zn:UserConstraint;
	
	public var bodies : List(PR(Body));

	public var rank : Int; //number of BODIES. actual rank = BODIES*3
	public var dim  : Int; //number of rows.

	public var  jAcc : ARRAY(Float);
	public var pjAcc : ARRAY(Float);
	public var  bias : Array(Float);

	//--------------------------------------------
	
	public var ucopy : Void -> Constraint;
	public var udest : Void -> Void; //can be null
	public var valid : Void -> Void; //can be null

	public var cerr : Void -> ARRAY(Float); //can be null (velocity constraint)
	public var verr : Void -> ARRAY(Float);
	public var keff : Void -> ARRAY(Float);
	public var clamp: ARRAY(Float) -> Void;

	public var vimp : ARRAY(Float) -> Void;
	public var pimp : ARRAY(Float) -> Void;
	public var bimp : ARRAY(Float) -> Body -> Vec3;

	//--------------------------------------------

	flibmdel public inline function bodyImpulse(b:PR(Body)) {
		var jtotal = newARRAY(Float,dim);
		for(i in 0...dim) jtotal[i] = pjAcc[i] + jAcc[i];

		if(stepped) return bimp(jtotal,b.outer);
		else return new Vec3(0,0,0);
	}

	//--------------------------------------------

	public override function activeBodies() {
		Iter(b, bodies, active_body(b));
	}
	public override function inactiveBodies() {
		Iter(b, bodies, inactive_body(b));
	}

	//-------------------------------------------

	public var stepped:Bool;

	//-------------------------------------------

	public override function copy(?dict:Array<{id:Int,bc:Body}>,?todo:Array<{id:Int,cb:Body->Void}>):Constraint {
		var ret = ucopy();
		copyto(ret);

		//copy to dictionary + todo?
		throw "not done yet";
		return ret;
	}

	public function new() {
		super();
		bodies = new List(PR(Body))();
		stepped = false;
	}

	public override function validate() {
		Iter(b, bodies, if(b.space!=space) throw "Error: Constraints must have each body within the same sapce to which the constraint has been assigned";);
		if(valid!=null) valid();
	}

	public override function wake_connected() {
		Iter(b, bodies, b.wake());
	}

	public override function forest() {
		Iter(b, bodies, DSF(union(b.component, component)));
	}

	public override function pair_exists(id:Int, di:Int) {
		var ret = false;
		Iter(b, bodies, {
			Iter(c, bodies, cx_ite.next, {
				if((b.id==id && c.id==di) || (b.id==di && c.id==id)) {
					ret = true;
					cx_break;
				}
			});
			if(ret) cx_break;
		});
		return ret;
	}

	public override function destroy() {
		inactiveBodies();
		if(udest!=null) udest();
	}

	public override function clearcache() {
		for(i in 0...dim) pjAcc[i] = jAcc[i] = 0.0;
		pre_dt = -1.0;
	}

	//-----------------------------------------------------------------------------

	public override function preStep(dt:Float) {
		if(pre_dt==-1.0) pre_dt = dt;
		var dtratio = dt/pre_dt;
		pre_dt = dt;

		stepped = true;

		//validate any anchors etc?
		throw "not done yet";

		//any positional error
		var Cerr = if(cerr!=null) cerr() else null;

		//effective mass
		var Keff = keff();
		invert(Keff);

		if(!stiff) {
		}else {
		}

		for(i in 0...dim) jAcc[i] *= dtratio;

		return false;
	}

	public override function warmStart() {
		vimp(jAcc);
		for(i in 0...dim) pjAcc[i] = jAcc[i];
	}

	public override function applyImpulseVel() {
		//velocity corrections
		var E = verr();
		var J = newARRAY(Float,dim);
		for(i in 0...dim) J[i] = bias[i] - E[i];

		transform(kMass, J);

		//combine these steps
		var jOld = newARRAY(Float,dim);
		for(i in 0...dim) {
			jOld[i] = jAcc[i];
			jAcc[i] += (J[i] -= jAcc[i]*gamma);
		}

		//clamping
		if(clamp!=null) clamp(jAcc);

		for(i in 0...dim) J[i] = jAcc[i] - jOld[i];

		vimp(J);
		return false;
	}

	public override function applyImpulsePos() {
		if(cerr==null) return false;

		var E = cerr();
		var K = keff();
		var J = newArray(Float,dim);
		for(i in 0...dim) J[i] = -E[i];

		//clamping?

		solve(K,J);

		pimp(J);

		return false;
	}
}
