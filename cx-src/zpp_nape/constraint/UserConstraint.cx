$(import);

class PR(UserConstraint) {
	public var outer_zn:UserConstraint;
	
	public var bodies : List(PR(Body));

	public var rank : Int; //number of BODIES. actual rank = BODIES*3
	public var dim  : Int; //number of rows.

	public var  jAcc : ARRAY(Float);
	public var pjAcc : ARRAY(Float);
	public var  bias : Array(Float);

	//--------------------------------------------
	
	//defined copying of constraint.
	public var ucopy : Void -> Constraint;

	//defined additional destroy logic.
	public var udest : Void -> Void; //can be null

	//defined additional validation logic.
	public var valid : Void -> Void; //can be null
	
	//positional error.
	public var cerr : Void -> ARRAY(Float); //can be null (velocity constraint)

	//velocity error.
	public var verr : Void -> ARRAY(Float);

	//effective mass.
	public var keff : Void -> ARRAY(Float);

	//defined clamping of impulses.
	public var clamp: ARRAY(Float) -> Void;

	//apply velocity impulse to all bodies.
	public var vimp : ARRAY(Float) -> Void;

	//apply positional impulse to all bodies.
	public var pimp : ARRAY(Float) -> Void; //null when cerr is null

	//determine impulse applied to particular body (veloctiy).
	public var bimp : ARRAY(Float) -> Body -> Vec3;

	//--------------------------------------------

	flibmdel public inline function bodyImpulse(b:PR(Body)) {
		var jtotal = newARRAY(Float,dim);
		for(i in 0...dim) jtotal[i] = pjAcc[i] + jAcc[i];

		if(stepped) return bimp(jtotal,b.outer);
		else return new Vec3(0,0,0);
	}

	//--------------------------------------------

	public override function activeBodies() {
		Iter(b, bodies, active_body(b));
	}
	public override function inactiveBodies() {
		Iter(b, bodies, inactive_body(b));
	}

	//-------------------------------------------

	public var stepped:Bool;

	//-------------------------------------------

	public override function copy(?dict:Array<{id:Int,bc:Body}>,?todo:Array<{id:Int,cb:Body->Void}>):Constraint {
		var ret = ucopy();
		copyto(ret);

		//copy to dictionary + todo?
		throw "not done yet";
		return ret;
	}

	public function new() {
		super();
		bodies = new List(PR(Body))();
		stepped = false;
	}

	public override function validate() {
		Iter(b, bodies, if(b.space!=space) throw "Error: Constraints must have each body within the same sapce to which the constraint has been assigned";);
	}

	public override function wake_connected() {
		Iter(b, bodies, b.wake());
	}

	public override function forest() {
		Iter(b, bodies, DSF(union(b.component, component)));
	}

	public override function pair_exists(id:Int, di:Int) {
		var ret = false;
		Iter(b, bodies, {
			Iter(c, bodies, cx_ite.next, {
				if((b.id==id && c.id==di) || (b.id==di && c.id==id)) {
					ret = true;
					cx_break;
				}
			});
			if(ret) cx_break;
		});
		return ret;
	}

	public override function destroy() {
		inactiveBodies();
		if(udest!=null) udest();
	}

	public override function clearcache() {
		for(i in 0...dim) pjAcc[i] = jAcc[i] = 0.0;
		pre_dt = -1.0;
	}

	//-----------------------------------------------------------------------------

	flibmdel public inline function invert(m:ARRAY(Float)) {

	}
	flibmdel public inline function transform(m:ARRAY(Float),x:ARRAY(Float)):ARRAY(Float) {
		var out = newARRAY(Float,dim);
		for(i in 0...dim) {
			var sum = 0.0;
			for(j in 0...dim) sum += m[j+i*dim]*x[j];
			out[i] = sum;
		}
		return out;
	}
	flibmdel public inline function solve(m:ARRAY(Float),x:ARRAY(Float)) {
		var L = newARRAY(Float,dim*dim);
		for(j in 0...dim) {
			var sum = 0.0;
			for(k in 1...j) sum += L[j*dim+k]*L[j*dim+k];
			var rec = Math.sqrt(m[j*dim+j] - sum);
			L[j*dim+j] = rec;

			rec = 1.0/rec;
			for(i in j+1...dim) {
				var sum = 0.0;
				for(k in 1...j) sum += L[i*dim+j]*L[j*dim+k];
				L[i*dim+j] = rec*(m[i*dim+j] - sum);
			}
		}

		var out = newARRAY(Float,dim);
		for(i in 0...dim) {
			var sum = x[i];
			for(k in 0...i) sum -= L[i*dim+k]*x[k];
			out[i] = sum / L[i*dim+i];
		}

		for(ix in 0...dim) {
			var i = dim-1-ix;
			var sum = out[i];
			for(k in i+1...dim) sum -= L[k*dim+i];
			x[i] = sum/L[i*dim+i];
		}
	}

	//-----------------------------------------------------------------------------

	public override function preStep(dt:Float) {
		if(pre_dt==-1.0) pre_dt = dt;
		var dtratio = dt/pre_dt;
		pre_dt = dt;

		stepped = true;

		if(valid!=null) valid();

		//any positional error
		var Cerr = if(cerr!=null) cerr() else null;

		//effective mass
		var Keff = keff();
		invert(Keff);

		if(!stiff) {
		}else {
		}

		for(i in 0...dim) jAcc[i] *= dtratio;

		return false;
	}

	public override function warmStart() {
		vimp(jAcc);
		for(i in 0...dim) pjAcc[i] = jAcc[i];
	}

	public override function applyImpulseVel() {
		//velocity corrections
		var E = verr();
		var J = newARRAY(Float,dim);
		for(i in 0...dim) J[i] = bias[i] - E[i];

		J = transform(kMass, J);

		//combine these steps
		var jOld = newARRAY(Float,dim);
		for(i in 0...dim) {
			jOld[i] = jAcc[i];
			jAcc[i] += (J[i] -= jAcc[i]*gamma);
		}

		//clamping
		if(clamp!=null) clamp(jAcc);

		for(i in 0...dim) J[i] = jAcc[i] - jOld[i];

		vimp(J);
		return false;
	}

	public override function applyImpulsePos() {
		if(cerr==null) return false;

		var E = cerr();
		var K = keff();
		var J = newArray(Float,dim);
		for(i in 0...dim) J[i] = -E[i];

		//clamping?

		solve(K,J);

		pimp(J);

		return false;
	}
}
