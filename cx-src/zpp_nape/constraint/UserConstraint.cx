$(import);

withConstraint(
class PR(UserConstraint) extends PR(Constraint) {
	public var outer_zn:UserConstraint;
	
	public var bodies : ARRAY({cnt:Int,body:PR(Body)});

	public var dim  : Int; //number of rows.

	public var  jAcc : ARRAY(Float);
	public var pjAcc : ARRAY(Float);
	public var  bias : ARRAY(Float);

	public function addBody(b:PR(Body)) {
		var match = null;
		for(x in bodies) { if(x.body==b) { match = x; break; } };

		if(match==null)
			 bodies.push({cnt:1,body:b});
		else match.cnt++;
	}

	public function remBody(b:PR(Body)) {
		var match = null;
		var i = 0; while(i<bodies.length) {
			var x = bodies[i];
			if(x.body==b) {
				x.cnt--;
				if(x.cnt==0) {
					bodies[i] = bodies[bodies.length-1];
					bodies.pop();
				}
				match=x;
				break;
			}
			i++;
		}
		match != null;
	}

	//--------------------------------------------
	
	//defined copying of constraint.
	public var ucopy : Void -> Constraint;

	//defined additional destroy logic.
	public var udest : Void -> Void; //can be null

	//defined additional validation logic.
	public var valid : Void -> Void; //can be null
	
	//positional error.
	public var cerr : Void -> ARRAY(Float); //can be null (velocity constraint)

	//velocity error.
	public var verr : Void -> ARRAY(Float);

	//effective mass.
	public var keff : Void -> ARRAY(Float);

	//defined clamping of impulses.
	public var clamp: ARRAY(Float) -> Void;

	//apply velocity impulse to all bodies.
	public var vimp : ARRAY(Float) -> Void;

	//apply positional impulse to all bodies.
	public var pimp : ARRAY(Float) -> Void; //null when cerr is null

	//determine impulse applied to particular body (veloctiy).
	public var bimp : ARRAY(Float) -> Body -> Vec3;

	//--------------------------------------------

	flibmdel public inline function bodyImpulse(b:PR(Body)) {
		DEBUG(if(bimp==null) throw "Error: Cannot evaluate bodyImpulse on UserConstraint if ???(bimp) is null";)

		var jtotal = newARRAY(Float,dim);
		for(i in 0...dim) jtotal[i] = pjAcc[i] + jAcc[i];

		if(stepped) return bimp(jtotal,b.outer);
		else return new Vec3(0,0,0);
	}

	//--------------------------------------------

	public override function activeBodies() {
		for(b in bodies) active_body(b.body);
	}
	public override function inactiveBodies() {
		for(b in bodies) inactive_body(b.body);
	}

	//-------------------------------------------

	public var gamma:Float;
	public var stepped:Bool;

	//-------------------------------------------

	public override function copy(?dict:Array<{id:Int,bc:Body}>,?todo:Array<{id:Int,cb:Body->Void}>):Constraint {
		DEBUG(if(ucopy==null) throw "Error: Cannot copy UserConstraint if ????(ucopy) is null";)

		var ret = ucopy();
		copyto(ret);

		//copy to dictionary + todo?
		throw "not done yet";
		return ret;
	}

	public function new(dim:Int) {
		super();

		bodies = newARRAY({cnt:Int,body:PR(Body)});

		this.dim = dim;
		jAcc = newARRAY(Float,dim);
		pjAcc = newARRAY(Float,dim);
		bias = newARRAY(Float,dim);

		L = newARRAY(Float,dim*dim);
		J = newARRAY(Float,dim);
		jOld = newARRAY(Float,dim);
		y = newARRAY(Float,dim);

		stepped = false;
	}

	public override function validate() {
		for(b in bodies) if(b.body.space!=space) throw "Error: Constraints must have each body within the same sapce to which the constraint has been assigned";

		if((cerr!=null)&&(pimp==null)) throw "Error: UserConstraint cannot have ???(pimp) null if ???(cerr) is not null";
		if(verr==null) throw "Error: UserConstraint cannot have ???(verr) null";
		if(keff==null) throw "Error: UserConstraint cannot have ???(keff) null";
		if(vimp==null) throw "Error: UserConstraint cannot have ???(vimp) null";
	}

	public override function wake_connected() {
		for(b in bodies) b.body.wake();
	}

	public override function forest() {
		for(b in bodies) DSF(union(b.body.component, component));
	}

	public override function pair_exists(id:Int, di:Int) {
		var ret = false;
		for(bi in 0...bodies.length) {
			var b = bodies[bi].body;
			for(ci in bi+1...bodies.length) {
				var c = bodies[ci].body;
				if((b.id==id && c.id==di) || (b.id==di && c.id==id)) {
					ret = true;
					break;
				}
			}
			if(ret) break;
		}
		return ret;
	}

	public override function destroy() {
		inactiveBodies();
		if(udest!=null) udest();
	}

	public override function clearcache() {
		for(i in 0...dim) pjAcc[i] = jAcc[i] = 0.0;
		pre_dt = -1.0;
	}

	//-----------------------------------------------------------------------------

	var L:ARRAY(Float);
	flibmdel public inline function solve(m:ARRAY(Float)) {
		for(j in 0...dim) {
			var sum = 0.0;
			for(k in 1...j) sum += L[j*dim+k]*L[j*dim+k];
			var rec = Math.sqrt(m[j*dim+j] - sum);
			L[j*dim+j] = rec;

			rec = 1.0/rec;
			for(i in j+1...dim) {
				var sum = 0.0;
				for(k in 1...j) sum += L[i*dim+j]*L[j*dim+k];
				L[i*dim+j] = rec*(m[i*dim+j] - sum);
			}
		}
		return L;
	}

	var y:ARRAY(Float);
	flibmdel public inline function transform(L:ARRAY(Float),x:ARRAY(Float)) {
		for(i in 0...dim) {
			var sum = x[i];
			for(k in 0...i) sum -= L[i*dim+k]*x[k];
			y[i] = sum / L[i*dim+i];
		}

		for(ix in 0...dim) {
			var i = dim-1-ix;
			var sum = y[i];
			for(k in i+1...dim) sum -= L[k*dim+i]*y[k];
			x[i] = sum/L[i*dim+i];
		}
	}

	//-----------------------------------------------------------------------------

	public override function preStep(dt:Float) {
		if(pre_dt==-1.0) pre_dt = dt;
		var dtratio = dt/pre_dt;
		pre_dt = dt;

		stepped = true;

		if(valid!=null) valid();

		//any positional error
		var Cerr = if(cerr!=null) cerr() else null;
		DEBUG(
			if(cerr!=null && Cerr==null) throw "Error: ???(cerr) non-null, but returned null value";
			if(Cerr!=null) {
				if(Cerr.length != dim) throw "Error: Dimensions of ???(cerr) do not match constraint dimensions!";
			}
		)

		//effective mass
		var Keff = keff();
		DEBUG(
			if(Keff==null) throw "Error: ???(Keff) returned null value";
			if(Keff.length != dim*dim) throw "Error: Dimensions of ???(keff) do not match constraint dimensions!";
		)
		L = solve(Keff);

		if(!stiff) {
		}else {
		}

		for(i in 0...dim) jAcc[i] *= dtratio;

		return false;
	}

	public override function warmStart() {
		vimp(jAcc);
		for(i in 0...dim) pjAcc[i] = jAcc[i];
	}

	var J:ARRAY(Float);
	var jOld:ARRAY(Float);
	public override function applyImpulseVel() {
		//velocity corrections
		var E = verr();
		DEBUG(
			if(E==null) throw "Error: ???(verr) returned null value";
			if(E.length!=dim) throw "Error: Dimensions of ???(verr) do not match constraint dimensions!";
		)
		for(i in 0...dim) J[i] = bias[i] - E[i];

		transform(L,J);

		//combine these steps
		for(i in 0...dim) {
			jOld[i] = jAcc[i];
			jAcc[i] += (J[i] -= jAcc[i]*gamma);
		}

		//clamping
		if(clamp!=null) clamp(jAcc);

		for(i in 0...dim) J[i] = jAcc[i] - jOld[i];

		vimp(J);
		return false;
	}

	public override function applyImpulsePos() {
		if(cerr==null) return false;

		var E = cerr();
		var K = keff();
		DEBUG(
			if(E==null) throw "Error: ???(cerr) returned null value";
			if(E.length != dim) throw "Error: Dimensions of ???(cerr) do not match constraint dimensions!";

			if(K==null) throw "Error: ???(Keff) returned null value";
			if(K.length != dim*dim) throw "Error: Dimensions of ???(keff) do not match constraint dimensions!";
		)

		for(i in 0...dim) J[i] = -E[i];

		//clamping?

		transform(solve(K),J);

		pimp(J);

		return false;
	}
}
)
