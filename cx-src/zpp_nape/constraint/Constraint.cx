package zpp_nape.constraint;
$(import);

GENID(Constraint)
class PR(Constraint) {
	public var outer:Constraint;

	flibmdel public inline function clear() {}

    public var id:Int;

	public var compound:PR(Compound);

	//assigned space
	public var space:PR(Space);
	
	//whether to ignore (disable) constraint without removing it from space.
	public var active:Bool;
	
	//softness parameters + switch
	public var stiff:Bool;
	public var frequency:Float;
	public var damping:Float;
	
	//clamping/breaking
	public var maxForce:Float;
	public var maxError:Float;
	public var breakUnderForce:Bool;
	public var breakUnderError:Bool;

    public var removeOnBreak:Bool; //if true, constraint is removed when broken rather than disabled.
	
	public var component:PR(Component);
	
	//ignore collisions between bodies
	public var ignore:Bool;

    //velocity only constraints
    public var __velocity:Bool;
	
	public function new() {
	    __velocity = false;
	    
        id = ID(Constraint);

		stiff = true;
		active = true;
		ignore = false;
		frequency = 10;
		damping = 1;
		maxForce = PR(Const).POSINF;
		maxError = PR(Const).POSINF;
		breakUnderForce = false;
		
        removeOnBreak = true;
        pre_dt = -1.0;
	}

	//------------------------------------------------------------------------------------

	flibmdel public inline function immutable_midstep(name:String) {
		DEBUG(if(space!=null && space.midstep)
			throw "Error: Constraint::"+name+" cannot be set during space step()";
		)
	}

    public function setCbType(cbType:PR(CbType)) {
        if(this.cbType != cbType) {
			if(space!=null && active && this.cbType!=null)
	            this.cbType.remConstraint(this);
			
            this.cbType = cbType;
			if(space!=null && active && cbType!=null)
	            cbType.addConstraint(this);

            wake();
        }
    }
	
	//------------------------------------------------------------------------------------

	flibmdel public inline function activate() {
		if(space!=null) activeInSpace();
	}
	flibmdel public inline function deactivate() {
		if(space!=null) inactiveOrOutSpace();
	}

	flibmdel public inline function addedToSpace() {
		if(active) activeInSpace();
	}
	flibmdel public inline function removedFromSpace() {
		if(active) inactiveOrOutSpace();
	}

	//------------------------------------------------------------------------------------

	flibmdel public inline function activeInSpace() {
		if(cbType!=null)
			cbType.addConstraint(this);
		
		assert(component==null,"already has a component?");
		component = Get(PR(Component));
		component.isBody = false;
		component.constraint = this;

		//do body lists
		activeBodies();
	}

	flibmdel public inline function inactiveOrOutSpace() {
		if(cbType!=null)
			cbType.remConstraint(this);

		Free(PR(Component),component);
		component = null;

		//do body lists
		inactiveBodies();
	}

	//------------------------------------------------------------------------------------

	//update body constraint lists.
	keep public function   activeBodies() { assert(false,  "activeBodies not overriden"); }
	keep public function inactiveBodies() { assert(false,"inactiveBodies not overriden"); }

	//------------------------------------------------------------------------------------

    //clear cached impulses
    keep public function clearcache() { assert(false,"clearcache not overriden"); }

	//validate constraint assignments
	keep public function validate() { assert(false,"validate not overriden"); }
	
	//wake connected bodies
	keep public function wake_connected() { assert(false,"wake_connected not overriden"); }
	
	//propogate constraint links to invasive disjoint set forest
	keep public function forest() { assert(false,"forest not overriden"); }
	
	//check body pair exists for ignoring.
	keep public function pair_exists(id:Int,di:Int) {
        assert(false,"pair_exists not overriden");
        return false;
    }
	
	//called to destroy constraint
	keep public function destroy() { assert(false,"destroy not overriden"); }
	
    keep public function warmStart() { assert(false,"warmStart not overriden"); }

    public var pre_dt:Float;
	keep public function preStep(dt:Float):Bool {
        assert(false,"preStep not overriden");
        return false;
    }
	keep public function applyImpulseVel() {
        assert(false,"applyImpulseVel not overriden");
        return false;
    }
	keep public function applyImpulsePos() {
        assert(false,"applyImpulsePos not overriden");
        return false;
    }
	
	flibmdel public inline function wake() {
		if(space!=null)
			space.wake_constraint(this);
	}

	//----------------------------------------------------------------------------------------------

    public var cbType:PR(CbType);

	//extra funky fields used in copying Compounds
	//so as to be able to resolve any dangling references external to the Compound.
	public function copy(?dict:Array<{id:Int,bc:Body}>,?todo:Array<{id:Int, cb:Body->Void}>):Constraint { return null; }

	public function copyto(ret:Constraint) {
		var me = outer;
		ret.cbType = me.cbType;
		ret.removeOnBreak = me.removeOnBreak;
		ret.breakUnderError = me.breakUnderError;
		ret.breakUnderForce = me.breakUnderForce;
		ret.maxError = me.maxError;
		ret.maxForce = me.maxForce;
		ret.damping = me.damping;
		ret.frequency = me.frequency;
		ret.stiff = me.stiff;
		ret.ignore = me.ignore;
		ret.active = me.active;
	}
}

$(mixin global withConstraint(block)

	//assume dict/todo exist
	$(mixin copybody(to,body,dict,todo) {
		if(dict!=null && body!=null) {
			assert(todo!=null,"dict non-null,but todo is in constraint copy?");
			var b:Body = null;
			for(idc in dict) {
				if(idc.id == body.id) {
					b = idc.bc;
					break;
				}
			}
			if(b!=null) to.body = b.pr(inner);
			else todo.push({id:body.id, cb:function(b:Body) to.body=b.pr(inner)});
		}
	});
	
	$(mixin anchor_init(n) {
		vec_set(n`local,0,0);
		vec_set(n`rel,0,0);
	});

	$(mixin anchor_new(n) anchor_new(n,$(->)));
	$(mixin anchor_new(n,extra)
		vec_new(public,n`local);
		vec_new(public,n`rel);
		
		public function setup_`n() {
			var me = this;
			wrap_`n = Vec2.get(n`localx,n`localy);
			wrap_`n.pr(inner).inuse = true;
			wrap_`n.pr(inner)._validate = function() {
				vec_set(me.wrap_`n.pr(inner).,me.n`local);
			}
			wrap_`n.pr(inner)._invalidate = function(x:PR(Vec2)) {
				me.immutable_midstep("Constraint::"+$str(n));
				vec_set(me.n`local,x.);
				extra
				me.wake();
			}
		}
		public var wrap_`n:Vec2
	);
	
	$(mixin wrap_anchor_new(N,n)
        property(N,Vec2,{
            if(pr(inner_zn).wrap_`n==null) pr(inner_zn).setup_`n();
			pr(inner_zn).wrap_`n;
        },{
			Disposed(N,Vec2);
            DEBUG(if(N==null) throw "Error: Constraint::"+$str(N)+" cannot be null";)
			this.N.set(N);
        })
	);
	
	$(mixin validate_anchor(b,n) vec_rotate(n`local,b.axis,n`rel));
	
	//-----------------------------------------------------------
	
	$(mixin wrap_body_new(B,b, new)
        property(B,Body,if(pr(inner_zn).b==null) null else pr(inner_zn).b.outer,{
			pr(inner).immutable_midstep("Constraint::"+$str(B));
			var in`B = if(B==null) null else B.pr(inner);
			if(in`B != pr(inner_zn).b) {
				if(pr(inner_zn).b != null) {
                    if(active && space!=null && new(pr(inner_zn).b)) {
						inactive_body(pr(inner_zn).b, this.pr(inner));
					}

                    if(active && space!=null)
                        pr(inner_zn).b.wake(); //wake old object!
				}
				pr(inner_zn).b = in`B;
				if(active && space!=null && in`B != null && new(in`B)) {
					active_body(in`B,this.pr(inner));
				}

				//must wake both.
				//it's possible that constraint is woken, but the newly assigned body is not.
				//equally it's possible constraint is not woken, but the newly assigned body is!
				pr(inner).wake();
				if(in`B!=null) in`B.wake();
			}
		})
	);

	$(mixin active_body(b) active_body(b,this));
	$(mixin active_body(b,this) {
		if(b!=null) b.constraints.add(this);
	});

	$(mixin inactive_body(b) inactive_body(b,this));
	$(mixin inactive_body(b,this) {
		if(b!=null) b.constraints.remove(this);
	});
	
	//-----------------------------------------------------------
	
	//return value is scaling for mass.
	//                 {--- in ---}  {---- out ----}
	$(mixin soft_gamma(freq,damping,dt, gamma,biasCoef) {
		var omega = 2*Math.PI*freq;
		gamma = 1/(omega*dt*(2*damping+omega*dt));
		var ig = 1/(1+gamma);
		
		biasCoef = omega*omega*gamma;
		gamma *= ig;
		ig;
	});
	
	//-----------------------------------------------------------
	
	$(mixin accum(jAcc,j, constraint) {
	    assert(!assert_isNaN(j),"accum nan");
		var jOld = jAcc;
		jAcc += j;
		constraint;
		j = jAcc-jOld;
	});
	$(mixin accum2(jAcc,j, constraint) {
		vec_new(jOld); vec_set(jOld,jAcc);
		vec_addeq(jAcc,j);
		constraint;
		vec_sub(jAcc,jOld,j);
	});
	$(mixin accum3(jAcc,j, constraint) {
		vec3_new(jOld); vec3_set(jOld,jAcc);
		vec3_addeq(jAcc,j);
		constraint;
		vec3_sub(jAcc,jOld,j);
	});
	
	//-----------------------------------------------------------
	
	$(mixin bias_xform(body,loc,rel) {
		vec_rotate(loc,body.axis,rel);
	});
	$(mixin bias_xform(body,loc,rel,glob) {
		bias_xform(body,loc,rel);
		vec_add(body.pos,rel,glob);
	});

	block
);
