package zpp_nape.space;
$(import);

class PR(Island) {
	MixPoolNoNext(PR(Island))
	MixListMixin(PR(Island))
	
	public var comps:List(PR(Component));
	public var sleep:Bool;
	public var waket:Int;
	
	flibmdel public inline function free() {
		waket = 0;
	}
	flibmdel public inline function alloc() {}
	public function new() {
		comps = new List(PR(Component))();
		waket = 0;
	}
}

class PR(Component) {
	MixPool(PR(Component))
	DSF(Mixin(PR(Component)));
	
	public var isBody:Bool;
	public var body:PR(Body);
	public var constraint:PR(Constraint);
	
	public var island:PR(Island);
	public var sleeping:Bool;
    public var waket:Int;
    public var woken:Bool;

	flibmdel public inline function free() {
		body = null;
		constraint = null;
		assert(island==null,"component freeed whilst connected to an island?");
	}
	flibmdel public inline function alloc() {}

	public function new() {
        reset();
        woken = false;
    }

	flibmdel public inline function reset() {
		sleeping = false;
		island = null;
		parent = this;
		rank = 0;
	}
}

class PR(CallbackSet) {
	//for hash
	public var hnext:PR(CallbackSet);
	public var id:Int; public var di:Int;

	public static inline function get(id:Int,di:Int) {
		var ret = Get(PR(CallbackSet));
		if(id<=di) { ret.id = id; ret.di = di; }
		else       { ret.id = di; ret.di = id; }
		return ret;
	}

	//can use a hash here and it naturally fits.
	//but for the size of the arbiter sets
	//it seems a waste of memory and would be sub-optimal
	public var arbiters:List(PR(Arbiter));

	//kept here so that any new arbiters can have the correct
	//state set, even retained after a listener no longer exists
	public var state:Int;

	//time stamp :)
	public var stamp:Int;

	MixPool(PR(CallbackSet))
	flibmdel public inline function free() {
		assert(arbiters.empty(),"callbackset released with lingering arbs");
	}
	flibmdel public inline function alloc() {
		state = Flag(PreFlag,ACCEPT);
		stamp = 0;
	}

	public function new() {
		arbiters = new List(PR(Arbiter))();
	}

	//-------------

	flibmdel public inline function add(x:PR(Arbiter)) {
		if(!arbiters.has(x))
			arbiters.add(x);
	}
	flibmdel public inline function remove(x:PR(Arbiter)) arbiters.remove(x)
	flibmdel public inline function empty() return arbiters.empty()
}

class PR(Space) {
	public var outer:Space;
	
	vec_new(public,gravity); public var wrap_gravity:Vec2;
	public function getgravity() {
		var me = this;
		wrap_gravity = Vec2.get(gravityx,gravityy);
		wrap_gravity.pr(inner).inuse = true;
		wrap_gravity.pr(inner)._invalidate = function(x:PR(Vec2)) {
			DEBUG(if(me.midstep) throw "Error: Space::gravity cannot be set during space step";)
			vec_set(me.gravity,x.);
			Iter(b, me.dynamics, {
				me.wake(b);
			});
		}
		wrap_gravity.pr(inner)._validate = function() {
			vec_set(me.wrap_gravity.pr(inner).,me.gravity);
		}
	}
	
	//----------------------------------------------------------------------------------------------

	//these model the public lists with the Space acting much like a Compound
	public var pubbodies :List(PR(Body));     public var wrap_bodies   :BodyList;
	public var compounds :List(PR(Compound)); public var wrap_compounds:CompoundList;
	public var pubconstraints:List(PR(Constraint)); public var wrap_constraints:ConstraintList;

	//these 4 lists (internally) store 'every' body of that type / constraint in the space
	public var statics   :List(PR(Body));
	public var dynamics  :List(PR(Body));
	public var kinematics:List(PR(Body));	
	public var constraints:List(PR(Constraint));
	
	public var bphase:PR(Broadphase);
	
	public var __static:Body; //for constraint use.
	
	//----------------------------------------------------------------------------------------------
	
	public var stamp:Int;
    public var midstep:Bool;
    public var time:Float;
	
	//----------------------------------------------------------------------------------------------
	
	$(define global public var c_arbiters(stat):List(PR(ColArbiter)););
	public var f_arbiters:List(PR(FluidArbiter));
	public var s_arbiters:List(PR(SensorArbiter));

	public var map_arb:FastHash2(PR(Arbiter));
	public var wrap_arbiters:ArbiterList;
	
	//----------------------------------------------------------------------------------------------
	
	public var live:List(PR(Body)); //live subset of dynamics.
	public var wrap_live:BodyList;
	
	public var live_constraints:List(PR(Constraint)); //live subset of constraints
	public var wrap_livecon:ConstraintList;
	
	//list of static/kinematics that need to be put to sleep after the next call to space.step()
	public var staticsleep:List(PR(Body));
	
	//used by forest method
	public var islands:MixList(PR(Island));

    //----------------------------------------------------------------------------------------------

    public var listeners:List(PR(Listener));
    public var wrap_listeners:ListenerList;

	//cbtype stores number of active listeneres utilising the cbtype for the particular event type
	//but this is not enoguh to determine that such a listener exists.
	//
	//these hashes are indexed by the two associated cbtype id's
	//to provide a quick lookup on any existing listener given that cbtype_1.event > 0 && cbtype_2.event > 0
	public var _begin:FastHash2(PR(InteractionListener));
	public var _end  :FastHash2(PR(InteractionListener));
	public var _pre  :FastHash2(PR(PreListener));

    public var callbacks:PR(Callback); //as a deque
    public var wrap_callbacks:CallbackQueue;

	//used in callbackset callbacks to keep track of arbiter counts for unique begin/end/pre
	public var callbacksets:FastHash2(PR(CallbackSet));
	
	//----------------------------------------------------------------------------------------------

	public function clear() {
		callbacks.clear();
		ClearWith(c, listeners, remListener(c));

		///clear internal lists to object pools if applicable
		//arbiters
		ClearWith(arb, c_arbiters(true),  arb.retire());
		ClearWith(arb, c_arbiters(false), arb.retire());
		ClearWith(arb, s_arbiters,        arb.retire());
		ClearWith(arb, f_arbiters,        arb.retire());
		map_arb.clear();

		//broadphase
		bphase.clear();

		//islands
		assert(islands.empty(),"islands exist... wuh?");

		//handle islands that exist implicitly through components.
		$(mixin isl(comp) {
			if(comp!=null) {
				var i = comp.island;
				if(i!=null) {
					ClearWith(c,i.comps,c.reset());
					Free(PR(Island),i);
				}
			}
		});

		//clear user lists
/*		ClearWith(b, bodies,     { isl(b.component); b.removedFromSpace(); b.space = null; });
		statics.clear();
		dynamics.clear();
		kinematics.clear();

		ClearWith(c, constraints, { isl(c.component); c.removedFromSpace(); c.space = null; });*/
		throw "not working yet (compound changes)"; //TODO

		//other
		staticsleep.clear();
		live.clear();
		live_constraints.clear();

		//nearly forgot these
		stamp = 0;
		time = 0.0;
		vec_set(gravity,0,0);
		#if NAPE_TIMES
			Debug.FOR = Debug.BROAD = Debug.PRE = Debug.POS = Debug.VEL = Debug.DRAW = 0;
			Debug.ltime = 0;
		#end
	}

	//----------------------------------------------------------------------------------------------
	
	public function new(gravity:PR(Vec2),broadphase:Broadphase) {
		pre_dt = 0.0;

		if(broadphase==null || broadphase==Broadphase.DYNAMIC_AABB_TREE)
			bphase = new PR(DynAABBPhase)(this);
		elif(broadphase==Broadphase.SWEEP_AND_PRUNE)
			bphase = new PR(SweepPhase)(this);

        time = 0.0;
		var me = this;
		
		if(gravity!=null) vec_set(this.gravity,gravity.);
		else vec_set(this.gravity,0,0);
	
		pubbodies = new List(PR(Body))();	
		wrap_bodies = PR(BodyList).get(pubbodies);
		wrap_bodies.pr(inner).adder = function(x:Body) {
			if(x.pr(inner).space!=me) {
				if(x.pr(inner).space!=null) x.pr(inner).space.outer.bodies.remove(x);
				me.addBody(x.pr(inner));
				return true;
			}else return false;
		};
		wrap_bodies.pr(inner).subber = function(x:Body) {
			me.remBody(x.pr(inner));
		};
		DEBUG(wrap_bodies.pr(inner)._modifiable = function() {
			if(me.midstep) throw "Error: Space::bodies cannot be set during space step()";
		})

		compounds = new List(PR(Compound))();
		wrap_compounds = PR(CompoundList).get(compounds);
		wrap_compounds.pr(inner).adder = function(x:Compound) {
			if(x.pr(inner).space!=me) {
				if(x.pr(inner).space!=null) x.pr(inner).space.wrap_compounds.remove(x);
				me.addCompound(x.pr(inner));
				return true;
			}else return false;
		}
		wrap_compounds.pr(inner).subber = function(x:Compound) {
			me.remCompound(x.pr(inner));
		}
		DEBUG(wrap_compounds.pr(inner)._modifiable = function() {
			if(me.midstep) throw "Error: Space::compounds cannot be set during space step()";
		})

		statics = new List(PR(Body))();
		dynamics = new List(PR(Body))();
		kinematics = new List(PR(Body))();
		constraints = new List(PR(Constraint))();
		
		c_arbiters(true) = new List(PR(ColArbiter))();
		c_arbiters(false) = new List(PR(ColArbiter))();
		f_arbiters = new List(PR(FluidArbiter))();
		s_arbiters = new List(PR(SensorArbiter))();
		
		map_arb = new FastHash2(PR(Arbiter))();
		
		islands = new MixList(PR(Island))();
		
		live = new List(PR(Body))();
		wrap_live = PR(BodyList).get(live,true);
		
		staticsleep = new List(PR(Body))();
		
		pubconstraints = new List(PR(Constraint))();
		wrap_constraints = PR(ConstraintList).get(pubconstraints);
		wrap_constraints.pr(inner).adder = function(x:Constraint) {
			if(x.pr(inner).space!=me) {
				if(x.pr(inner).space!=null) x.pr(inner).space.outer.constraints.remove(x);
				me.addConstraint(x.pr(inner));
				return true;
			}else return false;
		};
		wrap_constraints.pr(inner).subber = function(x:Constraint) {
			me.remConstraint(x.pr(inner));
		};
		DEBUG(wrap_constraints.pr(inner)._modifiable = function() {
			if(me.midstep) throw "Error: Space::constraints cannot be set during space step()";
		})
		
		live_constraints = new List(PR(Constraint))();
		wrap_livecon = PR(ConstraintList).get(live_constraints,true);
		
		__static = PR(Body).__static();
		__static.pr(inner).space = this;

        callbacks = new PR(Callback)(); //as a deque
        midstep = false;

        listeners = new List(PR(Listener))();
        wrap_listeners = PR(ListenerList).get(listeners);
        wrap_listeners.pr(inner).adder = function(x:Listener) {
            if(x.pr(inner).space!=me) {
                if(x.pr(inner).space!=null) x.pr(inner).space.outer.listeners.remove(x);
                me.addListener(x.pr(inner));
                return true;
            }else return false;
        };
        wrap_listeners.pr(inner).subber = function(x:Listener) {
            me.remListener(x.pr(inner));
        };
		DEBUG(wrap_listeners.pr(inner)._modifiable = function() {
			if(me.midstep) throw "Error: Space::listeners cannot be set during space step()";
		})

		_begin = new FastHash2(PR(InteractionListener))();
		_end   = new FastHash2(PR(InteractionListener))();
		_pre   = new FastHash2(PR(PreListener))();

		callbacksets = new FastHash2(PR(CallbackSet))();
	}
	
	//----------------------------------------------------------------------------------------------

	public function revoke_listener(x:PR(Listener)) {
		if(x.type==Flag(ListenerType,INTERACTION)) {
			var hash = if(x.event==Flag(CbEvent,BEGIN)) _begin else _end;
			var it = x.interaction;
			assert(hash.has(it.id,it.di), "hash doesn't have listener");
			hash.remove(it);
		}else {
			var hash = _pre;
			var it = x.imm;
			assert(hash.has(it.id,it.di), "hash doesn't have listener");
			hash.remove(it);
		}
	}
	public function unrevoke_listener(x:PR(Listener)) {
		if(x.type==Flag(ListenerType,INTERACTION)) {
			var hash = if(x.event==Flag(CbEvent,BEGIN)) _begin else _end;
			var it = x.interaction;
			DEBUG(if(hash.has(it.id,it.di))
				throw "Error: Space already contains a listener between CbType id's: "+it.id+"<->"+it.di+" for CbEvent "+x.outer.event.toString();
			)
			hash.add(it);
		}else {
			var hash = _pre; 
			var it = x.imm;
			DEBUG(if(hash.has(it.id,it.di))
				throw "Error: Space already contains a listener between CbType id's: "+it.id+"<->"+it.di+" for CbEvent "+x.outer.event.toString();
			)
			hash.add(it);
		}
	}

    public function addListener(x:PR(Listener)) {
        x.space = this;
        if(x.type==Flag(ListenerType,BODY))
            x.body.addedToSpace();
        else if(x.type==Flag(ListenerType,CONSTRAINT))
            x.constraint.addedToSpace();
		else if(x.type==Flag(ListenerType,INTERACTION)) {
			unrevoke_listener(x);
			x.interaction.addedToSpace();
		}else {
			unrevoke_listener(x);
			x.imm.addedToSpace();
		}
    }
    public function remListener(x:PR(Listener)) {
        if(x.type==Flag(ListenerType,BODY))
            x.body.removedFromSpace();
        else if(x.type==Flag(ListenerType,CONSTRAINT))
            x.constraint.removedFromSpace();
		else if(x.type==Flag(ListenerType,INTERACTION)) {
			revoke_listener(x);
			x.interaction.removedFromSpace();
		}else {
			revoke_listener(x);
			x.imm.removedFromSpace();
		}
        x.space = null;
    }

    //----------------------------------------------------------------------------------------------

	//called when Body has it's type changed.
	public function transmitType(p:PR(Body),new_type:Int) {
		//wake object
		wake(p);
		
		if     (p.type == Flag(BodyType,DYNAMIC))   { dynamics.remove(p);   live.remove(p);        }
		else if(p.type == Flag(BodyType,KINEMATIC)) { kinematics.remove(p); staticsleep.remove(p); }
		else if(p.type == Flag(BodyType,STATIC))    { statics.remove(p);    staticsleep.remove(p); }
		
		p.type = new_type;
		
		if     (p.type == Flag(BodyType,DYNAMIC))   dynamics.add(p);
		else if(p.type == Flag(BodyType,KINEMATIC)) kinematics.add(p);
		else if(p.type == Flag(BodyType,STATIC))    statics.add(p);
		
		if(p.type == Flag(BodyType,STATIC)) static_validation(p);
		
		//wake again, as new type of body
		p.component.sleeping = true; wake(p,true);
	}
	
	public function added_shape(s:PR(Shape)) {
		//wake the object
		wake(s.body);
		bphase.insert(s);

		s.addedToSpace();
	}
	public function removed_shape(s:PR(Shape), ?deleting=false) {
		var body = s.body;
		
		//if object is in the course of being deleted, don't want to wake it!
		if(!deleting) {
			//wake object first!
			body.wake();
		}
		
		var pre = null;
		Iter(xarb,body.arbiters,{
			var rem = xarb.ws1 == s || xarb.ws2 == s;
			if(rem) {
				//need to deal with callbackset callback counters!!!
				//
				//this handles shapes/bodies being removed
				//we only generate end callbacks when body is not being deleted
				//and we only care for callbackset callbacks as shape-shape are dealt
				//with automaticaly and simply.
				//
				//we decrement on both begin/end callback existance also pre.
				//as in either case the callbackset exists and must be cleaned
				$(mixin docbs(S1,S2,o1,o2) {
					var cb1 = o1.cbType;
					var cb2 = o2.cbType;
					if(cb1!=null && cb2!=null) {
						var endcb = null;
						var exists = false;
						if(cb1._end>0 && cb2._end>0) {
							endcb = _end.ordered_get(cb1.id,cb2.id);
							exists = endcb!=null;
						}
						if(!exists && cb1._begin>0 && cb2._begin>0)
							exists = _begin.ordered_get(cb1.id,cb2.id) != null;
						if(!exists && cb1._pre>0 && cb2._pre>0)
							exists = _pre.ordered_get(cb1.id,cb2.id) != null;

						if(exists) {
							var callbackset = callbacksets.ordered_get(o1.id,o2.id);
							assert(callbackset!=null,"null callbackset on arbiter deletion?");
							callbackset.remove(xarb);
							if(callbackset.empty()) {
								if(endcb!=null && !deleting) {
									var cb = push_callback(endcb,endcb.handler!=null);
									cb.event = Flag(CbEvent,END);
									PR(Interactor).int_callback(o1,o2,endcb.cb1,cb);
								}
								callbacksets.remove(callbackset);
								Free(PR(CallbackSet),callbackset);
							}
						}
					}
				});
				if(xarb.active) {
					docbs(true,false,xarb.ws1,xarb.ws2.body);
					docbs(false,true,xarb.ws1.body,xarb.ws2);
					docbs(false,false,xarb.ws1.body,xarb.ws2.body);
				}

				//wake connected first.
				if(xarb.b1 != body && xarb.b1.isDynamic()) wake(xarb.b1);
				if(xarb.b2 != body && xarb.b2.isDynamic()) wake(xarb.b2);
				
				xarb.lazyRetire(this,body);
				cx_ite = body.arbiters.erase(pre);
				continue;
			}
			
			pre = cx_ite;
		});
		
		bphase.remove(s);

		s.removedFromSpace();
	}
	
	//----------------------------------------------------------------------------------------------
	
	public function addConstraint(con:PR(Constraint)) {
		constraints.add(con);
		con.space = this;
		con.addedToSpace();
		if(con.active) {
            assert(con.component.island==null,"newly added constraint has an island??");
			con.component.sleeping = true;
			wake_constraint(con,true);
		}
	}
	
	public function remConstraint(con:PR(Constraint)) {
		constraints.remove(con);
		if(con.active) {
			wake_constraint(con,true);
			live_constraints.remove(con);
		}
		con.removedFromSpace();
		con.space = null;
	}
	
	//----------------------------------------------------------------------------------------------

	//simple batching
	public function addCompound(x:PR(Compound)) {
		x.space = this;
		Iterate(x.bodies,      addBody);
		Iterate(x.constraints, addConstraint);
		Iterate(x.compounds,   addCompound);
	}
	public function remCompound(x:PR(Compound)) {
		x.space = null;
		Iterate(x.bodies,      remBody);
		Iterate(x.constraints, remConstraint);
		Iterate(x.compounds,   remCompound);
	}

	//----------------------------------------------------------------------------------------------
	
	//flag = 0 if already added to bodies list, -1 if nothing has yet been done
	public function addBody(body:PR(Body),?flag:Int=-1) {
		body.space = this;

		body.addedToSpace();

        assert(body.component.island==null,"newly added body has an island??");
		body.component.sleeping = true;
        wake(body,true);
			
		Iter(shape,body.shapes,added_shape(shape));
			
		if(body.isStatic()) {
			//validation won't be done on statics later.
			static_validation(body);

			if(flag!=Flag(BodyType,STATIC)) statics.add(body);

			assert(staticsleep.has(body),"a2b f="+flag);
		}else {
			if(body.isDynamic()) {
				if(flag!=Flag(BodyType,DYNAMIC)) dynamics.add(body);

				assert(live.has(body),"a4b f="+flag);
			}else {
				if(flag!=Flag(BodyType,KINEMATIC)) kinematics.add(body);

				assert(staticsleep.has(body),"a6b f="+flag);
			}
		}
	}
	
	//----------------------------------------------------------------------------------------------
	
	//flag = 0 if already removed from bodies list, -1 if nothing has yet been done
	public function remBody(body:PR(Body),?flag:Int=-1) {
		if(body.isStatic()) {
			assert(statics.has(body),"neither? stat="+statics.has(body));

			if(flag!=Flag(BodyType,STATIC)) statics.remove(body);
			
			wake(body,true);

			assert(!body.component.sleeping,"as3");
			assert(staticsleep.has(body),"as4");

			staticsleep.remove(body);

			assert(!staticsleep.has(body),"e1");
		}else {
			if(body.isDynamic()) {
				if(flag!=Flag(BodyType,DYNAMIC)) dynamics.remove(body);
				
				wake(body,true);
				live.remove(body);
				assert(!live.has(body),"e3b");
			}else {
				if(flag!=Flag(BodyType,KINEMATIC)) kinematics.remove(body);
				
				wake(body,true);
				staticsleep.remove(body);
				assert(!staticsleep.has(body),"e4");
			}
		}
		Iter(shape,body.shapes,removed_shape(shape,true));
		
		body.removedFromSpace();
		body.space = null;
	}
	
	//----------------------------------------------------------------------------------------------

	flibmdel public inline function shapesUnderPoint(x:Float,y:Float,filter:PR(InteractionFilter)) {
		return bphase.shapesUnderPoint(x,y,filter);
	}
	flibmdel public inline function bodiesUnderPoint(x:Float,y:Float,filter:PR(InteractionFilter)) {
		return bphase.bodiesUnderPoint(x,y,filter);
	}
	
	flibmdel public inline function shapesInAABB(aabb:AABB,strict:Bool,cont:Bool,filter:PR(InteractionFilter)) {
		return bphase.shapesInAABB(aabb.pr(inner),strict,cont,filter);
	}
	flibmdel public inline function bodiesInAABB(aabb:AABB,strict:Bool,cont:Bool,filter:PR(InteractionFilter)) {
   		return bphase.bodiesInAABB(aabb.pr(inner),strict,cont,filter);
	}
	
	flibmdel public inline function shapesInCircle(pos:Vec2,rad:Float,cont:Bool,filter:PR(InteractionFilter)) {
		return bphase.shapesInCircle(pos.x,pos.y,rad,cont,filter);
	}
	flibmdel public inline function bodiesInCircle(pos:Vec2,rad:Float,cont:Bool,filter:PR(InteractionFilter)) {
   		return bphase.bodiesInCircle(pos.x,pos.y,rad,cont,filter);
	}

	flibmdel public inline function shapesInShape(shape:PR(Shape),cont:Bool,filter:PR(InteractionFilter)) {
		return bphase.shapesInShape(shape,cont,filter);
	}
	flibmdel public inline function bodiesInShape(shape:PR(Shape),cont:Bool,filter:PR(InteractionFilter)) {
		return bphase.bodiesInShape(shape,cont,filter);
	}
	
	//----------------------------------------------------------------------------------------------
	
	flibmdel public inline function rayCast(ray:Ray,inner:Bool,filter:InteractionFilter) {
   		return bphase.rayCast(ray.pr(inner),inner,filter==null ? null : filter.pr(inner));
	}
	flibmdel public inline function rayMultiCast(ray:Ray,inner:Bool,filter:InteractionFilter) {
   		return bphase.rayMultiCast(ray.pr(inner),inner,filter==null ? null : filter.pr(inner));
	}
	
	//----------------------------------------------------------------------------------------------

    flibmdel public inline function push_callback(i:PR(Listener),hasHandler:Bool) {
		assert(i!=null,"null listenere for push_callback?");
        var cb = Get(PR(Callback));
        callbacks.push(cb);
        cb.listener = i;
        cb.handler = hasHandler;
        return cb;
    }

    //----------------------------------------------------------------------------------------------

	public var pre_dt:Float;	
	public function step(deltaTime:Float, velocityIterations:Int, positionIterations:Int) {
		DEBUG(if(midstep) throw "Error: ... REALLY?? you're going to call space.step() inside of space.step()? COME ON!!";)

        time += deltaTime;
		pre_dt = deltaTime;


        midstep = true;
        var elastic = velocityIterations>>1;
        var inelastic = velocityIterations-elastic;

		stamp++;
		#if NAPE_TIMES var pt = flash.Lib.getTimer(); #end
		validation();
		#if NAPE_TIMES Debug.VALID += flash.Lib.getTimer()-pt; #end
		
        #if NAPE_TIMES var pt = flash.Lib.getTimer(); #end 
		bphase.broadphase();
        #if NAPE_TIMES Debug.BROAD += flash.Lib.getTimer()-pt; #end 

        #if NAPE_TIMES var pt = flash.Lib.getTimer(); #end
		doForests(deltaTime);
        #if NAPE_TIMES Debug.FOR += flash.Lib.getTimer()-pt; #end

        #if NAPE_TIMES
            Debug.ACNT = 0;
            Debug.AACNT = 0;
            Debug.CCNT = 0;
            Debug.ACCNT = 0;
        #end

		#if NAPE_TIMES var pt = flash.Lib.getTimer(); #end
        prestep(deltaTime);
        #if NAPE_TIMES Debug.PRE += flash.Lib.getTimer()-pt; #end

        #if NAPE_TIEMS var pt = flash.Lib.getTimer(); #end
        iterateVel(elastic,true);
        #if NAPE_TIMES Debug.VEL += flash.Lib.getTimer()-pt; #end

        updateVel(deltaTime);
		warmStart();

        #if NAPE_TIMES var pt = flash.Lib.getTimer(); #end
		iterateVel(inelastic,false);
        #if NAPE_TIMES Debug.VEL += flash.Lib.getTimer()-pt; #end

		$(mixin doit(list) {
			Iter(cur,list,{
				vec_set(cur.pre_pos,cur.pos);
				cur.pre_rot = cur.rot;
			});
		});
		doit(kinematics);
		doit(live);
	
		updatePos(deltaTime);
				
        #if NAPE_TIMES var pt = flash.Lib.getTimer(); #end
		iteratePos(positionIterations);
        #if NAPE_TIMES Debug.POS += flash.Lib.getTimer()-pt; #end
		
		$(mixin doit2(list) {
			Iter(cur,list,{
				if(!vec_eq(cur.pos,cur.pre_pos))
					cur.invalidate_pos();
				vec_set(cur.pre_pos,cur.pos);
				if(cur.pre_rot!=cur.rot)
					cur.invalidate_rot();
				cur.pre_rot = cur.rot;

		//		if(!bphase.is_sweep)
		//			Iter(shape,cur.shapes,bphase.sync(shape))
			});
		});
		doit2(kinematics);
		doit2(live);
		
		while(!staticsleep.empty()) {
			var b = staticsleep.pop_unsafe();
			assert(!b.isDynamic(), "step :: swef static/kinematics");
			b.component.sleeping = true;
		}
        midstep = false;

        //process handlers
	    IterQueue(cb,callbacks,{
		    if(cb.handler) {
				if(cb.listener.type==Flag(ListenerType,BODY)) {
					var o = cb.listener.body;
					o.handler(cb.body.outer);
				}else if(cb.listener.type==Flag(ListenerType,CONSTRAINT)) {
					var o = cb.listener.constraint;
					o.handler(cb.constraint.outer);
				}else if(cb.listener.type==Flag(ListenerType,INTERACTION)) {
					var o = cb.listener.interaction;
					o.handler(cb.int1.outer_i,cb.int2.outer_i);
				}
	
				cx_ite = callbacks.splice(cb);
				Free(PR(Callback),cb);
				continue;
			}
		});
	}
	
	//----------------------------------------------------------------------------------------------

    flibmdel public inline function bodyCbWake(b:PR(Body)) {
        if(b.isDynamic() && b.cbType != null && b.cbType._bodywake != null) {
            if(midstep) {
				var i = b.cbType._bodywake;
                var cb = push_callback(i,i.handler!=null);
                cb.event = Flag(CbEvent,WAKE);
                cb.body = b;
            }else
                b.component.woken = true;
        }
    }

    flibmdel public inline function bodyCbSleep(b:PR(Body)) {
        if(b.isDynamic() && b.cbType!=null && b.cbType._bodysleep != null) {
			var i = b.cbType._bodysleep;
            var cb = push_callback(i,i.handler!=null);
            cb.event = Flag(CbEvent,SLEEP);
            cb.body = b;
        }
    }

    //----------------------------------------------------------------------------------------------

    flibmdel public inline function constraintCbWake(con:PR(Constraint)) {
        if(con.cbType != null && con.cbType._conwake != null) {
            if(midstep) {
				var i = con.cbType._conwake;
                var cb = push_callback(i,i.handler!=null);
                cb.event = Flag(CbEvent,WAKE);
                cb.constraint = con;
            }else
                con.component.woken = true;
        }
    }

    flibmdel public inline function constraintCbSleep(con:PR(Constraint)) {
        if(con.cbType != null && con.cbType._consleep != null) {
			var i = con.cbType._consleep;
            var cb = push_callback(i,i.handler!=null);
            cb.event = Flag(CbEvent,SLEEP);
            cb.constraint = con;
        }
    }

    flibmdel public inline function constraintCbBreak(con:PR(Constraint)) {
        if(con.cbType != null && con.cbType._break != null) {
			var i = con.cbType._break;
            var cb = push_callback(i,i.handler!=null);
            cb.event = Flag(CbEvent,BREAK);
            cb.constraint = con;
        }
    }

    //----------------------------------------------------------------------------------------------

	//when body/shape cbType is changed, it is nulled, then set again
	// ' also used as a perhaps non-optimal way of refreshing callbacksets
	// on listener changes

	//called before set to null.
	flibmdel public inline function nullBodyType(body:PR(Body),incb1:PR(CbType)=null,incb2:PR(CbType)=null) {
		nullBodyShapeType(body, $(mixin forobject(x) true) forobject);
	}
	flibmdel public inline function nullShapeType(shape:PR(Shape),incb1:PR(CbType)=null,incb2:PR(CbType)=null) {
		nullBodyShapeType(shape.body, $(mixin forobject(x) x.ws1==shape || x.ws2==shape) forobject);
	}
			
	$(mixin nullBodyShapeType(xbody,forobject) {
		assert((incb1==null) == (incb2==null), "bllop null");
		var check = incb1!=null && incb2!=null;
		
		Iter(xarb,xbody.arbiters,{
			if(!(xarb.active && (forobject(xarb)))) cx_continue;
			//only need to worry about to callbackset callbacks
			$(mixin docbs(o1,o2) {
				var cb1 = o1.cbType;
				var cb2 = o2.cbType;
				if(cb1!=null && cb2!=null && (!check || ((cb1==incb1&&cb2==incb2)||(cb1==incb2&&cb2==incb1)))) {
					var exists = false;
					if(cb1._end>0 && cb2._end>0)
						exists = _end.ordered_get(cb1.id,cb2.id)!=null;
					if(!exists && cb1._begin>0 && cb2._begin>0)
						exists = _begin.ordered_get(cb1.id,cb2.id)!=null;
					if(!exists && cb1._pre>0 && cb2._pre>0)
						exists = _pre.ordered_get(cb1.id,cb2.id)!=null;
					
					if(exists) {
						var callbackset = callbacksets.ordered_get(o1.id,o2.id);
						assert(callbackset!=null,"null callbackset on nullBodyShapeType? "+o1.outer.toString()+" "+o2.outer.toString()+" "+xarb.type);
						callbackset.remove(xarb);
						if(callbackset.empty()) {
							callbacksets.remove(callbackset);
							Free(PR(CallbackSet),callbackset);
						}
					}
				}
			});
			docbs(xarb.ws1,xarb.ws2.body);
			docbs(xarb.ws1.body,xarb.ws2);
			docbs(xarb.ws1.body,xarb.ws2.body);
		});
	});

	//called after cbtype is set
	flibmdel public inline function freshBodyType(body:PR(Body),incb1:PR(CbType)=null,incb2:PR(CbType)=null) {
		freshBodyShapeType(body, $(mixin forobject(x) true) forobject);
	}
	flibmdel public inline function freshShapeType(shape:PR(Shape),incb1:PR(CbType)=null,incb2:PR(CbType)=null) {
		freshBodyShapeType(shape.body, $(mixin forobject(x) x.ws1==shape || x.ws2==shape) forobject);
	}

	$(mixin freshBodyShapeType(xbody, forobject) {
		assert((incb1==null) == (incb2==null), "bllop null");
		var check = incb1!=null && incb2!=null;
		
		Iter(xarb,xbody.arbiters,{
			if(!(xarb.active && (forobject(xarb)))) cx_continue;
			//only need to worry about callbacksets
			$(mixin docbs(o1,o2) {
				var cb1 = o1.cbType;
				var cb2 = o2.cbType;
				if(cb1!=null && cb2!=null && (!check || ((cb1==incb1&&cb2==incb2)||(cb1==incb2&&cb2==incb1)))) {
					var exists = false;
					if(cb1._end>0 && cb2._end>0)
						exists = _end.ordered_get(cb1.id,cb2.id) != null;
					if(!exists && cb1._begin>0 && cb2._begin>0)
						exists = _begin.ordered_get(cb1.id,cb2.id) != null;
					if(!exists && cb1._pre>0 && cb2._pre>0)
						exists = _pre.ordered_get(cb1.id,cb2.id) != null;

					if(exists) {
						var callbackset = callbacksets.ordered_get(o1.id,o2.id);
						if(callbackset==null) {
							callbackset = PR(CallbackSet).get(o1.id,o2.id);
							callbacksets.add(callbackset);
						}
						callbackset.add(xarb);
					}
				}
			});
			docbs(xarb.ws1,xarb.ws2.body);
			docbs(xarb.ws1.body,xarb.ws2);
			docbs(xarb.ws1.body,xarb.ws2.body);
		});
	});

    //----------------------------------------------------------------------------------------------

	public function wakeGroup(g:PR(InteractionGroup)) {
		Iterate(g.bodies, wake);
		Iterate(g.groups, wakeGroup);
	}
	
	public function wakeIsland(i:PR(Island)) {
		assert(i.sleep,"this island is not sleeping but referenced? wtf");
		
		while(!i.comps.empty()) {
			var c = i.comps.pop_unsafe();
			assert(c.sleeping, "???");
			c.waket = stamp+1;

			if(c.isBody) {
				var b = c.body;
					
				assert(b.space==this,"wakeIsland:: body is not actually IN this space??");	
				assert(b.isDynamic(),"din din");
				live.add(b);
				
				Iter(arb, b.arbiters, {
					if(arb.sleeping) {
						arb.sleeping = false;
						arb.up_stamp += stamp - arb.sleep_stamp;
						if(arb.type == PR(Arbiter).COL) {
							var carb = arb.colarb;
							if(carb.stat)
								c_arbiters(true).add(carb);
							else
								c_arbiters(false).add(carb);
						} else if(arb.type == PR(Arbiter).FLUID)
							f_arbiters.add(arb.fluidarb);
						else
							s_arbiters.add(arb.sensorarb);
					}
				});

                bodyCbWake(b);
				c.reset();

				//sync with aabb broadphase
				if(!bphase.is_sweep && !b.isStatic())
					Iter(shape, b.shapes, if(shape.node!=null) bphase.sync(shape));
			}else {
				var con = c.constraint;
				assert(con.space==this,"wakeIsland:: constraint is not actually IN this space??");
				live_constraints.add(con);

                constraintCbWake(con);
				c.reset();
			}
		}
		
		Free(PR(Island),i);
	}
	
	public function wake(o:PR(Body),?fst=false) {
		assert(o.space==this,"object being woken in the space... is not actually in the space!");
		if(!o.world) {
			assert(o.component!=null,"body woken, but no component exists?");
			o.component.waket = stamp+1;
			if(o.component.sleeping) {
				if(o.component.island==null) {
					//new body, or forced wake, or kinematic/static
					o.component.sleeping = false;
					if(o.isKinematic() || o.isStatic())
						staticsleep.add(o);
					else
						live.add(o);
						
					if(!o.isDynamic()) {
						//wake any constraints that might exist
						//check that only constraints IN the space are woken!!
						Iter(con,o.constraints,if(con.space==this) wake_constraint(con));
						//wake any touching bodies
						Iter(arb,o.arbiters,{
							if(arb.sleeping) {
								arb.sleeping = false;
								arb.up_stamp += stamp - arb.sleep_stamp;
								if(arb.type == PR(Arbiter).COL) {
									var carb = arb.colarb;
									if(carb.stat)
										c_arbiters(true).add(carb);
									else
										c_arbiters(false).add(carb);
								}else if(arb.type == PR(Arbiter).FLUID)
										f_arbiters.add(arb.fluidarb);
								else
									s_arbiters.add(arb.sensorarb);
							}
							//we do not know anything about arb.active
							//so base this on information we do know.
							//that is to say up_stamp and immState
                            if(arb.type != PR(Arbiter).SENSOR && !arb.cleared
							&& arb.up_stamp==stamp && ((arb.immState&Flag(ImmState,ACCEPT))!=0)) {
								if(arb.b1.isDynamic() && arb.b1.component.sleeping) wake(arb.b1);
								if(arb.b2.isDynamic() && arb.b2.component.sleeping) wake(arb.b2);
							}
						});
					}else if(!fst) bodyCbWake(o);

					//sync with aabb broadphase
					if(!fst && !bphase.is_sweep && !o.isStatic())
						Iter(shape, o.shapes, if(shape.node!=null) bphase.sync(shape));
				}else {
					//wake island
					wakeIsland(o.component.island);
				}
                assert(o.component.island==null,"woken, but island non-null?");

				return true;
			}else return false;
		}else return true;
	}
	
	public function wake_constraint(con:PR(Constraint),?fst=false) {
		assert(con.space==this,"constraint woken, but not actually IN the space!");
		if(con.active) {
			assert(con.component!=null,"constraint woken but no component exists?");
            con.component.waket = stamp+1;
            if(con.component.sleeping) {
                if(con.component.island==null) {
                    //new constraint
                    con.component.sleeping = false;
                    live_constraints.add(con);
                    con.wake_connected();

                    if(!fst) constraintCbWake(con);
                }else {
                    //wake island
                    wakeIsland(con.component.island);
                }
                assert(con.component.island==null,"woken (con), but island non-null?");
                return true;
            }else return false;
		}else
			return false;
	}
	
	//----------------------------------------------------------------------------------------------
	
	public function doForests(dt:Float) {
		//build set foreset.
		//
		//arb.active has not yet been computed.
		//so we base it on all currently available information
		//that is to say, arb.up_stamp==stamp and immState.
		Iter(arb, c_arbiters(false), {
            if(!arb.cleared && arb.up_stamp==stamp && ((arb.immState&Flag(ImmState,ACCEPT))!=0)) {
                if(arb.b1.isDynamic() && arb.b2.isDynamic())
                    DSF(union(arb.b1.component, arb.b2.component))
            }
		});
		Iter(arb, f_arbiters, {
            if(!arb.cleared && arb.up_stamp==stamp && ((arb.immState&Flag(ImmState,ACCEPT))!=0)) {
                if(arb.b1.isDynamic() && arb.b2.isDynamic())
                    DSF(union(arb.b1.component, arb.b2.component))
            }
		});
		Iter(con, live_constraints, con.forest());
		
		//build islands
		while(!live.empty()) {
			var o = live.pop_unsafe();
			var oc = o.component;
			
			var root = DSF(find(oc));
			if(root.island==null) {
				root.island = Get(PR(Island));
				islands.add(root.island);
				root.island.sleep = true;
			}
			oc.island = root.island;
			oc.island.comps.add(oc);
			var rest = o.atRest(dt);
			oc.island.sleep = oc.island.sleep && rest;
			if(oc.waket > oc.island.waket) oc.island.waket = oc.waket;
		}
		while(!live_constraints.empty()) {
			var o = live_constraints.pop_unsafe();
			var oc = o.component;
			
			var root = DSF(find(oc));
			assert(root.island!=null,"constraint without bodies?");
			
			oc.island = root.island;
			oc.island.comps.add(oc);
            if(oc.waket > oc.island.waket) oc.island.waket = oc.waket;
		}

		//build new live lists from islands
		//destroy waking islands, retain sleeping islands for waking later when necessary.
		while(!islands.empty()) {
			var i = islands.pop_unsafe();
			if(i.sleep) {
				Iter(c,i.comps,{
					if(c.isBody) {
						var b = c.body;
						vec_set(b.vel,0,0);
						b.angvel = 0;
						vec_set(b.force,0,0);
						b.torque = 0;

						c.sleeping = true;
						//sync with dyn aabb broadphase on sleep
						if(!bphase.is_sweep)
							Iter(shape,b.shapes,bphase.sync(shape))

                        bodyCbSleep(b);
					}else {
                        var con = c.constraint;
                        constraintCbSleep(con);
						c.sleeping = true;
                    }
				});
			}else {
				while(!i.comps.empty()) {
					var c = i.comps.pop_unsafe();
                    c.waket = i.waket;
					if(c.isBody) live.add(c.body);
					else         live_constraints.add(c.constraint);
					c.reset();
				}
				Free(PR(Island),i);
			}
		}
	}
	
	//----------------------------------------------------------------------------------------------
	
	public function static_validation(body:PR(Body)) {
		//validate body properties needed here as they are not 'allowed' to change
		//(material can be changed, but due to static nature, mass/inertia remain infinite)
		body.validate_aabb(); //validates worldVerts/worldCOM of shapes and their AABB
		body.validate_mass();
		body.validate_inertia();
        DEBUG(
            if(body.velx!=0 || body.vely!=0 || body.angvel!=0)
                throw "Error: Static body cannot have any real velocity, only kinematic or surface velocities";
        )
		Iter(s,body.shapes,{
			if(s.isPolygon()) {
				s.polygon.validate_gaxi();
				DEBUG(
					var res = s.polygon.valid();
					if(res!=ValidationResult.VALID) {
						throw "Error: Cannot simulate with an invalid Polygon : "+s.polygon.outer.toString()+" is invalid : "+res.toString();
					}
				)
			}
		});
		//check: no other properties (Body worldCOM, shape worldCOM(polygon) are needed?)
	}
	
	public function validation() {
		$(mixin update(list, kin) {
			Iter(cur,list,{
				DEBUG(if(cur.shapes.empty())
					throw "Error: Cannot simulate an empty Body";
				)
				
				cur.validate_mass();
				cur.validate_inertia();
				cur.validate_aabb();
				cur.validate_gravMass();
				cur.validate_worldCOM();
				cur.validate_axis();
					
				Iter(s,cur.shapes,{
					if(s.isPolygon()) {
						DEBUG(
							var res = s.polygon.valid();
							if(res!=ValidationResult.VALID) {
								throw "Error: Cannot simulate with an invalid Polygon : "+s.polygon.outer.toString()+" is invalid : "+res.toString();
							}
						)
						s.polygon.validate_gaxi();
					}
				});

                //wake callbacks
                if(!kin) {
                    if(cur.component.woken && cur.cbType != null && cur.cbType._bodywake!=null) {
						var i = cur.cbType._bodywake;
                        var cb = push_callback(i,i.handler!=null);
                        cb.event = Flag(CbEvent,WAKE);
                        cb.body = cur;
                    }
                    cur.component.woken = false;
                }

				if(!bphase.is_sweep)
					Iter(shape,cur.shapes,bphase.sync(shape));
			});
		});
		
		update(live,false);
		update(kinematics,true);
		
		//check validity of constraints' set-up.
        //do wake callbacks
        Iter(con,live_constraints,{
            if(con.active) {
                DEBUG(con.validate();)
                if(con.component.woken && con.cbType != null && con.cbType._conwake!=null) {
					var i = con.cbType._conwake;
                    var cb = push_callback(i,i.handler!=null);
                    cb.event = Flag(CbEvent,WAKE);
                    cb.constraint = con;
                }
                con.component.woken = false;
            }
        });
	}
	
	//----------------------------------------------------------------------------------------------
	
	public function updateVel(dt:Float) {
		var pre = null;
		Iter(cur,live,{
			vec_addeq(cur.force,gravity,cur.gravMass);
			vec_addeq(cur.force,cur.vel,-PR(Config).GLOBAL_LIN_DRAG*cur.mass);
			if(cur.smass!=0.0)
				vec_addeq(cur.vel,cur.force,dt*cur.imass);
			
			vec_set(cur.force,0,0);
			
			if(cur.sinertia!=0.0) {
				vec_new(dp); vec_sub(cur.worldCOM,cur.pos,dp);
				cur.torque += vec_cross(dp,gravity)*cur.gravMass;
				cur.torque -= cur.angvel*PR(Config).GLOBAL_ANG_DRAG*cur.inertia;
				cur.angvel += cur.torque*dt*cur.iinertia;
			}
			cur.torque = 0;
			
			pre = cx_ite;
		});
	}
	
	//----------------------------------------------------------------------------------------------
	
	public function updatePos(dt:Float) {
		$(mixin doit(list) {
			Iter(cur,list,{
				vec_addeq(cur.pos,cur.vel,dt);
				if(cur.angvel!=0)
					cur.delta_rot(cur.angvel*dt);
			});
		});
		doit(live);
		doit(kinematics);
	}

	//----------------------------------------------------------------------------------------------
	
	public function prestep(dt:Float) {
		
		var pre = null;
		Iter(con,live_constraints,{
			if(con.preStep(dt)) {
				cx_ite = live_constraints.erase(pre);

                if(con.removeOnBreak) {
                    //set sleeping to true as already removed from live list.
                    con.component.sleeping = true; remConstraint(con);
                    constraints.remove(con);
                }else
                    con.active = false;

                con.clearcache();
                constraintCbBreak(con);
				continue;
			}
			pre = cx_ite;
		});
		$(mixin prestep(arbs,action) {
			var pre = null;
			Iter(arb,arbs,{
				if(!arb.cleared && (arb.b1.component.sleeping && arb.b2.component.sleeping)) {
					arb.sleep_stamp = stamp;
					arb.sleeping = true;
					cx_ite = arbs.erase(pre);
					continue;
				}

                #if NAPE_TIMES Debug.ACNT++; #end

				var pact = arb.active;
				arb.active = true;
				arb.active = pact;

				if(!arb.cleared) {	
					//callbacks
					var endcb = arb.up_stamp==stamp-1;
					var begcb = arb.fresh;
					assert(!begcb || arb.up_stamp==stamp, " fresh -> active=true hasn't held :(");

					DEBUG(var endlist:PR(InteractionListener) = null;)
					DEBUG(var beglist:PR(InteractionListener) = null;)

					$(mixin docbs(S1,S2,o1,o2) {
						var cb1 = o1.cbType;
						var cb2 = o2.cbType;
						if(cb1!=null && cb2!=null) {
							var exists = false;
							var begi:PR(InteractionListener) = null;
							var endi:PR(InteractionListener) = null;
							if(cb1._begin > 0 && cb2._begin > 0) {
								exists = (begi = _begin.ordered_get(cb1.id,cb2.id)) != null;
							}
							if(cb1._end > 0 && cb2._end > 0) {
								endi = _end.ordered_get(cb1.id,cb2.id);
								exists = exists || (endi != null);
							}
							if(!exists && cb1._pre>0 && cb2._pre>0)
								exists = _pre.ordered_get(cb1.id,cb2.id)!=null;

							if(exists) {
								DEBUG(
									if(beglist!=null && begi!=null) throw "Error: Multiple valid listeners for BEGIN callback between possible shape/body combies, s1="+arb.ws1.outer.toString()+" s2="+arb.ws2.outer.toString()+". l1="+beglist.outer.toString()+" l2="+begi.outer.toString();
									if(begi!=null) beglist = begi;

									if(endlist!=null && endi!=null) throw "Error: Multiple valid listeners for END callback between possible shape/body combies, s1="+arb.ws1.outer.toString()+" s2="+arb.ws2.outer.toString()+". l1="+endlist.outer.toString()+" l2="+endi.outer.toString();
									if(endi!=null) endlist = endi;
								)
								if(S1 && S2) {
									//special case shape-shape
									if(begcb && begi!=null) {
										var cb = push_callback(begi,begi.handler!=null);
										cb.event = Flag(CbEvent,BEGIN);
										PR(Interactor).int_callback(o1,o2,begi.cb1,cb);
									}elif(endcb && endi!=null) {
										var cb = push_callback(endi,endi.handler!=null);
										cb.event = Flag(CbEvent,END);
										PR(Interactor).int_callback(o1,o2,endi.cb1,cb);
									}
								}else {
									var callbackset = callbacksets.ordered_get(o1.id,o2.id);
									if(begcb) {
										if(callbackset==null) {
											callbackset = PR(CallbackSet).get(o1.id,o2.id);
											callbacksets.add(callbackset);
										}
										//check for empty, rather than null callbackset as the callbackset is created in narrowphase
										//to avoid multiple pre-listeners.
										if(callbackset.empty() && begi!=null) {
											var cb = push_callback(begi,begi.handler!=null);
											cb.event = Flag(CbEvent,BEGIN);
											PR(Interactor).int_callback(o1,o2,begi.cb1,cb);
										}
										callbackset.add(arb);
									}elif(endcb) {
										assert(callbackset!=null,"end arbiter with no callbackset");
										callbackset.remove(arb);
										if(callbackset.empty()) { 
											callbacksets.remove(callbackset);
											Free(PR(CallbackSet),callbackset);

											if(endi!=null) {
												var cb = push_callback(endi,endi.handler!=null);
												cb.event = Flag(CbEvent,END);
												PR(Interactor).int_callback(o1,o2,endi.cb1,cb);
											}
										}
									}
								}
							}
						}
					});
					if(begcb || endcb) {
						docbs(true,true,arb.ws1,arb.ws2);
						docbs(true,false,arb.ws1,arb.ws2.body);
						docbs(false,true,arb.ws1.body,arb.ws2);
						docbs(false,false,arb.ws1.body,arb.ws2.body);
					}
					arb.fresh = false;
				}

				//no need for sensor/fluid arbiters to persist after deactivation, just remove now.
				if(arb.cleared //always retire
			 	 || arb.up_stamp + (arb.type==PR(Arbiter).COL ? PR(Config).PERSIST : 0) < stamp //possibly delayed age-death
				) {
					if(!arb.cleared)
						map_arb.remove(arb);
					arb.retire();
					cx_ite = arbs.erase(pre);
					continue;
				}
				
				var pact = arb.active;
				arb.active = arb.up_stamp==stamp;

				if((arb.immState&Flag(ImmState,ACCEPT)) != 0) {
					if(!(action)) arb.active = false;
				}else if($str(arbs)=="c_arbiters_true" || $str(arbs)=="c_arbiters_false") {
					if(!untyped arb.cleanupContacts()) arb.active = false;
				}
				
				//necessary to notify lists of non structual changes for API
				if(pact!=arb.active) {
					arb.b1.arbiters.modified = true;
					arb.b2.arbiters.modified = true;
					arbs.modified = true;
				}
				
				pre = cx_ite;
			});
		});
	
		//still iterate non acting arbiters
		//want to clean up contacts in collision arbiters
		//and clean up outdated arbiters also	
		prestep(c_arbiters(true),  if(arb.active) arb.preStep(dt));
		prestep(c_arbiters(false), if(arb.active) arb.preStep(dt));
		prestep(f_arbiters,      { if(arb.active) arb.preStep(this,dt); true; });
		prestep(s_arbiters,{true;});
	}

	//----------------------------------------------------------------------------------------------
	
    public function warmStart() {
        Iter(arb,f_arbiters,       if(arb.acting()) arb.warmStart());
        Iter(arb,c_arbiters(false),if(arb.acting()) arb.warmStart());
        Iter(arb,c_arbiters(true), if(arb.acting()) arb.warmStart());
        Iter(con,live_constraints, con.warmStart());
	}

	public function iterateVel(times:Int,bouncy:Bool) {
		for(i in 0...times) {
			Iter(arb,f_arbiters,if(arb.acting()) arb.applyImpulseVel());
			
			var pre = null;
			Iter(con,live_constraints, {
				if(con.applyImpulseVel()) {
					cx_ite = live_constraints.erase(pre);

					if(con.removeOnBreak) {
                        //set sleeping to true as already removed from live list.
                        con.component.sleeping = true; remConstraint(con);
                        constraints.remove(con);
                    }else
                        con.active = false;

                    con.clearcache();

                    constraintCbBreak(con);
					continue;
				}
				pre = cx_ite;
			});
				
			Iter(arb,c_arbiters(false),if(arb.acting()) arb.applyImpulseVel(bouncy));
			Iter(arb,c_arbiters(true), if(arb.acting()) arb.applyImpulseVel(bouncy));
		}
	}
	public function iteratePos(times:Int) {
		for(i in 0...times) {
			//ignore soft constraints.
			var pre = null;
			Iter(con,live_constraints, {
				if(!con.__velocity && con.stiff) {
					if(con.applyImpulsePos()) {
						cx_ite = live_constraints.erase(pre);
						
                        if(con.removeOnBreak) {
                            //set sleeping to true as already removed from live list.
                            con.component.sleeping = true; remConstraint(con);
                            constraints.remove(con);
                        }else
                            con.active = false;

                        con.clearcache();

                        constraintCbBreak(con);
						continue;
					}
				}
				pre = cx_ite;
			});
				
			Iter(arb,c_arbiters(false),if(arb.acting()) arb.applyImpulsePos());
			Iter(arb,c_arbiters(true), if(arb.acting()) arb.applyImpulsePos());
		}
	}

	//----------------------------------------------------------------------------------------------

	flibmdel public inline function group_ignore(s1:PR(Shape),s2:PR(Shape)) {
		//find closest group from interactor
		var g1 = s1.lookup_group();
		var g2 = s2.lookup_group();
		if(g1==null || g2==null) return false;
		else {
			//lookup ignore on most recent shared ancestor
			var ret = false;
			while(g1!=null && g2!=null) {
				if(g1==g2) { ret = g1.ignore; break; }
				elif(g1.depth==g2.depth) {
					g1 = g1.group;
					g2 = g2.group;
				}elif(g1.depth<g2.depth)
					g2 = g2.group;
				else
					g1 = g1.group;
			}
			return ret;
		}
	}

	flibmdel public inline function narrowPhase(s1:PR(Shape),s2:PR(Shape), stat:Bool, ?in_arb:PR(Arbiter)=null) {
		var ret:PR(Arbiter) = null;

        var b1 = s1.body;
		var b2 = s2.body;

        assert(!(b1.isStatic() && b2.isStatic()), "both objects static?");

        //check if constraints exists such that this should be ignored
		//check if the two bodies belong to a group hierarchy to be ignored.
        if(!Exists(con, b1.constraints, con.ignore && con.pair_exists(b1.id,b2.id))
		&& !group_ignore(s1,s2)
		) {

            var gcol = s1.filter.shouldCollide(s2.filter)
                && !(b1.imass==0 && b2.imass==0 && b1.iinertia==0 && b2.iinertia==0);
					
            var scol = s1.filter.shouldSense(s2.filter);
				
            var fcol = (s1.fluidEnabled || s2.fluidEnabled) && s1.filter.shouldFlow(s2.filter) &&
              ! (  (s1.fluidEnabled &&  b1.isDynamic() && !s2.fluidEnabled && !b2.isDynamic())
                || (s2.fluidEnabled &&  b2.isDynamic() && !s1.fluidEnabled && !b1.isDynamic())
                || (s1.fluidEnabled && !b1.isDynamic() && !b2.isDynamic())
                || (s2.fluidEnabled && !b2.isDynamic() && !b1.isDynamic())
            );
				
            if(scol || gcol || fcol) {
                var sa,sb;
                if(s1.type > s2.type) { sa = s2; sb = s1; }
                else if(s1.type == s2.type) {
                    if(s1.id < s2.id) { sa = s1; sb = s2; }
                    else              { sb = s1; sa = s2; }
                }else { sa = s1; sb = s2; }
                var reverse = sa == s2;

				$(mixin narrowed(arb,Type,arbs, cond, waking,collisions) {
					if(first || arb.stamp!=stamp) {
						arb.stamp = stamp;

						if(cond) {
							if(first) {
								arb.assign(s1,s2,sa.id,sb.id);
								arbs.add(arb);
								map_arb.add(arb);
								arb.fresh = !swapped;
							}else
								arb.fresh = arb.up_stamp<stamp-1; //handler persistance
							arb.up_stamp = arb.stamp;

							//search for a pre-listener or existing callbackset
							var listener:PR(PreListener) = null;
							var callbackset:PR(CallbackSet) = null;
							var ncallbackset:PR(CallbackSet) = null;
							$(mixin docbs(SHAPES,o1,o2) {
								if(RELEASE(listener==null) DEBUG(true)) {
									var cb1 = o1.cbType;
									var cb2 = o2.cbType;
									if(cb1!=null && cb2!=null && cb1._pre>0 && cb2._pre>0) {
										DEBUG(var i) RELEASE(listener) = _pre.ordered_get(cb1.id,cb2.id);
										DEBUG(if(i!=null && listener!=null) throw "Error: Multiple valid pre-listeners for possible shape/body combinations. s1="+s1.outer.toString()+" s2="+s2.outer.toString()+" and related bodies. l1="+i.outer.toString()+" l2="+listener.outer.toString();)
										DEBUG(listener = i;)
										#if !SHAPES
											if(listener!=null) {
												callbackset = callbacksets.ordered_get(o1.id,o2.id); 
												if(callbackset==null) {
													ncallbackset = PR(CallbackSet).get(o1.id,o2.id);
													callbacksets.add(ncallbackset);
												}
											}
										#end
									}
								}
							});
	
							if(arb.fresh || (arb.immState&Flag(ImmState,ALWAYS))==0) {
								arb.immState = Flag(ImmState,ACCEPT);
								docbs(true,s1,s2);
								docbs(false,s1.body,s2);
								docbs(false,s1,s2.body);
								docbs(false,s1.body,s2.body);
							}
							if(listener!=null && (callbackset==null || callbackset.stamp!=stamp)) {
								if(callbackset!=null) callbackset.stamp = stamp;

								// arbiter (public) is not active in the situtation of a persistant
								// collision arbiter being re-used before it was retired.
								// so we activate it temporarily.

								// we need to reset to old value so that in pre-step such an arbiter
								// can as usual, update the public lists.
								var pact = arb.active; arb.active = true;
								#if collisions //need to do this with #if since fluid/sensor has no such method
									//update wrapped contact list for user.
									arb.cleanupContacts();
								#end
								DEBUG(arb.makemutable();)
								var ret = listener.handler(arb.wrapper());
								DEBUG(arb.makeimmutable();)
								
								arb.active = pact;

								DEBUG(if(ret==null) throw "Error: PreListener handler should not return null >.>";)
								arb.immState = 
									if  (ret==PreFlag.ACCEPT)      Flag(ImmState, ACCEPT) | Flag(ImmState, ALWAYS)
									elif(ret==PreFlag.ACCEPT_ONCE) Flag(ImmState, ACCEPT)
									elif(ret==PreFlag.IGNORE)      Flag(ImmState, IGNORE) | Flag(ImmState, ALWAYS)
									else                           Flag(ImmState, IGNORE);

								if((arb.immState&Flag(ImmState,ACCEPT))!=0) {
									//make sure things like normals are still normalised
									arb.pre_validate();
								}
							}else if(callbackset==null) {
								//reset state on non-persistance
								if((arb.immState&Flag(ImmState,ALWAYS))==0)
									arb.immState = Flag(ImmState, ACCEPT);
							}else {
								arb.immState = callbackset.state;
							}
							if(callbackset==null && ncallbackset!=null)
								ncallbackset.state = arb.immState;

							//DON'T LET THE OBJECTS GO TO SLEEP!!
							//# we cannot assume that at some point
							//  handler (without explicit change) will
							//  inform nape to do something differently
							//  which would require the objects to be woken
							//  so we can't let the objects sleep
							if(listener!=null && !listener.pure && (arb.immState&Flag(ImmState,ALWAYS))==0) {
								//wake even if 'waking' false (aka sensor arbiter)
								//to keep consistency w.r.t #_ONCE handlers
								//
								//we do not check that they are sleeping before waking
								//as we want them to never sleep which would be possible
								//if we allowed them both to go to sleep at same time.
								//
								//what about non-dynamics? (like below waking)
								//    @ not sure this is important.
								//      the only relevant cases are static/kinematic - kinematic sensor arbiters
								//      which it would be fairly strange to use pre callbacks with.
								//    @ it should suffice to only wake non-statics
								//      and for non-sensor arbiters, we should be able to wake only
								//      dynamics as usual :)  ~ note: 'waking' only true for non-sensors so we use this.
								if(waking) {
									if(arb.b1.isDynamic()) wake(arb.b1);
									if(arb.b1.isDynamic()) wake(arb.b2);
								}else {
									if(!arb.b1.isStatic()) wake(arb.b1);
									if(!arb.b2.isStatic()) wake(arb.b2);
								}
							}
							//optimisation, none-accept arbiter need not wake it's constituents
							if(waking && (arb.immState & Flag(ImmState, ACCEPT)) !=0) {
								if(arb.b1.component.sleeping && arb.b1.isDynamic())
									wake(arb.b1);
								if(arb.b2.component.sleeping && arb.b2.isDynamic())
									wake(arb.b2);
							}

							if(arb.sleeping) {
								arb.sleeping = false;
								arbs.add(arb);
							}

							arb;
						}else if(first) {
							Free(Type, arb);
							null;
						}
					}else null;
				});

                if(fcol) {
                    var xarb = if(in_arb==null) map_arb.get(sa.id,sb.id) else in_arb;
                    var first = xarb==null;

                    var arb; var swapped = false;
                    if(first) arb = Get(PR(FluidArbiter))
                    else {
                        if(xarb.fluidarb==null) {
                            xarb.lazyRetire(this,null);
                            arb = Get(PR(FluidArbiter));
                            first = true;
							swapped = true;
                        }else
                            arb = xarb.fluidarb;
                    }
						
					ret = narrowed(arb,PR(FluidArbiter),f_arbiters, PR(Collide).flowCollide(sa,sb,arb), true,false);
                } else if(gcol) {
                    var carbs = stat ? c_arbiters(true) : c_arbiters(false);

                    var xarb = if(in_arb==null) map_arb.get(sa.id,sb.id) else in_arb;
                    var first = xarb==null;
						
                    var arb; var swapped = false;
                    if(first) {
                        arb = Get(PR(ColArbiter));
                        arb.stat = stat;
                    } else {
                        if(xarb.colarb==null) {
                            xarb.lazyRetire(this,null);
                            arb = Get(PR(ColArbiter));
                            arb.stat = stat;
                            first = true;
							swapped = true;
                        }else {
                            arb = xarb.colarb;
                            reverse = sa != arb.s1;

                            if(arb.stat != stat) {
                                arb.stat = stat;
                                if(!arb.sleeping) {
                                    (if(stat) c_arbiters(false) else c_arbiters(true)).remove(arb);
                                    carbs.add(arb);
                                }
                            }
                        }
                    }

					ret = narrowed(arb,PR(ColArbiter),carbs, PR(Collide).contactCollide(sa,sb,arb,reverse), true,true);
                } else if(scol) {
                    var xarb = if(in_arb==null) map_arb.get(sa.id,sb.id) else in_arb;
                    var first = xarb==null;
						
                    var arb; var swapped = false;
                    if(first) arb = Get(PR(SensorArbiter))
                    else {
                        if(xarb.sensorarb==null) {
                            xarb.lazyRetire(this,null);
                            arb = Get(PR(SensorArbiter));
                            first = true;
							swapped = true;
                        }else
                            arb = xarb.sensorarb;
                    }
					
					ret = narrowed(arb,PR(SensorArbiter),s_arbiters, PR(Collide).testCollide(sa,sb), false,false);
				}
			}
		}
		return ret;
	}
}
