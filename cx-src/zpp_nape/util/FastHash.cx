package zpp_nape.util;
$(import);

//only suitable for native types.
$(define global keep class Hashable2(T) {
	public var value:T;
	MixPool(Hashable2(T))
	public var hnext:Hashable2(T);

	public var id:Int;
	public var di:Int;

	flibmdel public inline function free() {}
	flibmdel public inline function alloc() {}
	function new() {}

	public static inline function get(id:Int,di:Int,val:T) {
		var ret = get_persist(id,di);
		ret.value = val;
		return ret;
	}
	public static inline function get_persist(id:Int,di:Int) {
		var ret = Get(Hashable2(T));
		ret.id = id;
		ret.di = di;
		return ret;
	}
	public static inline function ordered_get(id:Int,di:Int,val:T) {
		return if(id<=di) get(id,di,val) else get(di,id,val);
	}
	public static inline function ordered_get_persist(id:Int,di:Int) {
		return if(id<=di) get_persist(id,di); else get_persist(di,id);
	}
});

$(mixin global ClearHashWith(hash,cb) {
	for(i in 0...hash.table.length) {
		var n = hash.table[i];
		if(n==null) continue;
		while(n!=null) {
			var t = n.hnext;
			n.hnext = null;
			cb(n);
			n = t;
		}
		hash.table[i] = null;
	}
});

$(define global keep class FastHash2(T) {
	public var table:ARRAY(T);
	public var cnt:Int;

	public function new() {
		cnt = 0;
		#if flash10
			table = new flash.Vector<T>(0x100000,true);
		#else
			table = new Array<T>();
			for(i in 0...(0x100000)) table.push(null);
		#end
	}

	flibmdel public inline function empty() return cnt==0

	flibmdel public inline function destroy() {
		clear();
		table = null;
	}

	flibmdel public inline function clear() ClearHashWith(this,$(mixin cb(x)))

	flibmdel public inline function get(id:Int,di:Int):T {
		var n = table[hash(id,di)];
		if(n==null) return null;
		else if(n.id == id && n.di == di) return n;
		else {
			do n = n.hnext
			while(n!=null && (n.id != id || n.di != di));
			return n;
		}
	}

	flibmdel public inline function ordered_get(id:Int,di:Int) {
		return if(id<=di) get(id,di) else get(di,id);
	}

	flibmdel public inline function has(id:Int,di:Int):Bool {
		var n = table[hash(id,di)];
		if(n==null) return false;
		else if(n.id == id && n.di == di) return true;
		else {
			do n = n.hnext
			while(n!=null && (n.id != id || n.di != di));
			return n!=null;
		}
	}

	flibmdel public inline function maybeAdd(arb:T) {
		assert(arb!=null,"cannot add null to hash2");
		var h = hash(arb.id,arb.di);
		var n = table[h];
		var cont = true;
		if(n==null) {
			table[h] = arb;
			arb.hnext = null;
		}else {
			#if NAPE_ASSERT
				var nor = n;
				while(n!=null) {
					if(n.id==arb.id && n.di==arb.di) {
						cont = false;
						break;
					}
					n = n.hnext;
				}
				n = nor;
			#end
			if(cont) {
				arb.hnext = n.hnext;
				n.hnext = arb;
			}
		}
		if(cont)
			cnt++;
	}

	flibmdel public inline function add(arb:T) {
		assert(arb!=null,"cannot add null to hash2");
		var h = hash(arb.id,arb.di);
		var n = table[h];
		if(n==null) {
			table[h] = arb;
			arb.hnext = null;
		}else {
			#if NAPE_ASSERT
				var nor = n;
				while(n!=null) {
					if(n.id==arb.id && n.di==arb.di) throw "ASSERTION: FastHash2("+$str(T)+") already cotnains object with ids";
					n = n.hnext;
				}
				n = nor;
			#end
			arb.hnext = n.hnext;
			n.hnext = arb;
			#if NAPE_TIMES
				Debug.HASH++;
			#end
		}
		#if NAPE_TIMES
			Debug.HASHT++;
		#end
		cnt++;
	}

	flibmdel public inline function remove(arb:T) {
		assert(arb!=null,"cannot remove null from hash2");
		var h = hash(arb.id,arb.di);
		var n = table[h];
		if(n==arb) table[h] = n.hnext;
		else if(n!=null) {
			var pre:T;
			do { pre = n; n = n.hnext; }
			while(n!=null && n!=arb);

			assert(n!=null,"object doesn't exist in hash2");
			pre.hnext = n.hnext;
		}
		arb.hnext = null;
		cnt--;
	}

	flibmdel public inline function hash(id:Int,di:Int) return ((id*106039)+di)&0xfffff
//	flibmdel public inline function hash(id:Int,di:Int) return ((~(id*106039))^di)&0xffff
//	flibmdel public inline function hash(a,b) return 0
});

$(define global class FastHash(T) {
    public var table:ARRAY(T);

    public function new() {
        #if flash10
            table = new flash.Vector<T>(0x10000,true);
        #else
            table = new Array<T>();
			for(i in 0...(0x10000)) table.push(null);
        #end
    }

	flibmdel public inline function clear() ClearHashWith(this,$(mixin cb(x)))

    flibmdel public inline function get(id:Int):T {
        var n = table[hash(id)];
        if(n==null) return null;
        else if(n.id == id) return n;
        else {
            do n = n.hnext
            while(n!=null && n.id != id);
            return n;
        }
    }

	flibmdel public inline function has(id:Int):Bool {
		var n = table[hash(id)];
		if(n==null) return false;
		else if(n.id == id) return true;
		else {
			do n = n.hnext
			while(n!=null && n.id!=id);
			return n!=null;
		}
	}

    flibmdel public inline function add(arb:T) {
	    assert(arb!=null,"cannot add null to hash");
        var h = hash(arb.id);
        var n = table[h];
        if(n==null) {
            table[h] = arb;
            arb.hnext = null;
        } else {
            #if NAPE_ASSERT
                var nor = n;
                while(n!=null) {
                    if(n.id==arb.id) throw "ASSERTION: FastHash("+$str(T)+") already contains object with given id";
                    n = n.hnext;
                }
                n = nor;
            #end
            arb.hnext = n.hnext;
            n.hnext = arb;
        }
    }

    flibmdel public inline function remove(arb:T) {
		assert(arb!=null,"cannot remove null from hash");
        var h = hash(arb.id);
        var n = table[h];
        if(n==arb) table[h] = n.hnext;
        else if(n!=null) {
            var pre:T;
            do { pre = n; n = n.hnext; }
            while(n != null && n != arb);
            if(n!=null) pre.hnext = n.hnext;
        }
        arb.hnext = null;
    }

    flibmdel public inline function hash(key:Int) return (key*106039) & 0xffff
});
