package zpp_nape.util;
$(import);

//--------------------------------------------------------------------------------------------------

$(mixin global ArrayList(T) 
	#if NAPE_ARRAYS
		GenList(T,ZNPListARAR_`T,true,NAPE_ARRAYS) ZNPListARAR_`T
	#else
		GenList(T,ZNPListARLL_`T,false,(!NAPE_ARRAYS)) ZNPListARLL_`T
	#end
);
$(mixin global ArrayNode(T)
	#if !NAPE_ARRAYS
		Node(T)
	#else
		Int
	#end
);

$(mixin global List(T) GenList(T,ZNPListLL_`T,false,true) ZNPListLL_`T);
$(expand global GenList(T,NAMI,USE_ARRAY,KEEPITALL)
#if KEEPITALL
class NAMI {

	#if USE_ARRAY
		public var elts:ARRAY(T);
	#else
		public var head:Node(T);
	#end

	public function new() {
		#if USE_ARRAY
			elts = new ARRAY(T)();
		#end
	}

	flibmdel public inline function begin() {
		#if USE_ARRAY
			return 0;
		#else
			return head;
		#end
	}
	
	ListMixin(
		//for LL
		$(mixin _setbeg(i) head=i)
		$(mixin _new   (o) {
			var ret = Get(Node(T));
			ret.elt = o;
			ret;
		})
		$(mixin _delete(i) Free(Node(T),i))
		//for both
		$(mixin _delelt(o) {})
		$(mixin _clear true)
	,
		NAMI,T,#if USE_ARRAY Int #else Node(T) #end,USE_ARRAY
	)
}
#end);

$(mixin global AllocList(T) GenAllocList(T) ZNPAllocList_`T);
$(expand global GenAllocList(T)
class AllocList(T) {
	public var head:Node(T);
	public function new() {}
	flibmdel public inline function begin() return head
	
	ListMixin(
		$(mixin _setbeg(i) head=i)
		$(mixin _new   (o) {
			var ret = Get(Node(T));
			ret.elt = o;
			ret;
		})
		$(mixin _delete(i) Free(Node(T),i))
		$(mixin _delelt(o) Free(T,o))
		$(mixin _clear true)
	,
		AllocList(T),T,Node(T)
	)
});

$(mixin global Node(T) GenNode(T) ZNPNode_`T);
$(expand global GenNode(T)
class Node(T) {
	MixPoolNoNext(Node(T))
	
	public var next:Node(T);
	flibmdel public inline function alloc() {}
	flibmdel public inline function free() {
		elt = null;
	}
	public var elt:T;
	public function new() {}
	flibmdel public inline function elem() return elt
});

//--------------------------------------------------------------------------------------------------

$(expand global MixDerivedList(T,ListT,IteT,defs)
	$(mixin accept(x) true);
	$(mixin use_accept false);
	
	$(mixin copy_elt(o) { DEBUG(throw "Error: "+$str(T)+" is not a copyable type";) });
	
	class PR(Mix`T`List) extends T`List {
		defs
		
		public var inner:ListT;
		
		public var _length:Int;
		public var inv(length):Bool;
		
		public var at_ite:IteT;
		public var at_index:Int;

		public static function get(list:ListT,?immutable=false) {
			var ret = new PR(Mix`T`List)();
			ret.inner = list;
			ret.pr(inner).immutable = immutable;
			return ret;
		}
		
		public function new() {
			super();
			
			at_ite = null;
			at_index = 0;
			inv(length) = true;
			_length = 0;
		}
		
		public override function pr(gl)() {
			pr(vm)();
			
			if(inv(length)) {
				_length = 0;
				Iter(i, inner, if(accept(i)) _length++);
				inv(length) = false;
			}
			
			return _length;
		}
		
		public override function pr(vm)() {
			pr(inner).validate();
			
			if(inner.modified) {
				DEBUG(if(pr(inner).iterators!=null) {
					Iter(i,pr(inner).iterators,{
					if(i.pr(critical)) throw "Error: Lists should never be modified once hasNext() has been called, and before next() has been called on iterators to the list as it is not defined behaviour. In this case it appears that you are using api functions that modify this list between hasNext() and next() calls which bypass the usual checks.";
					});
				})
				
				inv(length) = true;
				_length = 0;
				at_ite = null;
			}
		}
		
		keep public override function at(index:Int):T {
			pr(vm)();
			
			DEBUG(if(index<0 || index>=length) throw "Error: Index out of bounds";)
			
			if(pr(inner).reverse_flag) index = length-1-index;
			
			if(index < at_index || at_ite == null) {
				at_index = 0;
				at_ite = inner.begin();
				while(true) {
					var x = at_ite.elem();
					if(accept(x)) break;
					at_ite = at_ite.next;
				}
			}
			while(at_index!=index) {
				at_index++;
				at_ite = at_ite.next;
				while(true) {
					var x = at_ite.elem();
					if(accept(x)) break;
					at_ite = at_ite.next;
				}
			}
			
			return closure(at_ite.elem());
		}
		
		keep public override function push(obj:T) {
			DEBUG(if(pr(inner).immutable) throw "Error: "+$str(T)+"List is immutable";)
			pr(inner).modify_test();
			
			pr(vm)();
			DEBUG(if(obj.pr(inner).inuse) throw "Error: "+$str(T)+" is already in use";)
			
			var cont = if(pr(inner).adder!=null) pr(inner).adder(obj) else true;
			if(cont) {
				if(pr(inner).reverse_flag)
					inner.add(erusolc(obj));
				else {
					var ite = inner.iterator_at(length-1);
					inner.insert(ite,erusolc(obj));
				}
				pr(inner).invalidate();
				
				if(pr(inner).post_adder!=null) pr(inner).post_adder(obj);
			}
			return cont;
		}
		keep public override function unshift(obj:T) {
			DEBUG(if(pr(inner).immutable) throw "Error: "+$str(T)+"List is immutable";)
			pr(inner).modify_test();
			
			pr(vm)();
			DEBUG(if(obj.pr(inner).inuse) throw "Error: "+$str(T)+" is already in use";)
			
			var cont = if(pr(inner).adder!=null) pr(inner).adder(obj) else true;
			if(cont) {
				if(pr(inner).reverse_flag) {
					var ite = inner.iterator_at(length-1);
					inner.insert(ite,erusolc(obj));
				}else
					inner.add(erusolc(obj));
				pr(inner).invalidate();
				
				if(pr(inner).post_adder!=null) pr(inner).post_adder(obj);
			}
			return cont;
		}
		
		keep public override function pop():T {
			DEBUG(if(pr(inner).immutable) throw "Error: "+$str(T)+"List is immutable";)
			pr(inner).modify_test();
			DEBUG(if(empty()) throw "Error: Cannot remove from empty list";)
			pr(vm)();
			
			var ret = null;
			if(pr(inner).reverse_flag) {
				ret = inner.front();
				var retx = closure(ret);
				if(pr(inner).subber!=null) pr(inner).subber(retx);
				if(!pr(inner).dontremove)
					inner.pop();
			}else {
				if(at_ite!=null && at_ite.next == null) at_ite = null;
				var ite = length==1 ? null : inner.iterator_at(length-2);
				ret = ite == null ? inner.front() : ite.next.elem();
				var retx = closure(ret);
				if(pr(inner).subber!=null) pr(inner).subber(retx);
				if(!pr(inner).dontremove)
					inner.erase(ite);
			}
			
			pr(inner).invalidate();
			var retx = closure(ret);
			return retx;
		}
		keep public override function shift():T {
			DEBUG(if(pr(inner).immutable) throw "Error: "+$str(T)+"List is immutable";)
			pr(inner).modify_test();
			DEBUG(if(empty()) throw "Error: Cannot remove from empty list";)
			pr(vm)();
			
			var ret = null;
			if(pr(inner).reverse_flag) {
				if(at_ite!=null && at_ite.next == null) at_ite = null;
				var ite = length==1 ? null : inner.iterator_at(length-2);
				ret = ite == null ? inner.front() : ite.next.elem();
				var retx = closure(ret);
				if(pr(inner).subber!=null) pr(inner).subber(retx);
				if(!pr(inner).dontremove)
					inner.erase(ite);
			}else {
				ret = inner.front();
				var retx = closure(ret);
				if(pr(inner).subber!=null) pr(inner).subber(retx);
				if(!pr(inner).dontremove)
					inner.pop();
			}
			
			pr(inner).invalidate();
			var retx = closure(ret);
			return retx;
		}
		
		keep public override function remove(obj:T):Bool {
			DEBUG(if(pr(inner).immutable) throw "Error: "+$str(T)+"List is immutable";)
			pr(inner).modify_test();
			
			pr(vm)();
			
			var ret = Exists(x,inner,erusolc(obj)==x);
			if(ret) {
				if(pr(inner).subber!=null) pr(inner).subber(obj);
				if(!pr(inner).dontremove)
					inner.remove(erusolc(obj));
				pr(inner).invalidate();
			}
			return ret;
		}

        keep public override function clear() {
            DEBUG(if(pr(inner).immutable) throw "Error: "+$str(T)+"List is immutable";)
            if(pr(inner).reverse_flag) {
                while(!empty()) pop();
            }else {
                while(!empty()) shift();
            }
        }
	}
);

$(expand global PRWrapList(T,ListT,IteT,USE_ARRAYS)
	class PR(T`List) {
		public var outer:T`List;
		
		public var inner:ListT;
		public var immutable:Bool;
		
		public var _invalidated:Bool;
		public var _invalidate:PR(T`List)->Dynamic;
		public var _validate:Void->Dynamic;
		public var _modifiable:Void->Dynamic;
		
		public var iterators:ArrayList(T`Iterator);
		public static var internal:Bool = false; //used to prevent instantiation of iterator type
		
		//to be called when object is added/removed
		public var adder:T->Bool; public var post_adder:T->Dynamic;
		public var subber:T->Dynamic;

		//mark that subber must deal with removing from list, not the public list.
		public var dontremove:Bool;
		
		//used for transparent reversal of list
		public var reverse_flag:Bool;

		flibstaticdel(get) public static function get(list:ListT,?imm:Bool=false) {
			var ret = new T`List();
			ret.pr(inner).inner = list;
			if(imm) ret.pr(inner).immutable = true;
			ret.pr(inner).inv(length) = true;
			return ret;
		}
		
		public function valmod() {
			validate();
			if(inner.modified) {
				DEBUG(if(iterators!=null) {
					Iter(i,iterators,{
						if(i.pr(critical)) throw "Error: Lists should never be modified once hasNext() has been called, and before next() has been called on iterators to the list as it is not defined behaviour. In this case it appears that you are using api functions that modify this list between hasNext() and next() calls which bypass the usual checks.";
					});
				})
				
				#if !USE_ARRAYS if(inner.pushmod) push_ite = null; #end
				at_ite = inner.prebegin();
				length += inner.mcnt;
				
				inner.modified = false;
				#if !USE_ARRAYS inner.pushmod = false; #end
				inner.mcnt = 0;
				inv(length) = true;
			}
		}
		
		public function modified() {
			inv(length) = true;
			at_ite = inner.prebegin();
			#if !USE_ARRAYS push_ite = null; #end
		}
		public function modify_test() {
			DEBUG(
				if(_modifiable!=null) _modifiable();
			
				if(iterators!=null) {
					Iter(i,iterators,{
						if(i.pr(critical)) throw "Error: Lists should never be modified once hasNext() has been called, and before next() has been called on iterators to the list as it is not defined behaviour";
					});
				}
			)
		}
		
		public function validate() {
			if(_invalidated) {
				_invalidated = false;
				if(_validate!=null) _validate();
			}
		}
		public function invalidate() {
			_invalidated = true;
			if(_invalidate!=null) _invalidate(this);
		}
		
		public var at_index:Int;
		public var at_ite:IteT;
		
		#if !USE_ARRAYS public var push_ite:IteT; #end
		
		public var length:Int;
		public var inv(length):Bool;
		
		public var user_length:Int; //may differ from 'real' length
		
		public function new() {
			inner = new ListT();
		}
	}
);

//--------------------------------------------------------------------------------------------------

$(mixin global MixArrayNode(T)
	#if NAPE_ARRAYS
		Int
	#else
		T
	#end
);

$(mixin global MixListMixin(T) MixListMixin(T,false));
$(mixin global MixListMixin(T,USE_ARRAY)
	#if !USE_ARRAY
		public var next:T;
		flibmdel public inline function elem () return this
	#else
		public var elts:ARRAY(T);
	#end

	flibmdel public inline function mixlist_new() {
		#if USE_ARRAY
			elts = new ARRAY(T)();
		#end	
	}

	flibmdel public inline function begin() {
		#if !USE_ARRAY
			return next;
		#else
			return 0;
		#end
	}
	
	public var inuse:Bool;
	
	ListMixin(
		//for LL
		$(mixin _setbeg(i) next=i);
		$(mixin _new(o) { o.inuse = true; o; });
		$(mixin _delete(o) {});
		//both
		$(mixin _delelt(o) { o.inuse = false; });
		$(mixin _clear false);
	,
		T,T,#if USE_ARRAY Int #else T #end,USE_ARRAY
	)
);
$(mixin global MixList(T) T);

//--------------------------------------------------------------------------------------------------


$(mixin global ListMixin(defs,Cons,T,I) ListMixin(defs,Cons,T,I,false));
$(mixin global ListMixin(defs,Cons,T,I,USE_ARRAY)
	defs
	
	public var modified:Bool;
	#if !USE_ARRAY
		public var pushmod:Bool;
	#end
	public var mcnt:Int;

	#if !USE_ARRAY
		//actual length of list, for wrapped lists wrap list length may not correspond.
		public var _length:Int;
	#end

	#if !USE_ARRAY
		flibmdel public inline function set_begin(i:I) {
			_setbeg(i);
			modified = true;
			pushmod = true;
		}
	#end

	#if USE_ARRAY
		flibmdel public inline function push(o:T) {
			elts.push(o);
			modified = true;
			mcnt++;
			return 0;
		}
		flibmdel public inline function unshift(o:T) {
			elts.unshift(o);
			modified = true;
			mcnt++;
			return 0;
		}
	#end

	public function add(o:T) return inlined_add(o)
    flibmdel public inline function inlined_add(o:T) {
		assert(o!=null && !has(o),"[ListMixin("+$str(T)+"] add -> o="+o);
	
		#if USE_ARRAY
			elts.push(o);
			modified = true;
			mcnt++;
			return o;
		#else
	        var temp = _new(o);
	        temp.next = begin();
	        _setbeg(temp);
			
			modified=true;
			mcnt++;
			_length++;
			return o;
		#end
    }

    public function addAll(x:Cons) {
		assert(x!=null,"[ListMixin("+$str(T)+"] addAll -> "+x);
		Iterate(x,add);
	}

	public function insert(cur:I,o:T) return inlined_insert(cur,o)
	flibmdel public inline function inlined_insert(cur:I,o:T) {
		assert(o != null && !has(o),"[ListMixin("+$str(T)+"] cur -> "+cur+" -> "+o);
	
		#if USE_ARRAY
			assert(false,"Array list shouldn't be using insert");
			return -1;
		#else	
			var temp = _new(o);
	        if(cur==null) {
				temp.next = begin();
				_setbeg(temp);
			} else {
	            temp.next = cur.next;
	            cur.next = temp;
	        }
	
			pushmod = modified = true;
			mcnt++;
			_length++;
			return temp;
		#end
    }

    //----------------------------------------------------------------------------------------------

	public function pop() inlined_pop()
    flibmdel public inline function inlined_pop():Void {
		assert(!empty(), "[ListMixin("+$str(T)+"] pop");
	
		#if USE_ARRAY
			elts.pop();
			modified = true;
			mcnt--;
		#else
	        var ret = begin();
	        _setbeg(ret.next);
	        _delelt(ret.elem());
	        _delete(ret);
			
			if(empty()) pushmod = true;
			modified = true;
			mcnt--;
			_length--;
		#end
    }

	public function pop_unsafe() return inlined_pop_unsafe()
    flibmdel public inline function inlined_pop_unsafe():T {
		assert(!empty(), "[ListMixin("+$str(T)+"] pop_unsafe");
		
		#if USE_ARRAY
			modified = true;
			mcnt--;
			return elts.pop();
		#else
	        var ret = front();
	        pop();
	        return ret;
		#end
    }

    //----------------------------------------------------------------------------------------------

    public function remove(obj:T):Bool {
		assert(obj!=null && has(obj), "[ListMixin("+$str(T)+"] remove -> "+obj);
	
		#if USE_ARRAY
			return inlined_remove(obj);
		#else
	        var pre = null;
	        var cur = begin();
	        var ret = false;
	        while(cur!=null) {
	            if(cur.elem()==obj) {
	                erase(pre);
	                ret = true;
	                break;
	            }
	            pre = cur;
	            cur = cur.next;
	        }
	        return ret;
		#end
    }

    flibmdel public inline function inlined_remove(obj:T):Bool {
		assert(obj!=null && has(obj), "[ListMixin("+$str(T)+"] remove -> "+obj);
	
		#if USE_ARRAY
			var ret = false;
			for(i in 0...elts.length) {
				var cur = elts[i];
				if(cur==obj) {
					elts[i] = elts[elts.length-1];
					elts.pop();
					_delelt(cur);
					ret = true;
					break;
				}
			}
			return ret;
		#else
	        var pre = null;
	        var cur = begin();
	        var ret = false;
	        while(cur!=null) {
	            if(cur.elem()==obj) {
	                inlined_erase(pre);
	                ret = true;
	                break;
	            }
	            pre = cur;
	            cur = cur.next;
	        }
	        return ret;
		#end
    }

	public function erase(pre:I):I return inlined_erase(pre)
    flibmdel public inline function inlined_erase(pre:I):I {
		assert(!empty(),"[ListMixin("+$str(T)+"] erase -> "+pre);
		#if USE_ARRAY
			var old = elts[pre+1];
			elts[pre+1] = elts[elts.length-1];
			elts.pop();
			_delelt(old);

			modified = true;
			mcnt--;

			return pre+1;
		#else
			var old:I;
			var ret:I;
			if(pre==null) {
		        old = begin(); ret = old.next;
		        _setbeg(ret);
				if(empty()) pushmod = true;
			} else {
				old = pre.next; ret = old.next;
				pre.next = ret;
				if(ret==null) pushmod = true;
			}
			_delelt(old.elem());
			_delete(old);
	
			modified = true;
			mcnt--;
			_length--;
			pushmod = true;
			return ret;
		#end
    }

    public function splice(pre:I,n:Int):I {
		#if USE_ARRAY
			assert(false,"Array list shouldn't be using splice");
			return -1;
		#else
	        while(n-->0 && pre.next!=null) erase(pre);
	        return pre.next;
		#end
    }

    public function clear() {
        if(_clear) {
            while(!empty()) pop();
			#if !USE_ARRAY pushmod = true; #end
        }
    }

    //----------------------------------------------------------------------------------------------

    public function reverse() {
		#if USE_ARRAY
			assert(false,"Array list shouldn't be using reverse");
		#else
	        var cur = begin();
	        var pre = null;
	        while(cur!=null) {
	            var nx = cur.next;
	            cur.next = pre;
	            _setbeg(cur);
	            pre = cur;
	            cur = nx;
	        }
			modified = true;
			pushmod = true;
		#end
    }

    //----------------------------------------------------------------------------------------------

	flibmdel public inline function empty():Bool return size()==0
	flibmdel public inline function size():Int {
		#if USE_ARRAY
			return elts.length;
		#else
			return _length;
		#end
	}

    public function has(obj:T) {
		assert(obj!=null,"[ListMixin("+$str(T)+"] has -> "+obj);
		return Exists(npite, this, npite==obj);
	}

    //----------------------------------------------------------------------------------------------

	flibmdel public inline function front() {
		#if USE_ARRAY
			return elts[0];
		#else
			return begin().elem();
		#end
	}

    #if USE_ARRAY flibmdel inline #end public function back() {
		#if USE_ARRAY
			return elts[elts.length-1];
		#else
	        var ret = begin();
	        var cur = ret;
	        while(cur!=null) { ret = cur; cur = cur.next; }
	        return ret.elem();
		#end
    }

	//ind = -1 is valid, and gives null.
	#if USE_ARRAY flibmdel inline #end public function iterator_at(ind:Int) {
		assert(ind>=-1 && ind<size(),"[ListMixin("+$str(T)+"] iterator_at -> "+ind);
		#if USE_ARRAY
			return ind;
		#else
	        var ret = begin();
	        while(ind-->0 && ret!=null) ret = ret.next;
	        return ret;
		#end
    }
	
	#if USE_ARRAY flibmdel inline #end public function at(ind:Int) {
		assert(ind>=0 && ind<size(),"[ListMixin("+$str(T)+"] at -> "+ind);
		#if USE_ARRAY
			return elts[ind];
		#else
        	var it = iterator_at(ind);
	        return if(it!=null) it.elem() else null;
		#end
    }

    //----------------------------------------------------------------------------------------------

	flibmdel public inline function getnext(i:I):I {
		return #if USE_ARRAY i+1 #else i.next #end;
	}
	flibmdel public inline function getelem(i:I):T {
		return #if USE_ARRAY elts[i] #else i.elem() #end;
	}
	flibmdel public inline function prebegin():I {
		return #if USE_ARRAY -1 #else null #end;
	}
	flibmdel public inline function end():I {
		return #if USE_ARRAY elts.length #else null #end;
	}
);

//--------------------------------------------------------------------------------------------------

$(mixin global Insert(i,list,less) {
	var pre = list.prebegin();
	Iter(j,list,{
		if(less(i,j))
			cx_break;
		pre = cx_ite;
	});
	list.insert(pre,i);
});

$(mixin global RealArraySort(L,T,lt) {
	L.elts.sort(function (x:T,y:T) return if(lt(x,y)) -1 else 1);
});

$(mixin global Sort(L,NodeT, lt) {
	var xxlist = L;
	if(!xxlist.empty() && xxlist.begin().next!=null) {
		var head:NodeT = xxlist.begin();
		var tail:NodeT = null; var left:NodeT = null;
		var right:NodeT = null; var nxt:NodeT = null;
		var listSize = 1; var numMerges:Int, leftSize:Int, rightSize:Int;
		do {
			numMerges = 0; left = head; tail = head = null;
			while(left!=null) {
				numMerges++; right = left; leftSize = 0; rightSize = listSize;
				//cut list
				while(right!=null && leftSize<listSize) { leftSize++; right = right.next; }
				//merge lists
				while(leftSize>0 || (rightSize>0 && right!=null)) {
					if  (leftSize==0)                 { nxt=right; right=right.next; rightSize--; }
					elif(rightSize==0 || right==null) { nxt=left;  left =left .next; leftSize --; }
					elif(lt(left.elem(),right.elem())){ nxt=left;  left = left.next; leftSize --; }
					else                              { nxt=right; right=right.next; rightSize--; }

					if(tail!=null) tail.next = nxt;
					else           head = nxt;

					tail = nxt;
				}
				left=right;
			}
			tail.next=null; listSize<<=1;
		} while(numMerges>1);

		xxlist.set_begin(head);
	}
});

//--------------------------------------------------------------------------------------------------

$(mixin global Exists(i,list,predicate) ({
	var ret = false;
	Iter(i,list,{
		if($predicate) {
			ret = true;
			break;
		}
	});
	ret;
}));

$(mixin global ForAll(i,list,predicate) (!Exists(i,list,!($predicate))));

//--------------------------------------------------------------------------------------------------

$(mixin global ClearWith(i,list,closure) {
	while(!list.empty()) {
		var i = list.pop_unsafe();
		closure;
	}
});

//--------------------------------------------------------------------------------------------------

$(mixin global Iter(i,list,closure) IterIte(i,list,list.begin(),closure));
$(mixin global IterIte(i,list,listite,closure) ${->
	var cx_ite = listite;
	while(cx_ite != list.end()) {
		var i = list.getelem(cx_ite);
		
		$(mixin cx_continue { cx_ite = list.getnext(cx_ite); continue; });
		$(mixin cx_break break);
		$(cx_continue,cx_break->closure);

		cx_ite = list.getnext(cx_ite);
	}
});
$(mixin global Iterate(list,closure) IterateIte(list,list.begin(),closure));
$(mixin global IterateIte(list,listite,closure) IterIte(i,list,listite,closure(i)));

$(mixin global IterCycleFull(i,list,listite,closure) ${IterCycle/4->
	IterCycle(i,list,listite,closure);
	do {
		var cx_ite = listite;
		var i = cx_ite.elem();
		$(mixin cx_continue break);
		$(mixin cx_break break);
		closure;
	}while(false);
});

$(mixin global IterCycle(i,list,listite,closure) ${->
	var beg_ite = listite;
	var cx_ite = listite;
	$(mixin cx_continue { cx_ite = cx_ite.next; if(cx_ite==null) cx_ite = list.begin(); continue; });
	$(mixin cx_break { cx_ite = beg_ite; break; });
	do {
		var i = cx_ite.elem();
		$(cx_continue,cx_break->closure);
		cx_ite = cx_ite.next; if(cx_ite==null) cx_ite = list.begin();
	}while(false);
	while(cx_ite != beg_ite) {
		var i = cx_ite.elem();
		$(cx_continue,cx_break->closure);
		cx_ite = cx_ite.next; if(cx_ite==null) cx_ite = list.begin();
	}
});

$(mixin global CycleNext(list,cur) ${-> 
	if(cur.next==null) list.begin() else cur.next;
});

//--------------------------------------------------------------------------------------------------

$(mixin global Iter2(i,j,list,closure) ${->
	var cx_cont = true;
	var cx_itei = list.begin();
	var i = cx_itei.elem();
	var cx_itej = cx_itei.next;
	
	while(cx_itej!=null) {
		var j = cx_itej.elem();
		$(mixin cx_continue { cx_next; continue; });
		$(mixin cx_break { cx_cont = false; break; });
		$(cx_continue,cx_break->closure);
		
		$(mixin cx_next {
			cx_itei = cx_itej; i = j;
			cx_itej = cx_itej.next;
		});
		cx_next;
	}
	
	if(cx_cont) {
		do {
			cx_itej = list.begin();
			var j = cx_itej.elem();
			$(mixin cx_continue break);
			$(mixin cx_break break);
			$(cx_continue,cx_break->closure);
		}while(false);
	}
});

$(mixin global Iter2_noite(i,j,list,closure) ${->
	var cx_cont = true;
	var cx_ite = list.begin();
	var i = cx_ite.elem();
	cx_ite = cx_ite.next;
	
	while(cx_ite!=null) {
		var j = cx_ite.elem();
		$(mixin cx_continue { cx_next; continue; });
		$(mixin cx_break { cx_cont = false; break; });
		$(cx_continue,cx_break->closure);
		
		$(mixin cx_next {
			i = j;
			cx_ite = cx_ite.next;
		});
		cx_next;
	}
	
	if(cx_cont) {
		do {
			var j = list.front();
			$(mixin cx_continue break);
			$(mixin cx_break break);
			$(cx_continue,cx_break->closure);
		}while(false);
	}
});

$(mixin global Iter2_fast(i,j,list,closure) ${->
	var cx_ite = list.begin();
	var i = cx_ite.elem();
	cx_ite = cx_ite.next;
	
	while(cx_ite!=null) {
		var j = cx_ite.elem();
		$closure;
		i = j;
		cx_ite = cx_ite.next;
	}
	
	var j = list.front();
	$closure;
});

//--------------------------------------------------------------------------------------------------

$(mixin global Iter3(i,j,k,list,closure) ${->
	var cx_cont = true;
	var cx_itei = list.begin();
	var i = cx_itei.elem();
	var cx_itej = cx_itei.next;
	var j = cx_itej.elem();
	var cx_itek = cx_itej.next;
	
	while(cx_itek!=null) {
		var k = cx_itek.elem();
		$(mixin cx_continue { cx_next; continue; });
		$(mixin cx_break { cx_cont = false; break; });
		$(cx_continue,cx_break->closure);

		cx_next;
	}
	
	$(mixin cx_next {
		cx_itei = cx_itej; cx_itej = cx_itek;
		i = j; j = k;
		cx_itek = cx_itek.next;
	});
	
	if(cx_cont) {
		cx_itek = list.begin();
		var k = cx_itek.elem();
		do {
			$(mixin cx_continue break);
			$(mixin cx_break { cx_cont = false; break; });
			$(cx_continue,cx_break->closure);
		}while(false);
		
		if(cx_cont) {
			cx_next;
			var k = cx_itek.elem();
			do {
				$(mixin cx_continue break);
				$(mixin cx_break break);
				$(cx_continue,cx_break->closure);
			}while(false);
		}
	}
});

$(mixin global Iter3_noite(i,j,k,list,closure) ${->
	var cx_cont = true;
	var cx_ite = list.begin();
	var i = cx_ite.elem();
	cx_ite = cx_ite.next;
	var j = cx_ite.elem();
	cx_ite = cx_ite.next;
	
	while(cx_ite!=null) {
		var k = cx_ite.elem();
		$(mixin cx_continue { cx_next; continue; });
		$(mixin cx_break { cx_cont = false; break; });
		$(cx_continue,cx_break->closure);
		
		cx_next;
	}
	
	$(mixin cx_next {
		i = j; j = k;
		cx_ite = cx_ite.next;
	});
	
	if(cx_cont) {
		cx_ite = list.begin();
		var k = cx_ite.elem();
		do {
			$(mixin cx_continue break);
			$(mixin cx_break { cx_cont = false; break; });
			$(cx_continue,cx_break->closure);
		}while(false);
		
		if(cx_cont) {
			cx_next;
			var k = cx_ite.elem();
			do {
				$(mixin cx_continue break);
				$(mixin cx_break break);
				$(cx_continue,cx_break->closure);
			}while(false);
		}
	}
});

$(mixin global Iter3_fast(i,j,k,list,closure) ${->
	var cx_ite = list.begin();
	var i = cx_ite.elem();
	cx_ite = cx_ite.next;
	var j = cx_ite.elem();
	cx_ite = cx_ite.next;
	
	while(cx_ite!=null) {
		var k = cx_ite.elem();
		$closure;
		i = j; j = k;
		cx_ite = cx_ite.next;
	}
	
	cx_ite = list.begin();
	var k = cx_ite.elem();
	$closure;
	
	i = j; j = k;
	cx_ite = cx_ite.next;
	var k = cx_ite.elem();
	$closure;
});
