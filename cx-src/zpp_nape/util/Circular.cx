package zpp_nape.util;
$(import);

// circular doubly linked list
// there is no 'head' to the list, and 'null' is a valid list
// representing an empty list.
// for these reasons, 'methods' are mixins.

$(mixin global Circular(T)
	genCircular(T)
	ZPP_Circular_`T
);

$(expand global genCircular(T) class ZPP_Circular_`T {
	MixPool(Circular(T))
	flibmdel public inline function free() {
		elt = null;
	}
	flibmdel public inline function alloc() {}

	public var prev:Circular(T);
	public var elt:T;

	public function new(obj:T) {
		elt = obj;
	}
});

$(mixin global circular(block)
	block

	//------------------------------------------------------------------------------------

	//insert obj before node, return object.
	//NOTE: node must be mutable and pure!!
	$(mixin push_before(T, node, O) {
		var obj = new Circular(T)(O);

		if(node==null)
			node = obj.prev = obj.next = obj;
		else {
			obj.next = node;
			obj.prev = node.prev;
			node.prev.next = obj;
			node.prev = obj;
		}

		obj;
	});

	//insert obj after node, return object.
	//NOTE: node must be mutable and pure!!
	$(mixin push_after(T, node, O) {
		var obj = new Circular(T)(O);

		if(node==null)
			node = obj.prev = obj.next = obj;
		else {
			obj.prev = node;
			obj.next = node.next;
			node.next.prev = obj;
			node.next = obj;
		}

		obj;
	});

	//------------------------------------------------------------------------------------

	//pop element and return element which preceeded it
	$(mixin pop_ret_before(T, node) {
		assert(!empty(node), "can't pop from empty list derpiderp");
		if(singular(node)) {
			node.next = node.prev = null;
			Free(Circular(T),node);
			null;
		}else {
			var ret = node.prev;
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = node.prev = null;
			Free(Cicular(T),node);
			ret;
		}
	});

	//pop element and return element which suceeded it
	$(mixin pop_ret_after(T,node) {
		assert(!empty(node), "can't pop from empty list herpaderp");
		if(singular(node)) {
			node.next = node.prev = null;
			Free(Circular(T),node);
			null;
		}else {
			var ret = node.next;
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = node.prev = null;
			Free(Circular(T),node);
			ret;
		}
	});

	$(mixin pop(T,node) {
		assert(!empty(node), "can't pop from empty list herpaderp");
		if(singular(node)) {
			node.next = node.prev = null;
			Free(Circular(T),node);
		} else {
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = node.prev = null;
			Free(Circular(T),node);
		}
	});

	$(mixin clear(T,node) {
		while(!empty(node)) node = pop_ret_after(T,node)
	});

	//------------------------------------------------------------------------------------

	$(mixin empty(node) (
		#if NAPE_ASSERT
			{ var ret = node==null; assert(!ret || (node.next==node.prev && node.next==null), "empty list isn't empty"); ret; }
		#else
			node==null
		#end
	));
	$(mixin singular(node) (
		#if NAPE_ASSERT
			{ var ret = node.next==node.prev; assert(!ret || node.next==node, "singular list isn't circular?"); ret; }
		#else
			node.next==node.prev
		#end
	));

	//------------------------------------------------------------------------------------

	$(mixin private_iter(i,first,last,dir,closure) {
		if(first!=null) {
			var n = first;
			do {
				var i = n.elt;
				{
					closure;
				}
				n = n.dir;
			} while(n!=last);
		}
	});

	$(mixin for_iter(i,first,last,closure) private_iter(i,first,last,next,closure));
	$(mixin for_iter(i,list,closure) for_iter(i,list,list,closure));

	$(mixin rev_iter(i,first,last,closure) private_iter(i,first,last,prev,closure));
	$(mixin rev_iter(i,list,closure) rev_iter(i,list,list,closure));

	$(mixin size(node) ({ var ret = 0; for_iter(i,node,ret++); ret; }));

	//===================================================================================

	$(mixin select(node,lt) ({
		if(empty(node)) null;
		else {
			var ret = node;
			var i = node.next;
			while(i!=node) {
				if(lt(i.elt,ret.elt)) { ret = i; }
				i = i.next;
			}
			ret;
		}
	}));

	//===================================================================================

	//sort list using L as a pivot.
	//returning the smallest element as given by 'lt'
	$(mixin sort(T,L,lt) {
	var list = L;
	if(!empty(list) && !singular(list)) {
		//break circular list temporarily
		list.prev.next = null;
		list.prev = null;
		//sort as a standard doubly linked list
		var tail:Circular(T) = null; var left:Circular(T) = null;
		var right:Circular(T) = null; var nxt:Circular(T) = null;
		var listSize = 1; var numMerges:Int, leftSize:Int, rightSize:Int;
		do {
			numMerges = 0; left = list; tail = list = null;
			while(left!=null) {
				numMerges++; right = left; leftSize = 0; rightSize = listSize;
				//cut list
				while(right!=null && leftSize<listSize) { leftSize++; right = right.next; }
				//merge lists
				while(leftSize>0 || (rightSize>0 && right!=null)) {
					if  (leftSize==0)                 { nxt=right; right=right.next; rightSize--; }
					elif(rightSize==0 || right==null) { nxt=left;  left =left .next; leftSize --; }
					elif(lt(left.elt,right.elt))      { nxt=left;  left = left.next; leftSize --; }
					else                              { nxt=right; right=right.next; rightSize--; }

					if(tail!=null) tail.next = nxt;
					else           list = nxt;

					nxt.prev = tail;
					tail = nxt;
				}
				left=right;
			}
			tail.next=null; listSize<<=1;
		} while(numMerges>1);
		//reform circular list
		list.prev = tail;
		tail.next = list;
	}
	});

);
