package zpp_nape.util;
$(import);

/**

	Intrusive object pooling.
	
	class Type {
		MixPool(Type) //or MixPoolNoNext(Type) if Type already has a field 'next' of type Type
	}
	
	Get (Type)      ; retrieve object from pool, or instantiate new one if empty.
	Free(Type, obj) ; free object to pool
	
	NECESSARY REQUIREMENT: Type has an empty (or possibly empty) constructor.

**/

//for public API types.
$(mixin global PublicMixPool(T)
	public var pr(pool):T;
	DEBUG(public var pr(disp):Bool;)
	PublicMixPoolNoNext(T)
);
$(mixin global PublicMixPoolNoNext(T)
	PUBSTATS(T)
	PUBCLEARPOOL(T)
	PUBLICPOOL(T)
);

$(mixin global PRDestroyed(o,T) { DEBUG(
	if(o!=null && o.outer==null) throw "Error: "+$str(T)+" has been destroyed and cannot be used!";
)});

$(mixin global Destroyed(o,T) { DEBUG(
	if(o!=null && o.pr(inner)==null) throw "Error: "+$str(T)+" has been destroyed and cannot be used!";
)});
$(mixin global Destroyed(o,T,innert) { DEBUG(
	if(o!=null && o.innert==null) throw "Error: "+$str(T)+" has been destroyed and cannot be used!";
)});

class PR(PubPool) {
	$(expand file PUBLICPOOL(T)
		public static var pool`T:T = null;
		//for public pool want a disposed Vec2 to go to the BACK of the stack
		//so that it is more likely if they have any semantic errors on using a disposed Vec2
		//they are more likely to be caught! (only in DEBUG mode)
		DEBUG(public static var next`T:T = null;)
	);
}

//------------------------------------------------

//for inner types.
$(mixin global MixPool(T)
	public var next:T;
	MixPoolNoNext(T)
);
$(mixin global MixPoolNoNext(T)
	static public var pr(pool):T;

	STATS(T)
	CLEARPOOL(T)
);

$(expand PUBSTATS(T)
DEBUG(
	class ZPP_`STATS`T {
		static public var POOL_CNT:Int = 0;
		static public var POOL_GET:Int = 0;
		static public var POOL_FREE:Int = 0;
		POOLSTATS(T,ZPP_`STATS`T)
	}
));

$(mixin STATS(T)
	DEBUG(
		static public var POOL_CNT:Int = 0;
		static public var POOL_GET:Int = 0;
		static public var POOL_FREE:Int = 0;
		POOLSTATS(T,T)
	)
);

//-------------------------------------------

//for public API types
$(mixin global PublicGet(T) {
	var ret:T;
	DEBUG(PR(STATS`T).POOL_GET++;)
	if(PR(PubPool).pool`T==null)
		ret = new T();
	else {
		ret = PR(PubPool).pool`T;
		PR(PubPool).pool`T = ret.pr(pool);
		ret.pr(pool) = null;
		DEBUG(
			if(ret==PR(PubPool).next`T)
				PR(PubPool).next`T = null;
		)
		DEBUG(PR(STATS`T).POOL_CNT--;)
	}
	ret;
});

$(mixin global Get(T) {
	var ret:T;
	DEBUG(T.POOL_GET++;)
	if(T.pr(pool)==null)
		ret = new T();
	else {
		ret = T.pr(pool);
		T.pr(pool) = ret.next;
		ret.next = null;
		DEBUG(T.POOL_CNT--;)
	}
	ret.alloc();
	ret;
});

$(mixin global PublicFree(T,O) {
	var o = O;
	assert(o!=null, "PublicFree(in T: "+$str(T)+", in obj: "+$str(O)+")");
	DEBUG(PR(STATS`T).POOL_FREE++;)
	DEBUG(
		o.pr(pool) = null;
		if(PR(PubPool).next`T!=null)
			PR(PubPool).next`T.pr(pool) = o;
		else
			PR(PubPool).pool`T = o;
		PR(PubPool).next`T = o;
	)
	RELEASE(
		o.pr(pool) = PR(PubPool).pool`T;
		PR(PubPool).pool`T = o;
	)
	DEBUG(PR(STATS`T).POOL_CNT++;)
});

$(mixin global Free(T,O) {
	var o = O;
	DEBUG(T.POOL_FREE++;)
	assert(o!=null, "Free(in T: "+$str(T)+", in obj: "+$str(O)+")");
	o.free();
	o.next = T.pr(pool);
	T.pr(pool) = o;
	DEBUG(T.POOL_CNT++;)
});
