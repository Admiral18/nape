package zpp_nape.util;
$(import);

#if ogl

import ogl.GL;
import ogl.GLArray;
import ogl.GLM;

class PR(OGLDebug) extends PR(Debug) {
    public var outer_zn:OGLDebug = null;

    static inline var VERTEX_SIZE = 6; // x, y, r, g, b, a

    var vertexData:GLfloatArray;
    var vertexArray:Int;
    var vertexBuffer:Int;
    var numVertices:Int = 0;

    var program:Int;
    var proj:Int;
    var projMatrix:Mat3x2;

    public function new(width:Int, height:Int) {
        super(width, height);
        type = 2;
        d_ogl = this;

        vertexData = GL.allocBuffer(GL.FLOAT, VERTEX_SIZE*2);
        vertexArray = GL.genVertexArrays(1)[0];
        GL.bindVertexArray(vertexArray);

        vertexBuffer = GL.genBuffers(1)[0];
        GL.bindBuffer(GL.ARRAY_BUFFER, vertexBuffer);
        GL.bufferData(GL.ARRAY_BUFFER, vertexData, GL.DYNAMIC_DRAW);

        var vertexShader = GL.createShader(GL.VERTEX_SHADER);
        var fragmentShader = GL.createShader(GL.FRAGMENT_SHADER);
        GL.shaderSource(vertexShader, "
            #version 330 core\n
            layout(location = 0) in vec2 vPos;
            layout(location = 1) in vec4 vColour;
            uniform mat3x2 proj;
            out vec4 colour;
            void main() {
                gl_Position = vec4(proj * vec3(vPos, 1), 0, 1);
                colour = vColour;
            }
        ");
        GL.shaderSource(fragmentShader, "
            #version 330 core\n
            in vec4 colour;
            out vec4 outColour;
            void main() {
                outColour = colour;
            }
        ");
        GL.compileShader(vertexShader);
        GL.compileShader(fragmentShader);

        program = GL.createProgram();
        GL.attachShader(program, vertexShader);
        GL.attachShader(program, fragmentShader);
        GL.linkProgram(program);

        GL.deleteShader(vertexShader);
        GL.deleteShader(fragmentShader);

        proj = GL.getUniformLocation(program, "proj");
        projMatrix = Mat3x2.viewportMap(width, height);
    }

    inline function vertex(vindex:Int, off:Int, x:Float, y:Float, r:Float, g:Float, b:Float, a:Float, dup=false) {
        vindex += off*VERTEX_SIZE;
        if (dup) {
            vertexData[vindex]   = vertexData[vindex+VERTEX_SIZE]   = x;
            vertexData[vindex+1] = vertexData[vindex+VERTEX_SIZE+1] = y;
            vertexData[vindex+2] = vertexData[vindex+VERTEX_SIZE+2] = r;
            vertexData[vindex+3] = vertexData[vindex+VERTEX_SIZE+3] = g;
            vertexData[vindex+4] = vertexData[vindex+VERTEX_SIZE+4] = b;
            vertexData[vindex+5] = vertexData[vindex+VERTEX_SIZE+5] = a;
        }
        else {
            vertexData[vindex]   = x;
            vertexData[vindex+1] = y;
            vertexData[vindex+2] = r;
            vertexData[vindex+3] = g;
            vertexData[vindex+4] = b;
            vertexData[vindex+5] = a;
        }
    }

    public function drawLine(x1:Float, y1:Float, x2:Float, y2:Float, colour:Int) {
        var r = cred(colour); var g = cgrn(colour); var b = cblu(colour); var a = calp(colour);
        var vindex = reserve(2);
        vertex(vindex,0, x1,y1, r,g,b,a);
        vertex(vindex,1, x2,y2, r,g,b,a);
    }

    public function drawRectangle(x1:Float, y1:Float, x2:Float, y2:Float, colour:Int) {
        var r = cred(colour); var g = cgrn(colour); var b = cblu(colour); var a = calp(colour);
        var vindex = reserve(8);
        vertex(vindex,0, x1,y1, r,g,b,a);
        vertex(vindex,1, x2,y1, r,g,b,a, true);
        vertex(vindex,3, x2,y2, r,g,b,a, true);
        vertex(vindex,5, x1,y2, r,g,b,a, true);
        vertex(vindex,7, x1,y1, r,g,b,a);
    }

    public function drawCircle(x:Float, y:Float, radius:Float, colour:Int) {
        var r = cred(colour); var g = cgrn(colour); var b = cblu(colour); var a = calp(colour);
        var maxError = 0.5; // px
        var vCount;
        if (radius < maxError / 2) vCount = 3;
        else {
            // Error for given turn theta
            // E = r(1-cos(t/2))
            // We require E < maxError <=> t > 2.acos(1 - maxError/r)
            // Requiring pi/acos(1 - maxError/r) vertices
            vCount = Math.ceil(Math.PI / Math.acos(1 - maxError/radius));
            if (vCount < 3) vCount = 3;
        }

        var vindex = reserve(vCount * 2); //GL_LINES, must duplicate

        // Generate vertices via radial vector (radius, 0)
        var dx = radius;
        var dy = 0.0;

        var angInc = Math.PI * 2 / vCount;
        var cos = Math.cos(angInc);
        var sin = Math.sin(angInc);

        vertex(vindex, 0, x+radius,y, r,g,b,a);
        for (i in 1...vCount) {
            var nx = (dx * cos) - (dy * sin);
            dy = (dx * sin) + (dy * cos);
            dx = nx;
            vertex(vindex,i*2-1, x+dx,y+dy, r,g,b,a, true);
        }
        vertex(vindex,vCount*2-1, x+radius,y, r,g,b,a);
    }

    inline function reserve(numVerts:Int) {
        var current = numVertices * VERTEX_SIZE;
        var newsize = current + (numVerts * VERTEX_SIZE);
        if (newsize > vertexData.count) {
            var size = vertexData.count;
            do size *= 2 while (size < newsize);
            vertexData.resize(size);
            GL.bindBuffer(GL.ARRAY_BUFFER, vertexBuffer);
            GL.bufferData(GL.ARRAY_BUFFER, vertexData, GL.DYNAMIC_DRAW);
        }
        numVertices += numVerts;
        return current;
    }

    public function clear() {
        numVertices = 0;
    }

    public function flush() {
        GL.useProgram(program);
        GL.enableVertexAttribArray(0);
        GL.enableVertexAttribArray(1);

        GL.bindBuffer(GL.ARRAY_BUFFER, vertexBuffer);
        GL.vertexAttribPointer(0, 2, GL.FLOAT, false, VERTEX_SIZE*4, 0);
        GL.vertexAttribPointer(1, 4, GL.FLOAT, false, VERTEX_SIZE*4, 2*4);

        GL.bufferSubData(GL.ARRAY_BUFFER, 0, GLfloatArray.view(vertexData, 0, numVertices*VERTEX_SIZE));
        GL.uniformMatrix3x2fv(proj, false, projMatrix);
        GL.drawArrays(GL.LINES, 0, numVertices);

        GL.disableVertexAttribArray(0);
        GL.disableVertexAttribArray(1);

        clear();
    }

    inline function calp(c:Int) {
        var alp = (c&0xff000000)/(255*0x1000000);
        return alp == 0 ? 1 : alp;
    }
    inline function cred(c:Int) return (c&0x00ff0000)/(255*0x10000);
    inline function cgrn(c:Int) return (c&0x0000ff00)/(255*0x100);
    inline function cblu(c:Int) return (c&0x000000ff)/(255*0x1);





    public var compoundstack:List(PR(Compound)) = null;
    public function draw_compound(compound:PR(Compound),xform:PR(Mat23),xdet:Float,xnull:Bool) {
        Iter(c, compound.compounds, draw_compound(c,xform,xdet,xnull));
        Iter(b, compound.bodies, if (b.outer.debugDraw) draw_body(b,xform,xdet,xnull));
        Iter(c, compound.constraints, if (c.active && c.outer.debugDraw) c.draw(outer));
    }
    var shapeList:ShapeList = null;
    var bodyList:BodyList = null;
    public function draw_space(space:PR(Space),xform:PR(Mat23),xdet:Float,xnull:Bool) {
        if(outer.cullingEnabled) {
            if(outer.drawBodies) {
                if(outer.drawBodyDetail) {
                    var bods = bodyList = space.bphase.bodiesInAABB(iport,false,false,null,bodyList);
                    while(!bods.empty()) {
                        var b = bods.shift();
                        if (b.debugDraw)
                            draw_body(b.pr(inner),xform,xdet,xnull);
                    }
                }else {
                    var shapes = shapeList = space.bphase.shapesInAABB(iport,false,false,null,shapeList);
                    while(!shapes.empty()) {
                        var s = shapes.shift();
                        if (s.body.debugDraw)
                            draw_shape(s.pr(inner),xform,xdet,xnull);
                    }
                }
            }
        }else {
            if(outer.drawBodies) {
                if(compoundstack==null) compoundstack = new List(PR(Compound))();
                Iter(b, space.bodies, if (b.outer.debugDraw) draw_body(b,xform,xdet,xnull));
                Iter(c, space.compounds, compoundstack.add(c));
                while(!compoundstack.empty()) {
                    var x = compoundstack.pop_unsafe();
                    Iter(b, x.bodies, if (b.outer.debugDraw) draw_body(b,xform,xdet,xnull));
                    Iter(c, x.compounds, compoundstack.add(c));
                }
            }
        }

        if(outer.drawCollisionArbiters || outer.drawFluidArbiters || outer.drawSensorArbiters)
            for(arb in space.outer.arbiters) draw_arbiter(arb.pr(inner),xform,xdet,xnull);

        if(outer.drawConstraints) {
            if(compoundstack==null) compoundstack = new List(PR(Compound))();
            Iter(c, space.constraints, if(c.active && c.outer.debugDraw) c.draw(outer));
            Iter(c, space.compounds, compoundstack.add(c));
            while(!compoundstack.empty()) {
                var x = compoundstack.pop_unsafe();
                Iter(c, x.constraints, if(c.active && c.outer.debugDraw) c.draw(outer));
                Iter(c, x.compounds, compoundstack.add(c));
            }
        }
    }

    public function draw_body(body:PR(Body),xform:PR(Mat23),xdet:Float,xnull:Bool) {
        Iter(s,body.shapes, draw_shape(s,xform,xdet,xnull));
        if(outer.drawBodyDetail) {
            var col = __colour(body.id, body.space!=null && body.outer.isSleeping);
            var col2 = __tint(col,0xff0000,0.8);

            vec_new(p);
            vec_new(q);
            if (!body.shapes.empty())
            {
                body.validate_worldCOM();
                mat_xform_hom(xnull,xform,body.worldCOM,p);

                drawCircle(px,py, 1, col2);

                body.validate_aabb();
                drawRectangle(body.aabb.minx, body.aabb.miny, body.aabb.maxx, body.aabb.maxy, col2);
            }

            mat_xform_hom(xnull,xform,body.pre_pos,q);
            mat_xform_hom(xnull,xform,body.pos,p);
            drawLine(qx,qy, px,py, col2);
            drawCircle(px,py, 1, col2);
        }
    }

    public function draw_shape(shape:PR(Shape),xform:PR(Mat23),xdet:Float,xnull:Bool) {
        var col = __colour(shape.id,false);
        var body = shape.body;
        if(body!=null) {
            var bcol = __colour(body.id, body.space!=null && body.outer.isSleeping);
            col = __tint(col,bcol,0.2);

            if(shape.isCircle()) {
                var circ = shape.circle;
                circ.validate_worldCOM();
                var vx = circ.worldCOMx;
                var vy = circ.worldCOMy;
                mat_xform_hom(xnull,xform,v);
                drawCircle(vx,vy, circ.radius*xdet, col);

                if(outer.drawShapeAngleIndicators) {
                    var v0x = circ.worldCOMx + 0.3*circ.radius*body.axisy;
                    var v0y = circ.worldCOMy + 0.3*circ.radius*body.axisx;
                    var v1x = circ.worldCOMx + circ.radius*body.axisy;
                    var v1y = circ.worldCOMy + circ.radius*body.axisx;

                    mat_xform_hom(xnull,xform,v0);
                    mat_xform_hom(xnull,xform,v1);
                    drawLine(v0x,v0y, v1x,v1y, col);
                }
            }else {
                var poly = shape.polygon;
                poly.validate_gverts();

                var u = poly.gverts.front();
                var vx = u.x;
                var vy = u.y;
                mat_xform_hom(xnull,xform,v);
                var v0x, v0y;
                var vox = v0x = vx;
                var voy = v0y = vy;
                IterIte(u, poly.gverts, poly.gverts.begin().next, {
                    vx = u.x;
                    vy = u.y;
                    mat_xform_hom(xnull,xform,v);
                    drawLine(vox,voy, vx,vy, col);
                    vox = vx;
                    voy = vy;
                });
                drawLine(vox,voy, v0x,v0y, col);

                if(outer.drawShapeAngleIndicators) {
                    poly.validate_worldCOM();
                    mat_xform_hom(xnull,xform,poly.worldCOM,v);
                    drawLine(vx,vy, vox,voy, col);
                }
            }

            if(outer.drawShapeDetail) {
                shape.validate_worldCOM();
                var col2 = __tint(col,0xff0000,0.8);
                vec_new(v); mat_xform_hom(xnull,xform,shape.worldCOM,v);
                drawCircle(vx,vy, 1, col2);

                shape.validate_aabb();
                drawRectangle(shape.aabb.minx, shape.aabb.miny, shape.aabb.maxx, shape.aabb.maxy, col2);
            }
        }
    }

    public function draw_arbiter(arb:PR(Arbiter),xform:PR(Mat23),xdet:Float,xnull:Bool) {
    }
}
#end
