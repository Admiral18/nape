<?xml version="1.0" encoding="utf-8" ?>
<data>

<swf name="Milestone 3 - Demo 01" package="">
	<long>
		<br/>
		<text>Assorted demo of fluid interaction/kinematic objects/filtering</text>
		<br/>
		<br/>
		<swf centre="true" file="m301.swf" width="800" height="600"/>
		<br/>
		<br/>
		<link type="relative" anchor="AS3">AS3 Source</link><br/>
		<link type="relative" anchor="haXe">haXe Source</link><br/>
		<br/>
		<hr/>
		<br/>
		<anch name="AS3"/><text class="header2">AS3 Source</text>
		<br/>
		<code><![CDATA[package {
	import flash.Boot;
	import flash.display.Sprite;
	import flash.events.Event;
	import nape.dynamics.InteractionFilter;
	import nape.phys.Body
	import nape.phys.BodyKind;
	import nape.phys.FluidProperties;
	import nape.phys.PhysObj;
	import nape.shape.Shape;
	import nape.shape.Polygon;
	import nape.shape.Circle;
	import nape.space.Space;
	import nape.util.Debug;
	
	/**
	 * @author dELtaluca
	 */
	public class Main extends Sprite {
		public function Main():void {
			if (stage) init();
			else addEventListener(Event.ADDED_TO_STAGE, init);
		}
		
		private function init(e:Event = null):void {
			new Boot();
			removeEventListener(Event.ADDED_TO_STAGE, init);
			// entry point

			var space:Space = new Space();
			space.gravity.y = 400;

			var debug:Debug = new Debug();
			debug.drawCollisionArbiters = true;
			debug.drawFluidArbiters = true;
			
			stage.quality = flash.display.StageQuality.MEDIUM;
			
			// create border
			var body:Body = new Body(BodyKind.STATIC);
			body.shapes.add(new Polygon(Polygon.rect(0, 0, 10, 600)));
			body.shapes.add(new Polygon(Polygon.rect(0, 0, 800, 10)));
			body.shapes.add(new Polygon(Polygon.rect(800, 0, -10, 600)));
			body.shapes.add(new Polygon(Polygon.rect(0, 600, 800, -10)));
			space.objects.add(body);
			
			// create fluid objects
			body = new Body(BodyKind.STATIC);
			var poly:Polygon = new Polygon(Polygon.rect(0, 400, 800, 200));
			body.shapes.add(poly);
			poly.fluidEnabled = true;
			poly.fluidProperties = new FluidProperties(2, 5);
			space.objects.add(body);
			
			body = new Body(BodyKind.KINEMATIC);
			var circle:Circle = new Circle(60);
			body.shapes.add(circle);
			
			circle.fluidEnabled = true;
			circle.fluidProperties = new FluidProperties(3, 10);
			
			body.position.y = 300;
			for (var i:int = 0; i < 6; i++) {
				if(i!=0) body = Body.copy(body);
				body.position.x = 400 + (i - 2.5) * 130;
				space.objects.add(body);
			}
			
			// create other objects
			var body1:Body = new Body(BodyKind.DYNAMIC);
			body1.shapes.add(new Polygon(Polygon.box(20, 20)));
			var body2:Body = new Body(BodyKind.DYNAMIC);
			body2.shapes.add(new Circle(10));
			
			for (var x:int = 0; x < 30; x++) {
				for (var y:int = 0; y < 6; y++) {
					body = Body.copy(((x+y)%2==0) ? body1 : body2);
					body.position.x = 400 + (x - 14.5) * 20;
					body.position.y = y < 3 ? 150 + y * 20 : 450 - (y-3) * 20;
					space.objects.add(body);
				}
			}
			
			var stamp:int = 0;
			addEventListener(Event.ENTER_FRAME, function (ev:Event):void {
				//iterate kinematics (aka fluid objects)
				for (var i:int = 0; i < space.kinematics.length; i++) {
					var fluid:Body = space.kinematics.at(i);
					fluid.position.y = 300 + 280 * Math.sin(stamp / 300 * (i + 1));
					fluid.rotation += (i < space.kinematics.length / 2) ? -0.05 : 0.05;
				}
				
				space.step(1 / 60);
				stamp++;
				
				graphics.clear();
				debug.draw(graphics, space);
			});
		}
	}
}]]></code>
		<br/>
		<hr/>
		<br/>
		<anch name="haXe"/><text class="header2">haXe Source</text>
		<br/>
		<code><![CDATA[package;

import nape.dynamics.InteractionFilter;
import nape.phys.Body
import nape.phys.BodyKind;
import nape.phys.FluidProperties;
import nape.phys.PhysObj;
import nape.shape.Shape;
import nape.shape.Polygon;
import nape.shape.Circle;
import nape.space.Space;
import nape.util.Debug;

/**
 * @author dELtaluca
 */
class Main {
	static function main() {
		var space = new Space();
		space.gravity.y = 400;
		
		var debug = new Debug();
		debug.drawCollisionArbiters = true;
		debug.drawFluidArbiters = true;
			
		flash.Lib.current.stage.quality = flash.display.StageQuality.MEDIUM;
		
		// create border
		var body = new Body(BodyKind.STATIC);
		body.shapes.add(new Polygon(Polygon.rect(0, 0, 10, 600)));
		body.shapes.add(new Polygon(Polygon.rect(0, 0, 800, 10)));
		body.shapes.add(new Polygon(Polygon.rect(800, 0, -10, 600)));
		body.shapes.add(new Polygon(Polygon.rect(0, 600, 800,-10)));
		space.objects.add(body);
		
		// create fluid objects
		body = new Body(BodyKind.STATIC);
		var poly = new Polygon(Polygon.rect(0, 400, 800, 200));
		body.shapes.add(poly);
		poly.fluidEnabled = true;
		poly.fluidProperties = new FluidProperties(2, 5);
		space.objects.add(body);
			
		body = new Body(BodyKind.KINEMATIC);
		var circle = new Circle(60);
		body.shapes.add(circle);
		
		circle.fluidEnabled = true;
		circle.fluidProperties = new FluidProperties(3, 10);
		
		body.position.y = 300;
		for(i in 0...6) {
			if(i!=0) body = Body.copy(body);
			body.position.x = 400 + (i - 2.5) * 130;
			space.objects.add(body);
		}
		
		// create other objects
		var body1 = new Body(BodyKind.DYNAMIC);
		body1.shapes.add(new Polygon(Polygon.box(20, 20)));
		var body2 = new Body(BodyKind.DYNAMIC);
		body2.shapes.add(new Circle(10));
		
		for(x in 0...30) {
			for(y in 0...6) {
				var body = Body.copy(((x+y)%2==0) ? body1 : body2);
				body.position.x = 400 + (x - 14.5) * 20;
				body.position.y = y < 3 ? 150 + y * 20 : 450 - (y-3) * 20;
				space.objects.add(body);
			}
		}
		
		var stamp = 0;
		flash.Lib.current.addEventListener(flash.events.Event.ENTER_FRAME, function (_) {
			//iterate kinematics (aka fluid objects)
			var i = 0;
			for(fluid in space.kinematics) {
				fluid.position.y = 300 + 280 * Math.sin(stamp / 300 * (i + 1));
				fluid.rotation += (i < space.kinematics.length / 2) ? -0.05 : 0.05;
				i++;
			}
			
			space.step(1 / 60);
			stamp++;
			
			flash.Lib.current.graphics.clear();
			debug.draw(flash.Lib.current.graphics, space);
		});
	}
}]]></code>
	</long>
</swf>
	
</data>