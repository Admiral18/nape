<?xml version="1.0" encoding="utf-8" ?>
<data>

<swf name="Milestone 2 - Demo 01" package="">
	<long>
		<br/>
		<text>Assorted demo of fluid interaction/kinematic objects/filtering</text>
		<br/>
		<text>There is of course, still no broadphase collision detection in alpha nape! So this is a pretty intensive simulation, especcialy since everything is being redrawn every frame, and all arbiter information (bar sensors) are drawn too!</text>
		<br/>
		<br/>
		<swf centre="true" file="m201.swf" width="800" height="600"/>
		<br/>
		<br/>
		<link type="relative" anchor="AS3">AS3 Source</link><br/>
		<link type="relative" anchor="haXe">haXe Source</link><br/>
		<br/>
		<hr/>
		<br/>
		<anch name="AS3"/><text class="header2">AS3 Source</text>
		<br/>
		<code><![CDATA[package {
	import flash.Boot;
	import flash.display.Sprite;
	import flash.events.Event;
	import nape.dynamics.InteractionFilter;
	import nape.phys.Body
	import nape.phys.BodyKind;
	import nape.phys.FluidProperties;
	import nape.phys.PhysObj;
	import nape.shape.Shape;
	import nape.shape.Circle;
	import nape.space.BruteSpace;
	import nape.space.Space;
	import nape.util.Debug;
	
	/**
	 * @author dELtaluca
	 */
	public class Main extends Sprite {
		public function Main():void {
			if (stage) init();
			else addEventListener(Event.ADDED_TO_STAGE, init);
		}
		
		private function init(e:Event = null):void {
			new Boot();
			removeEventListener(Event.ADDED_TO_STAGE, init);
			// entry point

			var space:Space = new BruteSpace();
			space.gravity.y = 400;
			var debug:Debug = new Debug();
			stage.quality = flash.display.StageQuality.MEDIUM;
			
			// create border
			var body:Body = new Body(BodyKind.STATIC);
			body.shapes.add(new Circle(10));
			
			for (var x:int = 0; x <= 40; x++) {
				if(x!=0) body = Body.copy(body);
				body.position.setxy(x * 20, 0);
				space.objects.add(body);
				
				body = Body.copy(body);
				body.position.y = 600;
				space.objects.add(body);
				
				if (x > 0 && x < 30) {
					body = Body.copy(body);
					body.position.setxy(0, x * 20);
					space.objects.add(body);
					
					body = Body.copy(body);
					body.position.x = 800;
					space.objects.add(body);
				}
			}
			
			// create fluid objects
			body = new Body(BodyKind.KINEMATIC);
			var circle:Circle = new Circle(60);
			body.shapes.add(circle);
			
			circle.fluidEnabled = true;
			circle.fluidProperties = new FluidProperties(3, 10);
			
			body.position.y = 300;
			for (var i:int = 0; i < 6; i++) {
				if(i!=0) body = Body.copy(body);
				body.position.x = 400 + (i - 2.5) * 130;
				space.objects.add(body);
			}
			
			// create other objects
			body = new Body(BodyKind.DYNAMIC);
			body.shapes.add(new Circle(10));
			
			for (x = 0; x < 30; x++) {
				for (var y:int = 0; y < 4; y++) {
					if (x != 0 || y != 0) body = Body.copy(body);
					body.position.x = 400 + (x - 14.5) * 20;
					body.position.y = y < 2 ? 150 + y * 20 : 450 - (y-2) * 20;
					space.objects.add(body);
				}
			}
			
			var stamp:int = 0;
			addEventListener(Event.ENTER_FRAME, function (ev:Event):void {
				//iterate kinematics (aka fluid objects)
				for (var i:int = 0; i < space.kinematics.length; i++) {
					var fluid:Body = space.kinematics.at(i);
					fluid.position.y = 300 + 280 * Math.sin(stamp / 200 * (i + 1));
					fluid.rotation += (i < space.kinematics.length / 2) ? -0.1 : 0.1;
				}
				
				space.step(1 / 60);
				stamp++;
				
				graphics.clear();
				debug.draw(graphics, space);
			});
		}
	}
}]]></code>
		<br/>
		<hr/>
		<br/>
		<anch name="haXe"/><text class="header2">haXe Source</text>
		<br/>
		<code><![CDATA[package;

import nape.dynamics.InteractionFilter;
import nape.phys.Body
import nape.phys.BodyKind;
import nape.phys.FluidProperties;
import nape.phys.PhysObj;
import nape.shape.Shape;
import nape.shape.Circle;
import nape.space.BruteSpace;
import nape.space.Space;
import nape.util.Debug;

/**
 * @author dELtaluca
 */
class Main {
	static function main() {
		var space = new BruteSpace();
		space.gravity.y = 400;
		var debug = new Debug();
		flash.Lib.current.stage.quality = flash.display.StageQuality.MEDIUM;
		
		// create border
		var body = new Body(BodyKind.STATIC);
		body.shapes.add(new Circle(10));
		
		for(x in 0...41) {
			if(x!=0) body = Body.copy(body);
			body.position.setxy(x * 20, 0);
			space.objects.add(body);
			
			body = Body.copy(body);
			body.position.y = 600;
			space.objects.add(body);
			
			if (x > 0 && x < 30) {
				body = Body.copy(body);
				body.position.setxy(0, x * 20);
				space.objects.add(body);
				
				body = Body.copy(body);
				body.position.x = 800;
				space.objects.add(body);
			}
		}
		
		// create fluid objects
		body = new Body(BodyKind.KINEMATIC);
		var circle = new Circle(60);
		body.shapes.add(circle);
		
		circle.fluidEnabled = true;
		circle.fluidProperties = new FluidProperties(3, 10);
		
		body.position.y = 300;
		for(i in 0...6) {
			if(i!=0) body = Body.copy(body);
			body.position.x = 400 + (i - 2.5) * 130;
			space.objects.add(body);
		}
		
		// create other objects
		body = new Body(BodyKind.DYNAMIC);
		body.shapes.add(new Circle(10));
			
		for(x in 0...30) {
			for(y in 0...4) {
				if (x != 0 || y != 0) body = Body.copy(body);
				body.position.x = 400 + (x - 14.5) * 20;
				body.position.y = y < 2 ? 150 + y * 20 : 450 - (y-2) * 20;
				space.objects.add(body);
			}
		}
		
		var stamp = 0;
		flash.Lib.current.addEventListener(flash.events.Event.ENTER_FRAME, function (_) {
			//iterate kinematics (aka fluid objects)
			var i = 0;
			for(fluid in space.kinematics) {
				fluid.position.y = 300 + 280 * Math.sin(stamp / 200 * (i + 1));
				fluid.rotation += (i < space.kinematics.length / 2) ? -0.1 : 0.1;
				i++;
			}
			
			space.step(1 / 60);
			stamp++;
			
			flash.Lib.current.graphics.clear();
			debug.draw(flash.Lib.current.graphics, space);
		});
	}
}]]></code>
	</long>
</swf>
	
</data>